[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/datetime.js",
    "content": "import Duration, { friendlyDuration } from \"./duration.js\";\r\nimport Interval from \"./interval.js\";\r\nimport Settings from \"./settings.js\";\r\nimport Info from \"./info.js\";\r\nimport Formatter from \"./impl/formatter.js\";\r\nimport FixedOffsetZone from \"./zones/fixedOffsetZone.js\";\r\nimport Locale from \"./impl/locale.js\";\r\nimport {\r\n  isUndefined,\r\n  maybeArray,\r\n  isDate,\r\n  isNumber,\r\n  bestBy,\r\n  daysInMonth,\r\n  daysInYear,\r\n  isLeapYear,\r\n  weeksInWeekYear,\r\n  normalizeObject,\r\n  roundTo,\r\n  objToLocalTS\r\n} from \"./impl/util.js\";\r\nimport { normalizeZone } from \"./impl/zoneUtil.js\";\r\nimport diff from \"./impl/diff.js\";\r\nimport { parseRFC2822Date, parseISODate, parseHTTPDate, parseSQL } from \"./impl/regexParser.js\";\r\nimport { parseFromTokens, explainFromTokens } from \"./impl/tokenParser.js\";\r\nimport {\r\n  gregorianToWeek,\r\n  weekToGregorian,\r\n  gregorianToOrdinal,\r\n  ordinalToGregorian,\r\n  hasInvalidGregorianData,\r\n  hasInvalidWeekData,\r\n  hasInvalidOrdinalData,\r\n  hasInvalidTimeData\r\n} from \"./impl/conversions.js\";\r\nimport * as Formats from \"./impl/formats.js\";\r\nimport {\r\n  InvalidArgumentError,\r\n  ConflictingSpecificationError,\r\n  InvalidUnitError,\r\n  InvalidDateTimeError\r\n} from \"./errors.js\";\r\nimport Invalid from \"./impl/invalid.js\";\r\n\r\nconst INVALID = \"Invalid DateTime\";\r\n\r\nfunction unsupportedZone(zone) {\r\n  return new Invalid(\"unsupported zone\", `the zone \"${zone.name}\" is not supported`);\r\n}\r\n\r\n// we cache week data on the DT object and this intermediates the cache\r\nfunction possiblyCachedWeekData(dt) {\r\n  if (dt.weekData === null) {\r\n    dt.weekData = gregorianToWeek(dt.c);\r\n  }\r\n  return dt.weekData;\r\n}\r\n\r\n// clone really means, \"make a new object with these modifications\". all \"setters\" really use this\r\n// to create a new object while only changing some of the properties\r\nfunction clone(inst, alts) {\r\n  const current = {\r\n    ts: inst.ts,\r\n    zone: inst.zone,\r\n    c: inst.c,\r\n    o: inst.o,\r\n    loc: inst.loc,\r\n    invalid: inst.invalid\r\n  };\r\n  return new DateTime(Object.assign({}, current, alts, { old: current }));\r\n}\r\n\r\n// find the right offset a given local time. The o input is our guess, which determines which\r\n// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)\r\nfunction fixOffset(localTS, o, tz) {\r\n  // Our UTC time is just a guess because our offset is just a guess\r\n  let utcGuess = localTS - o * 60 * 1000;\r\n\r\n  // Test whether the zone matches the offset for this ts\r\n  const o2 = tz.offset(utcGuess);\r\n\r\n  // If so, offset didn't change and we're done\r\n  if (o === o2) {\r\n    return [utcGuess, o];\r\n  }\r\n\r\n  // If not, change the ts by the difference in the offset\r\n  utcGuess -= (o2 - o) * 60 * 1000;\r\n\r\n  // If that gives us the local time we want, we're done\r\n  const o3 = tz.offset(utcGuess);\r\n  if (o2 === o3) {\r\n    return [utcGuess, o2];\r\n  }\r\n\r\n  // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time\r\n  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];\r\n}\r\n\r\n// convert an epoch timestamp into a calendar object with the given offset\r\nfunction tsToObj(ts, offset) {\r\n  ts += offset * 60 * 1000;\r\n\r\n  const d = new Date(ts);\r\n\r\n  return {\r\n    year: d.getUTCFullYear(),\r\n    month: d.getUTCMonth() + 1,\r\n    day: d.getUTCDate(),\r\n    hour: d.getUTCHours(),\r\n    minute: d.getUTCMinutes(),\r\n    second: d.getUTCSeconds(),\r\n    millisecond: d.getUTCMilliseconds()\r\n  };\r\n}\r\n\r\n// convert a calendar object to a epoch timestamp\r\nfunction objToTS(obj, offset, zone) {\r\n  return fixOffset(objToLocalTS(obj), offset, zone);\r\n}\r\n\r\n// create a new DT instance by adding a duration, adjusting for DSTs\r\nfunction adjustTime(inst, dur) {\r\n  const oPre = inst.o,\r\n    year = inst.c.year + dur.years,\r\n    month = inst.c.month + dur.months + dur.quarters * 3,\r\n    c = Object.assign({}, inst.c, {\r\n      year,\r\n      month,\r\n      day: Math.min(inst.c.day, daysInMonth(year, month)) + dur.days + dur.weeks * 7\r\n    }),\r\n    millisToAdd = Duration.fromObject({\r\n      hours: dur.hours,\r\n      minutes: dur.minutes,\r\n      seconds: dur.seconds,\r\n      milliseconds: dur.milliseconds\r\n    }).as(\"milliseconds\"),\r\n    localTS = objToLocalTS(c);\r\n\r\n  let [ts, o] = fixOffset(localTS, oPre, inst.zone);\r\n\r\n  if (millisToAdd !== 0) {\r\n    ts += millisToAdd;\r\n    // that could have changed the offset by going over a DST, but we want to keep the ts the same\r\n    o = inst.zone.offset(ts);\r\n  }\r\n\r\n  return { ts, o };\r\n}\r\n\r\n// helper useful in turning the results of parsing into real dates\r\n// by handling the zone options\r\nfunction parseDataToDateTime(parsed, parsedZone, opts, format, text) {\r\n  const { setZone, zone } = opts;\r\n  if (parsed && Object.keys(parsed).length !== 0) {\r\n    const interpretationZone = parsedZone || zone,\r\n      inst = DateTime.fromObject(\r\n        Object.assign(parsed, opts, {\r\n          zone: interpretationZone,\r\n          // setZone is a valid option in the calling methods, but not in fromObject\r\n          setZone: undefined\r\n        })\r\n      );\r\n    return setZone ? inst : inst.setZone(zone);\r\n  } else {\r\n    return DateTime.invalid(\r\n      new Invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ${format}`)\r\n    );\r\n  }\r\n}\r\n\r\n// if you want to output a technical format (e.g. RFC 2822), this helper\r\n// helps handle the details\r\nfunction toTechFormat(dt, format) {\r\n  return dt.isValid\r\n    ? Formatter.create(Locale.create(\"en-US\"), {\r\n        allowZ: true,\r\n        forceSimple: true\r\n      }).formatDateTimeFromString(dt, format)\r\n    : null;\r\n}\r\n\r\n// technical time formats (e.g. the time part of ISO 8601), take some options\r\n// and this commonizes their handling\r\nfunction toTechTimeFormat(\r\n  dt,\r\n  {\r\n    suppressSeconds = false,\r\n    suppressMilliseconds = false,\r\n    includeOffset,\r\n    includeZone = false,\r\n    spaceZone = false\r\n  }\r\n) {\r\n  let fmt = \"HH:mm\";\r\n\r\n  if (!suppressSeconds || dt.second !== 0 || dt.millisecond !== 0) {\r\n    fmt += \":ss\";\r\n    if (!suppressMilliseconds || dt.millisecond !== 0) {\r\n      fmt += \".SSS\";\r\n    }\r\n  }\r\n\r\n  if ((includeZone || includeOffset) && spaceZone) {\r\n    fmt += \" \";\r\n  }\r\n\r\n  if (includeZone) {\r\n    fmt += \"z\";\r\n  } else if (includeOffset) {\r\n    fmt += \"ZZ\";\r\n  }\r\n\r\n  return toTechFormat(dt, fmt);\r\n}\r\n\r\n// defaults for unspecified units in the supported calendars\r\nconst defaultUnitValues = {\r\n    month: 1,\r\n    day: 1,\r\n    hour: 0,\r\n    minute: 0,\r\n    second: 0,\r\n    millisecond: 0\r\n  },\r\n  defaultWeekUnitValues = {\r\n    weekNumber: 1,\r\n    weekday: 1,\r\n    hour: 0,\r\n    minute: 0,\r\n    second: 0,\r\n    millisecond: 0\r\n  },\r\n  defaultOrdinalUnitValues = {\r\n    ordinal: 1,\r\n    hour: 0,\r\n    minute: 0,\r\n    second: 0,\r\n    millisecond: 0\r\n  };\r\n\r\n// Units in the supported calendars, sorted by bigness\r\nconst orderedUnits = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"millisecond\"],\r\n  orderedWeekUnits = [\r\n    \"weekYear\",\r\n    \"weekNumber\",\r\n    \"weekday\",\r\n    \"hour\",\r\n    \"minute\",\r\n    \"second\",\r\n    \"millisecond\"\r\n  ],\r\n  orderedOrdinalUnits = [\"year\", \"ordinal\", \"hour\", \"minute\", \"second\", \"millisecond\"];\r\n\r\n// standardize case and plurality in units\r\nfunction normalizeUnit(unit) {\r\n  const normalized = {\r\n    year: \"year\",\r\n    years: \"year\",\r\n    month: \"month\",\r\n    months: \"month\",\r\n    day: \"day\",\r\n    days: \"day\",\r\n    hour: \"hour\",\r\n    hours: \"hour\",\r\n    minute: \"minute\",\r\n    minutes: \"minute\",\r\n    second: \"second\",\r\n    seconds: \"second\",\r\n    millisecond: \"millisecond\",\r\n    milliseconds: \"millisecond\",\r\n    weekday: \"weekday\",\r\n    weekdays: \"weekday\",\r\n    weeknumber: \"weekNumber\",\r\n    weeksnumber: \"weekNumber\",\r\n    weeknumbers: \"weekNumber\",\r\n    weekyear: \"weekYear\",\r\n    weekyears: \"weekYear\",\r\n    ordinal: \"ordinal\"\r\n  }[unit.toLowerCase()];\r\n\r\n  if (!normalized) throw new InvalidUnitError(unit);\r\n\r\n  return normalized;\r\n}\r\n\r\n// this is a dumbed down version of fromObject() that runs about 60% faster\r\n// but doesn't do any validation, makes a bunch of assumptions about what units\r\n// are present, and so on.\r\nfunction quickDT(obj, zone) {\r\n  // assume we have the higher-order units\r\n  for (const u of orderedUnits) {\r\n    if (isUndefined(obj[u])) {\r\n      obj[u] = defaultUnitValues[u];\r\n    }\r\n  }\r\n\r\n  const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);\r\n  if (invalid) {\r\n    return DateTime.invalid(invalid);\r\n  }\r\n\r\n  const tsNow = Settings.now(),\r\n    offsetProvis = zone.offset(tsNow),\r\n    [ts, o] = objToTS(obj, offsetProvis, zone);\r\n\r\n  return new DateTime({\r\n    ts,\r\n    zone,\r\n    o\r\n  });\r\n}\r\n\r\nfunction diffRelative(start, end, opts) {\r\n  const round = isUndefined(opts.round) ? true : opts.round,\r\n    format = (c, unit) => {\r\n      c = roundTo(c, round || opts.calendary ? 0 : 2, true);\r\n      const formatter = end.loc.clone(opts).relFormatter(opts);\r\n      return formatter.format(c, unit);\r\n    },\r\n    differ = unit => {\r\n      if (opts.calendary) {\r\n        if (!end.hasSame(start, unit)) {\r\n          return end\r\n            .startOf(unit)\r\n            .diff(start.startOf(unit), unit)\r\n            .get(unit);\r\n        } else return 0;\r\n      } else {\r\n        return end.diff(start, unit).get(unit);\r\n      }\r\n    };\r\n\r\n  if (opts.unit) {\r\n    return format(differ(opts.unit), opts.unit);\r\n  }\r\n\r\n  for (const unit of opts.units) {\r\n    const count = differ(unit);\r\n    if (Math.abs(count) >= 1) {\r\n      return format(count, unit);\r\n    }\r\n  }\r\n  return format(0, opts.units[opts.units.length - 1]);\r\n}\r\n\r\n/**\r\n * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.\r\n *\r\n * A DateTime comprises of:\r\n * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.\r\n * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).\r\n * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.\r\n *\r\n * Here is a brief overview of the most commonly used functionality it provides:\r\n *\r\n * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link local}, {@link utc}, and (most flexibly) {@link fromObject}. To create one from a standard string format, use {@link fromISO}, {@link fromHTTP}, and {@link fromRFC2822}. To create one from a custom string format, use {@link fromFormat}. To create one from a native JS date, use {@link fromJSDate}.\r\n * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link toObject}), use the {@link year}, {@link month},\r\n * {@link day}, {@link hour}, {@link minute}, {@link second}, {@link millisecond} accessors.\r\n * * **Week calendar**: For ISO week calendar attributes, see the {@link weekYear}, {@link weekNumber}, and {@link weekday} accessors.\r\n * * **Configuration** See the {@link locale} and {@link numberingSystem} accessors.\r\n * * **Transformation**: To transform the DateTime into other DateTimes, use {@link set}, {@link reconfigure}, {@link setZone}, {@link setLocale}, {@link plus}, {@link minus}, {@link endOf}, {@link startOf}, {@link toUTC}, and {@link toLocal}.\r\n * * **Output**: To convert the DateTime to other representations, use the {@link toRelative}, {@link toRelativeCalendar}, {@link toJSON}, {@link toISO}, {@link toHTTP}, {@link toObject}, {@link toRFC2822}, {@link toString}, {@link toLocaleString}, {@link toFormat}, {@link toMillis} and {@link toJSDate}.\r\n *\r\n * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.\r\n */\r\nexport default class DateTime {\r\n  /**\r\n   * @access private\r\n   */\r\n  constructor(config) {\r\n    const zone = config.zone || Settings.defaultZone,\r\n      invalid =\r\n        config.invalid ||\r\n        (Number.isNaN(config.ts) ? new Invalid(\"invalid input\") : null) ||\r\n        (!zone.isValid ? unsupportedZone(zone) : null);\r\n    /**\r\n     * @access private\r\n     */\r\n    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;\r\n\r\n    let c = null,\r\n      o = null;\r\n    if (!invalid) {\r\n      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);\r\n      c = unchanged ? config.old.c : tsToObj(this.ts, zone.offset(this.ts));\r\n      o = unchanged ? config.old.o : zone.offset(this.ts);\r\n    }\r\n\r\n    /**\r\n     * @access private\r\n     */\r\n    this._zone = zone;\r\n    /**\r\n     * @access private\r\n     */\r\n    this.loc = config.loc || Locale.create();\r\n    /**\r\n     * @access private\r\n     */\r\n    this.invalid = invalid;\r\n    /**\r\n     * @access private\r\n     */\r\n    this.weekData = null;\r\n    /**\r\n     * @access private\r\n     */\r\n    this.c = c;\r\n    /**\r\n     * @access private\r\n     */\r\n    this.o = o;\r\n    /**\r\n     * @access private\r\n     */\r\n    this.isLuxonDateTime = true;\r\n  }\r\n\r\n  // CONSTRUCT\r\n\r\n  /**\r\n   * Create a local DateTime\r\n   * @param {number} year - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used\r\n   * @param {number} [month=1] - The month, 1-indexed\r\n   * @param {number} [day=1] - The day of the month\r\n   * @param {number} [hour=0] - The hour of the day, in 24-hour time\r\n   * @param {number} [minute=0] - The minute of the hour, i.e. a number between 0 and 59\r\n   * @param {number} [second=0] - The second of the minute, i.e. a number between 0 and 59\r\n   * @param {number} [millisecond=0] - The millisecond of the second, i.e. a number between 0 and 999\r\n   * @example DateTime.local()                            //~> now\r\n   * @example DateTime.local(2017)                        //~> 2017-01-01T00:00:00\r\n   * @example DateTime.local(2017, 3)                     //~> 2017-03-01T00:00:00\r\n   * @example DateTime.local(2017, 3, 12)                 //~> 2017-03-12T00:00:00\r\n   * @example DateTime.local(2017, 3, 12, 5)              //~> 2017-03-12T05:00:00\r\n   * @example DateTime.local(2017, 3, 12, 5, 45)          //~> 2017-03-12T05:45:00\r\n   * @example DateTime.local(2017, 3, 12, 5, 45, 10)      //~> 2017-03-12T05:45:10\r\n   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765\r\n   * @return {DateTime}\r\n   */\r\n  static local(year, month, day, hour, minute, second, millisecond) {\r\n    if (isUndefined(year)) {\r\n      return new DateTime({ ts: Settings.now() });\r\n    } else {\r\n      return quickDT(\r\n        {\r\n          year,\r\n          month,\r\n          day,\r\n          hour,\r\n          minute,\r\n          second,\r\n          millisecond\r\n        },\r\n        Settings.defaultZone\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a DateTime in UTC\r\n   * @param {number} year - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used\r\n   * @param {number} [month=1] - The month, 1-indexed\r\n   * @param {number} [day=1] - The day of the month\r\n   * @param {number} [hour=0] - The hour of the day, in 24-hour time\r\n   * @param {number} [minute=0] - The minute of the hour, i.e. a number between 0 and 59\r\n   * @param {number} [second=0] - The second of the minute, i.e. a number between 0 and 59\r\n   * @param {number} [millisecond=0] - The millisecond of the second, i.e. a number between 0 and 999\r\n   * @example DateTime.utc()                            //~> now\r\n   * @example DateTime.utc(2017)                        //~> 2017-01-01T00:00:00Z\r\n   * @example DateTime.utc(2017, 3)                     //~> 2017-03-01T00:00:00Z\r\n   * @example DateTime.utc(2017, 3, 12)                 //~> 2017-03-12T00:00:00Z\r\n   * @example DateTime.utc(2017, 3, 12, 5)              //~> 2017-03-12T05:00:00Z\r\n   * @example DateTime.utc(2017, 3, 12, 5, 45)          //~> 2017-03-12T05:45:00Z\r\n   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)      //~> 2017-03-12T05:45:10Z\r\n   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765Z\r\n   * @return {DateTime}\r\n   */\r\n  static utc(year, month, day, hour, minute, second, millisecond) {\r\n    if (isUndefined(year)) {\r\n      return new DateTime({\r\n        ts: Settings.now(),\r\n        zone: FixedOffsetZone.utcInstance\r\n      });\r\n    } else {\r\n      return quickDT(\r\n        {\r\n          year,\r\n          month,\r\n          day,\r\n          hour,\r\n          minute,\r\n          second,\r\n          millisecond\r\n        },\r\n        FixedOffsetZone.utcInstance\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a DateTime from a Javascript Date object. Uses the default zone.\r\n   * @param {Date} date - a Javascript Date object\r\n   * @param {Object} options - configuration options for the DateTime\r\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\r\n   * @return {DateTime}\r\n   */\r\n  static fromJSDate(date, options = {}) {\r\n    const ts = isDate(date) ? date.valueOf() : NaN;\r\n    if (Number.isNaN(ts)) {\r\n      return DateTime.invalid(\"invalid input\");\r\n    }\r\n\r\n    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);\r\n    if (!zoneToUse.isValid) {\r\n      return DateTime.invalid(unsupportedZone(zoneToUse));\r\n    }\r\n\r\n    return new DateTime({\r\n      ts: ts,\r\n      zone: zoneToUse,\r\n      loc: Locale.fromObject(options)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create a DateTime from a number of milliseconds since the epoch (i.e. since 1 January 1970 00:00:00 UTC). Uses the default zone.\r\n   * @param {number} milliseconds - a number of milliseconds since 1970 UTC\r\n   * @param {Object} options - configuration options for the DateTime\r\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\r\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\r\n   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance\r\n   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance\r\n   * @return {DateTime}\r\n   */\r\n  static fromMillis(milliseconds, options = {}) {\r\n    if (!isNumber(milliseconds)) {\r\n      throw new InvalidArgumentError(\"fromMillis requires a numerical input\");\r\n    } else {\r\n      return new DateTime({\r\n        ts: milliseconds,\r\n        zone: normalizeZone(options.zone, Settings.defaultZone),\r\n        loc: Locale.fromObject(options)\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a DateTime from a number of seconds since the epoch (i.e. since 1 January 1970 00:00:00 UTC). Uses the default zone.\r\n   * @param {number} seconds - a number of seconds since 1970 UTC\r\n   * @param {Object} options - configuration options for the DateTime\r\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\r\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\r\n   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance\r\n   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance\r\n   * @return {DateTime}\r\n   */\r\n  static fromSeconds(seconds, options = {}) {\r\n    if (!isNumber(seconds)) {\r\n      throw new InvalidArgumentError(\"fromSeconds requires a numerical input\");\r\n    } else {\r\n      return new DateTime({\r\n        ts: seconds * 1000,\r\n        zone: normalizeZone(options.zone, Settings.defaultZone),\r\n        loc: Locale.fromObject(options)\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a DateTime from a Javascript object with keys like 'year' and 'hour' with reasonable defaults.\r\n   * @param {Object} obj - the object to create the DateTime from\r\n   * @param {number} obj.year - a year, such as 1987\r\n   * @param {number} obj.month - a month, 1-12\r\n   * @param {number} obj.day - a day of the month, 1-31, depending on the month\r\n   * @param {number} obj.ordinal - day of the year, 1-365 or 366\r\n   * @param {number} obj.weekYear - an ISO week year\r\n   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year\r\n   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday\r\n   * @param {number} obj.hour - hour of the day, 0-23\r\n   * @param {number} obj.minute - minute of the hour, 0-59\r\n   * @param {number} obj.second - second of the minute, 0-59\r\n   * @param {number} obj.millisecond - millisecond of the second, 0-999\r\n   * @param {string|Zone} [obj.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()\r\n   * @param {string} [obj.locale='system's locale'] - a locale to set on the resulting DateTime instance\r\n   * @param {string} obj.outputCalendar - the output calendar to set on the resulting DateTime instance\r\n   * @param {string} obj.numberingSystem - the numbering system to set on the resulting DateTime instance\r\n   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'\r\n   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'\r\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06\r\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'utc' }),\r\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'local' })\r\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'America/New_York' })\r\n   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'\r\n   * @return {DateTime}\r\n   */\r\n  static fromObject(obj) {\r\n    const zoneToUse = normalizeZone(obj.zone, Settings.defaultZone);\r\n    if (!zoneToUse.isValid) {\r\n      return DateTime.invalid(unsupportedZone(zoneToUse));\r\n    }\r\n\r\n    const tsNow = Settings.now(),\r\n      offsetProvis = zoneToUse.offset(tsNow),\r\n      normalized = normalizeObject(obj, normalizeUnit, [\r\n        \"zone\",\r\n        \"locale\",\r\n        \"outputCalendar\",\r\n        \"numberingSystem\"\r\n      ]),\r\n      containsOrdinal = !isUndefined(normalized.ordinal),\r\n      containsGregorYear = !isUndefined(normalized.year),\r\n      containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),\r\n      containsGregor = containsGregorYear || containsGregorMD,\r\n      definiteWeekDef = normalized.weekYear || normalized.weekNumber,\r\n      loc = Locale.fromObject(obj);\r\n\r\n    // cases:\r\n    // just a weekday -> this week's instance of that weekday, no worries\r\n    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error\r\n    // (gregorian month or day) + ordinal -> error\r\n    // otherwise just use weeks or ordinals or gregorian, depending on what's specified\r\n\r\n    if ((containsGregor || containsOrdinal) && definiteWeekDef) {\r\n      throw new ConflictingSpecificationError(\r\n        \"Can't mix weekYear/weekNumber units with year/month/day or ordinals\"\r\n      );\r\n    }\r\n\r\n    if (containsGregorMD && containsOrdinal) {\r\n      throw new ConflictingSpecificationError(\"Can't mix ordinal dates with month/day\");\r\n    }\r\n\r\n    const useWeekData = definiteWeekDef || (normalized.weekday && !containsGregor);\r\n\r\n    // configure ourselves to deal with gregorian dates or week stuff\r\n    let units,\r\n      defaultValues,\r\n      objNow = tsToObj(tsNow, offsetProvis);\r\n    if (useWeekData) {\r\n      units = orderedWeekUnits;\r\n      defaultValues = defaultWeekUnitValues;\r\n      objNow = gregorianToWeek(objNow);\r\n    } else if (containsOrdinal) {\r\n      units = orderedOrdinalUnits;\r\n      defaultValues = defaultOrdinalUnitValues;\r\n      objNow = gregorianToOrdinal(objNow);\r\n    } else {\r\n      units = orderedUnits;\r\n      defaultValues = defaultUnitValues;\r\n    }\r\n\r\n    // set default values for missing stuff\r\n    let foundFirst = false;\r\n    for (const u of units) {\r\n      const v = normalized[u];\r\n      if (!isUndefined(v)) {\r\n        foundFirst = true;\r\n      } else if (foundFirst) {\r\n        normalized[u] = defaultValues[u];\r\n      } else {\r\n        normalized[u] = objNow[u];\r\n      }\r\n    }\r\n\r\n    // make sure the values we have are in range\r\n    const higherOrderInvalid = useWeekData\r\n        ? hasInvalidWeekData(normalized)\r\n        : containsOrdinal\r\n          ? hasInvalidOrdinalData(normalized)\r\n          : hasInvalidGregorianData(normalized),\r\n      invalid = higherOrderInvalid || hasInvalidTimeData(normalized);\r\n\r\n    if (invalid) {\r\n      return DateTime.invalid(invalid);\r\n    }\r\n\r\n    // compute the actual time\r\n    const gregorian = useWeekData\r\n        ? weekToGregorian(normalized)\r\n        : containsOrdinal\r\n          ? ordinalToGregorian(normalized)\r\n          : normalized,\r\n      [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),\r\n      inst = new DateTime({\r\n        ts: tsFinal,\r\n        zone: zoneToUse,\r\n        o: offsetFinal,\r\n        loc\r\n      });\r\n\r\n    // gregorian data + weekday serves only to validate\r\n    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {\r\n      return DateTime.invalid(\r\n        \"mismatched weekday\",\r\n        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`\r\n      );\r\n    }\r\n\r\n    return inst;\r\n  }\r\n\r\n  /**\r\n   * Create a DateTime from an ISO 8601 string\r\n   * @param {string} text - the ISO string\r\n   * @param {Object} opts - options to affect the creation\r\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone\r\n   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one\r\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\r\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\r\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\r\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123')\r\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')\r\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})\r\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})\r\n   * @example DateTime.fromISO('2016-W05-4')\r\n   * @return {DateTime}\r\n   */\r\n  static fromISO(text, opts = {}) {\r\n    const [vals, parsedZone] = parseISODate(text);\r\n    return parseDataToDateTime(vals, parsedZone, opts, \"ISO 8601\", text);\r\n  }\r\n\r\n  /**\r\n   * Create a DateTime from an RFC 2822 string\r\n   * @param {string} text - the RFC 2822 string\r\n   * @param {Object} opts - options to affect the creation\r\n   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\r\n   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one\r\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\r\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\r\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\r\n   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')\r\n   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')\r\n   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')\r\n   * @return {DateTime}\r\n   */\r\n  static fromRFC2822(text, opts = {}) {\r\n    const [vals, parsedZone] = parseRFC2822Date(text);\r\n    return parseDataToDateTime(vals, parsedZone, opts, \"RFC 2822\", text);\r\n  }\r\n\r\n  /**\r\n   * Create a DateTime from an HTTP header date\r\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\r\n   * @param {string} text - the HTTP header date\r\n   * @param {Object} opts - options to affect the creation\r\n   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\r\n   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.\r\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\r\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\r\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\r\n   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')\r\n   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')\r\n   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')\r\n   * @return {DateTime}\r\n   */\r\n  static fromHTTP(text, opts = {}) {\r\n    const [vals, parsedZone] = parseHTTPDate(text);\r\n    return parseDataToDateTime(vals, parsedZone, opts, \"HTTP\", opts);\r\n  }\r\n\r\n  /**\r\n   * Create a DateTime from an input string and format string.\r\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale.\r\n   * @see https://moment.github.io/luxon/docs/manual/parsing.html#table-of-tokens\r\n   * @param {string} text - the string to parse\r\n   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)\r\n   * @param {Object} opts - options to affect the creation\r\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone\r\n   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one\r\n   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale\r\n   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\r\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\r\n   * @return {DateTime}\r\n   */\r\n  static fromFormat(text, fmt, opts = {}) {\r\n    if (isUndefined(text) || isUndefined(fmt)) {\r\n      throw new InvalidArgumentError(\"fromFormat requires an input string and a format\");\r\n    }\r\n\r\n    const { locale = null, numberingSystem = null } = opts,\r\n      localeToUse = Locale.fromOpts({\r\n        locale,\r\n        numberingSystem,\r\n        defaultToEN: true\r\n      }),\r\n      [vals, parsedZone, invalid] = parseFromTokens(localeToUse, text, fmt);\r\n    if (invalid) {\r\n      return DateTime.invalid(invalid);\r\n    } else {\r\n      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @deprecated use fromFormat instead\r\n   */\r\n  static fromString(text, fmt, opts = {}) {\r\n    return DateTime.fromFormat(text, fmt, opts);\r\n  }\r\n\r\n  /**\r\n   * Create a DateTime from a SQL date, time, or datetime\r\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale\r\n   * @param {string} text - the string to parse\r\n   * @param {Object} opts - options to affect the creation\r\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone\r\n   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one\r\n   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale\r\n   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\r\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\r\n   * @example DateTime.fromSQL('2017-05-15')\r\n   * @example DateTime.fromSQL('2017-05-15 09:12:34')\r\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')\r\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')\r\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')\r\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })\r\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })\r\n   * @example DateTime.fromSQL('09:12:34.342')\r\n   * @return {DateTime}\r\n   */\r\n  static fromSQL(text, opts = {}) {\r\n    const [vals, parsedZone] = parseSQL(text);\r\n    return parseDataToDateTime(vals, parsedZone, opts, \"SQL\", text);\r\n  }\r\n\r\n  /**\r\n   * Create an invalid DateTime.\r\n   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent\r\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\r\n   * @return {DateTime}\r\n   */\r\n  static invalid(reason, explanation = null) {\r\n    if (!reason) {\r\n      throw new InvalidArgumentError(\"need to specify a reason the DateTime is invalid\");\r\n    }\r\n\r\n    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);\r\n\r\n    if (Settings.throwOnInvalid) {\r\n      throw new InvalidDateTimeError(invalid);\r\n    } else {\r\n      return new DateTime({ invalid });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if an object is a DateTime. Works across context boundaries\r\n   * @param {object} o\r\n   * @return {boolean}\r\n   */\r\n  static isDateTime(o) {\r\n    return (o && o.isLuxonDateTime) || false;\r\n  }\r\n\r\n  // INFO\r\n\r\n  /**\r\n   * Get the value of unit.\r\n   * @param {string} unit - a unit such as 'minute' or 'day'\r\n   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7\r\n   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4\r\n   * @return {number}\r\n   */\r\n  get(unit) {\r\n    return this[unit];\r\n  }\r\n\r\n  /**\r\n   * Returns whether the DateTime is valid. Invalid DateTimes occur when:\r\n   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30\r\n   * * The DateTime was created by an operation on another invalid date\r\n   * @type {boolean}\r\n   */\r\n  get isValid() {\r\n    return this.invalid === null;\r\n  }\r\n\r\n  /**\r\n   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid\r\n   * @type {string}\r\n   */\r\n  get invalidReason() {\r\n    return this.invalid ? this.invalid.reason : null;\r\n  }\r\n\r\n  /**\r\n   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid\r\n   * @type {string}\r\n   */\r\n  get invalidExplanation() {\r\n    return this.invalid ? this.invalid.explanation : null;\r\n  }\r\n\r\n  /**\r\n   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime\r\n   *\r\n   * @type {string}\r\n   */\r\n  get locale() {\r\n    return this.isValid ? this.loc.locale : null;\r\n  }\r\n\r\n  /**\r\n   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime\r\n   *\r\n   * @type {string}\r\n   */\r\n  get numberingSystem() {\r\n    return this.isValid ? this.loc.numberingSystem : null;\r\n  }\r\n\r\n  /**\r\n   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime\r\n   *\r\n   * @type {string}\r\n   */\r\n  get outputCalendar() {\r\n    return this.isValid ? this.loc.outputCalendar : null;\r\n  }\r\n\r\n  /**\r\n   * Get the time zone associated with this DateTime.\r\n   * @type {Zone}\r\n   */\r\n  get zone() {\r\n    return this._zone;\r\n  }\r\n\r\n  /**\r\n   * Get the name of the time zone.\r\n   * @type {string}\r\n   */\r\n  get zoneName() {\r\n    return this.isValid ? this.zone.name : null;\r\n  }\r\n\r\n  /**\r\n   * Get the year\r\n   * @example DateTime.local(2017, 5, 25).year //=> 2017\r\n   * @type {number}\r\n   */\r\n  get year() {\r\n    return this.isValid ? this.c.year : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the quarter\r\n   * @example DateTime.local(2017, 5, 25).quarter //=> 2\r\n   * @type {number}\r\n   */\r\n  get quarter() {\r\n    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the month (1-12).\r\n   * @example DateTime.local(2017, 5, 25).month //=> 5\r\n   * @type {number}\r\n   */\r\n  get month() {\r\n    return this.isValid ? this.c.month : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the day of the month (1-30ish).\r\n   * @example DateTime.local(2017, 5, 25).day //=> 25\r\n   * @type {number}\r\n   */\r\n  get day() {\r\n    return this.isValid ? this.c.day : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the hour of the day (0-23).\r\n   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9\r\n   * @type {number}\r\n   */\r\n  get hour() {\r\n    return this.isValid ? this.c.hour : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the minute of the hour (0-59).\r\n   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30\r\n   * @type {number}\r\n   */\r\n  get minute() {\r\n    return this.isValid ? this.c.minute : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the second of the minute (0-59).\r\n   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52\r\n   * @type {number}\r\n   */\r\n  get second() {\r\n    return this.isValid ? this.c.second : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the millisecond of the second (0-999).\r\n   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654\r\n   * @type {number}\r\n   */\r\n  get millisecond() {\r\n    return this.isValid ? this.c.millisecond : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the week year\r\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\r\n   * @example DateTime.local(2014, 11, 31).weekYear //=> 2015\r\n   * @type {number}\r\n   */\r\n  get weekYear() {\r\n    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the week number of the week year (1-52ish).\r\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\r\n   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21\r\n   * @type {number}\r\n   */\r\n  get weekNumber() {\r\n    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the day of the week.\r\n   * 1 is Monday and 7 is Sunday\r\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\r\n   * @example DateTime.local(2014, 11, 31).weekday //=> 4\r\n   * @type {number}\r\n   */\r\n  get weekday() {\r\n    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the ordinal (i.e. the day of the year)\r\n   * @example DateTime.local(2017, 5, 25).ordinal //=> 145\r\n   * @type {number|DateTime}\r\n   */\r\n  get ordinal() {\r\n    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the human readable short month name, such as 'Oct'.\r\n   * Defaults to the system's locale if no locale has been specified\r\n   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct\r\n   * @type {string}\r\n   */\r\n  get monthShort() {\r\n    return this.isValid ? Info.months(\"short\", { locale: this.locale })[this.month - 1] : null;\r\n  }\r\n\r\n  /**\r\n   * Get the human readable long month name, such as 'October'.\r\n   * Defaults to the system's locale if no locale has been specified\r\n   * @example DateTime.local(2017, 10, 30).monthLong //=> October\r\n   * @type {string}\r\n   */\r\n  get monthLong() {\r\n    return this.isValid ? Info.months(\"long\", { locale: this.locale })[this.month - 1] : null;\r\n  }\r\n\r\n  /**\r\n   * Get the human readable short weekday, such as 'Mon'.\r\n   * Defaults to the system's locale if no locale has been specified\r\n   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon\r\n   * @type {string}\r\n   */\r\n  get weekdayShort() {\r\n    return this.isValid ? Info.weekdays(\"short\", { locale: this.locale })[this.weekday - 1] : null;\r\n  }\r\n\r\n  /**\r\n   * Get the human readable long weekday, such as 'Monday'.\r\n   * Defaults to the system's locale if no locale has been specified\r\n   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday\r\n   * @type {string}\r\n   */\r\n  get weekdayLong() {\r\n    return this.isValid ? Info.weekdays(\"long\", { locale: this.locale })[this.weekday - 1] : null;\r\n  }\r\n\r\n  /**\r\n   * Get the UTC offset of this DateTime in minutes\r\n   * @example DateTime.local().offset //=> -240\r\n   * @example DateTime.utc().offset //=> 0\r\n   * @type {number}\r\n   */\r\n  get offset() {\r\n    return this.isValid ? this.zone.offset(this.ts) : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the short human name for the zone's current offset, for example \"EST\" or \"EDT\".\r\n   * Defaults to the system's locale if no locale has been specified\r\n   * @type {string}\r\n   */\r\n  get offsetNameShort() {\r\n    if (this.isValid) {\r\n      return this.zone.offsetName(this.ts, {\r\n        format: \"short\",\r\n        locale: this.locale\r\n      });\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the long human name for the zone's current offset, for example \"Eastern Standard Time\" or \"Eastern Daylight Time\".\r\n   * Defaults to the system's locale if no locale has been specified\r\n   * @type {string}\r\n   */\r\n  get offsetNameLong() {\r\n    if (this.isValid) {\r\n      return this.zone.offsetName(this.ts, {\r\n        format: \"long\",\r\n        locale: this.locale\r\n      });\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get whether this zone's offset ever changes, as in a DST.\r\n   * @type {boolean}\r\n   */\r\n  get isOffsetFixed() {\r\n    return this.isValid ? this.zone.universal : null;\r\n  }\r\n\r\n  /**\r\n   * Get whether the DateTime is in a DST.\r\n   * @type {boolean}\r\n   */\r\n  get isInDST() {\r\n    if (this.isOffsetFixed) {\r\n      return false;\r\n    } else {\r\n      return (\r\n        this.offset > this.set({ month: 1 }).offset || this.offset > this.set({ month: 5 }).offset\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if this DateTime is in a leap year, false otherwise\r\n   * @example DateTime.local(2016).isInLeapYear //=> true\r\n   * @example DateTime.local(2013).isInLeapYear //=> false\r\n   * @type {boolean}\r\n   */\r\n  get isInLeapYear() {\r\n    return isLeapYear(this.year);\r\n  }\r\n\r\n  /**\r\n   * Returns the number of days in this DateTime's month\r\n   * @example DateTime.local(2016, 2).daysInMonth //=> 29\r\n   * @example DateTime.local(2016, 3).daysInMonth //=> 31\r\n   * @type {number}\r\n   */\r\n  get daysInMonth() {\r\n    return daysInMonth(this.year, this.month);\r\n  }\r\n\r\n  /**\r\n   * Returns the number of days in this DateTime's year\r\n   * @example DateTime.local(2016).daysInYear //=> 366\r\n   * @example DateTime.local(2013).daysInYear //=> 365\r\n   * @type {number}\r\n   */\r\n  get daysInYear() {\r\n    return this.isValid ? daysInYear(this.year) : NaN;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of weeks in this DateTime's year\r\n   * @see https://en.wikipedia.org/wiki/ISO_week_date\r\n   * @example DateTime.local(2004).weeksInWeekYear //=> 53\r\n   * @example DateTime.local(2013).weeksInWeekYear //=> 52\r\n   * @type {number}\r\n   */\r\n  get weeksInWeekYear() {\r\n    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;\r\n  }\r\n\r\n  /**\r\n   * Returns the resolved Intl options for this DateTime.\r\n   * This is useful in understanding the behavior of formatting methods\r\n   * @param {Object} opts - the same options as toLocaleString\r\n   * @return {Object}\r\n   */\r\n  resolvedLocaleOpts(opts = {}) {\r\n    const { locale, numberingSystem, calendar } = Formatter.create(\r\n      this.loc.clone(opts),\r\n      opts\r\n    ).resolvedOptions(this);\r\n    return { locale, numberingSystem, outputCalendar: calendar };\r\n  }\r\n\r\n  // TRANSFORM\r\n\r\n  /**\r\n   * \"Set\" the DateTime's zone to UTC. Returns a newly-constructed DateTime.\r\n   *\r\n   * Equivalent to {@link setZone}('utc')\r\n   * @param {number} [offset=0] - optionally, an offset from UTC in minutes\r\n   * @param {Object} [opts={}] - options to pass to `setZone()`\r\n   * @return {DateTime}\r\n   */\r\n  toUTC(offset = 0, opts = {}) {\r\n    return this.setZone(FixedOffsetZone.instance(offset), opts);\r\n  }\r\n\r\n  /**\r\n   * \"Set\" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.\r\n   *\r\n   * Equivalent to `setZone('local')`\r\n   * @return {DateTime}\r\n   */\r\n  toLocal() {\r\n    return this.setZone(Settings.defaultZone);\r\n  }\r\n\r\n  /**\r\n   * \"Set\" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.\r\n   *\r\n   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link plus}. You may wish to use {@link toLocal} and {@link toUTC} which provide simple convenience wrappers for commonly used zones.\r\n   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link Zone} class.\r\n   * @param {Object} opts - options\r\n   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.\r\n   * @return {DateTime}\r\n   */\r\n  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {\r\n    zone = normalizeZone(zone, Settings.defaultZone);\r\n    if (zone.equals(this.zone)) {\r\n      return this;\r\n    } else if (!zone.isValid) {\r\n      return DateTime.invalid(unsupportedZone(zone));\r\n    } else {\r\n      const newTS =\r\n        keepLocalTime || keepCalendarTime // keepCalendarTime is the deprecated name for keepLocalTime\r\n          ? this.ts + (this.o - zone.offset(this.ts)) * 60 * 1000\r\n          : this.ts;\r\n      return clone(this, { ts: newTS, zone });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \"Set\" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.\r\n   * @param {Object} properties - the properties to set\r\n   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })\r\n   * @return {DateTime}\r\n   */\r\n  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {\r\n    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });\r\n    return clone(this, { loc });\r\n  }\r\n\r\n  /**\r\n   * \"Set\" the locale. Returns a newly-constructed DateTime.\r\n   * Just a convenient alias for reconfigure({ locale })\r\n   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')\r\n   * @return {DateTime}\r\n   */\r\n  setLocale(locale) {\r\n    return this.reconfigure({ locale });\r\n  }\r\n\r\n  /**\r\n   * \"Set\" the values of specified units. Returns a newly-constructed DateTime.\r\n   * You can only set units with this method; for \"setting\" metadata, see {@link reconfigure} and {@link setZone}.\r\n   * @param {Object} values - a mapping of units to numbers\r\n   * @example dt.set({ year: 2017 })\r\n   * @example dt.set({ hour: 8, minute: 30 })\r\n   * @example dt.set({ weekday: 5 })\r\n   * @example dt.set({ year: 2005, ordinal: 234 })\r\n   * @return {DateTime}\r\n   */\r\n  set(values) {\r\n    if (!this.isValid) return this;\r\n\r\n    const normalized = normalizeObject(values, normalizeUnit, []),\r\n      settingWeekStuff =\r\n        !isUndefined(normalized.weekYear) ||\r\n        !isUndefined(normalized.weekNumber) ||\r\n        !isUndefined(normalized.weekday);\r\n\r\n    let mixed;\r\n    if (settingWeekStuff) {\r\n      mixed = weekToGregorian(Object.assign(gregorianToWeek(this.c), normalized));\r\n    } else if (!isUndefined(normalized.ordinal)) {\r\n      mixed = ordinalToGregorian(Object.assign(gregorianToOrdinal(this.c), normalized));\r\n    } else {\r\n      mixed = Object.assign(this.toObject(), normalized);\r\n\r\n      // if we didn't set the day but we ended up on an overflow date,\r\n      // use the last day of the right month\r\n      if (isUndefined(normalized.day)) {\r\n        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);\r\n      }\r\n    }\r\n\r\n    const [ts, o] = objToTS(mixed, this.o, this.zone);\r\n    return clone(this, { ts, o });\r\n  }\r\n\r\n  /**\r\n   * Add a period of time to this DateTime and return the resulting DateTime\r\n   *\r\n   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.\r\n   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\r\n   * @example DateTime.local().plus(123) //~> in 123 milliseconds\r\n   * @example DateTime.local().plus({ minutes: 15 }) //~> in 15 minutes\r\n   * @example DateTime.local().plus({ days: 1 }) //~> this time tomorrow\r\n   * @example DateTime.local().plus({ days: -1 }) //~> this time yesterday\r\n   * @example DateTime.local().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min\r\n   * @example DateTime.local().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min\r\n   * @return {DateTime}\r\n   */\r\n  plus(duration) {\r\n    if (!this.isValid) return this;\r\n    const dur = friendlyDuration(duration);\r\n    return clone(this, adjustTime(this, dur));\r\n  }\r\n\r\n  /**\r\n   * Subtract a period of time to this DateTime and return the resulting DateTime\r\n   * See {@link plus}\r\n   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\r\n   @return {DateTime}\r\n  */\r\n  minus(duration) {\r\n    if (!this.isValid) return this;\r\n    const dur = friendlyDuration(duration).negate();\r\n    return clone(this, adjustTime(this, dur));\r\n  }\r\n\r\n  /**\r\n   * \"Set\" this DateTime to the beginning of a unit of time.\r\n   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\r\n   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'\r\n   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'\r\n   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'\r\n   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'\r\n   * @return {DateTime}\r\n   */\r\n  startOf(unit) {\r\n    if (!this.isValid) return this;\r\n    const o = {},\r\n      normalizedUnit = Duration.normalizeUnit(unit);\r\n    switch (normalizedUnit) {\r\n      case \"years\":\r\n        o.month = 1;\r\n      // falls through\r\n      case \"quarters\":\r\n      case \"months\":\r\n        o.day = 1;\r\n      // falls through\r\n      case \"weeks\":\r\n      case \"days\":\r\n        o.hour = 0;\r\n      // falls through\r\n      case \"hours\":\r\n        o.minute = 0;\r\n      // falls through\r\n      case \"minutes\":\r\n        o.second = 0;\r\n      // falls through\r\n      case \"seconds\":\r\n        o.millisecond = 0;\r\n        break;\r\n      case \"milliseconds\":\r\n        break;\r\n      // no default, invalid units throw in normalizeUnit()\r\n    }\r\n\r\n    if (normalizedUnit === \"weeks\") {\r\n      o.weekday = 1;\r\n    }\r\n\r\n    if (normalizedUnit === \"quarters\") {\r\n      const q = Math.ceil(this.month / 3);\r\n      o.month = (q - 1) * 3 + 1;\r\n    }\r\n\r\n    return this.set(o);\r\n  }\r\n\r\n  /**\r\n   * \"Set\" this DateTime to the end (i.e. the last millisecond) of a unit of time\r\n   * @param {string} unit - The unit to go to the end of. Can be 'year', 'month', 'day', 'hour', 'minute', 'second', or 'millisecond'.\r\n   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'\r\n   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'\r\n   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'\r\n   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'\r\n   * @return {DateTime}\r\n   */\r\n  endOf(unit) {\r\n    return this.isValid\r\n      ? this.plus({ [unit]: 1 })\r\n          .startOf(unit)\r\n          .minus(1)\r\n      : this;\r\n  }\r\n\r\n  // OUTPUT\r\n\r\n  /**\r\n   * Returns a string representation of this DateTime formatted according to the specified format string.\r\n   * **You may not want this.** See {@link toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens).\r\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale.\r\n   * @see https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens\r\n   * @param {string} fmt - the format string\r\n   * @param {Object} opts - opts to override the configuration options\r\n   * @example DateTime.local().toFormat('yyyy LLL dd') //=> '2017 Apr 22'\r\n   * @example DateTime.local().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'\r\n   * @example DateTime.local().toFormat('yyyy LLL dd', { locale: \"fr\" }) //=> '2017 avr. 22'\r\n   * @example DateTime.local().toFormat(\"HH 'hours and' mm 'minutes'\") //=> '20 hours and 55 minutes'\r\n   * @return {string}\r\n   */\r\n  toFormat(fmt, opts = {}) {\r\n    return this.isValid\r\n      ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt)\r\n      : INVALID;\r\n  }\r\n\r\n  /**\r\n   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.\r\n   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation\r\n   * of the DateTime in the assigned locale.\r\n   * Defaults to the system's locale if no locale has been specified\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\r\n   * @param opts {Object} - Intl.DateTimeFormat constructor options and configuration options\r\n   * @example DateTime.local().toLocaleString(); //=> 4/20/2017\r\n   * @example DateTime.local().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'\r\n   * @example DateTime.local().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'\r\n   * @example DateTime.local().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'\r\n   * @example DateTime.local().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'\r\n   * @example DateTime.local().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'\r\n   * @example DateTime.local().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'\r\n   * @example DateTime.local().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'\r\n   * @example DateTime.local().toLocaleString({ hour: '2-digit', minute: '2-digit', hour12: false }); //=> '11:32'\r\n   * @return {string}\r\n   */\r\n  toLocaleString(opts = Formats.DATE_SHORT) {\r\n    return this.isValid\r\n      ? Formatter.create(this.loc.clone(opts), opts).formatDateTime(this)\r\n      : INVALID;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of format \"parts\", i.e. individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.\r\n   * Defaults to the system's locale if no locale has been specified\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts\r\n   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.\r\n   * @example DateTime.local().toLocaleString(); //=> [\r\n   *                                    //=>   { type: 'day', value: '25' },\r\n   *                                    //=>   { type: 'literal', value: '/' },\r\n   *                                    //=>   { type: 'month', value: '05' },\r\n   *                                    //=>   { type: 'literal', value: '/' },\r\n   *                                    //=>   { type: 'year', value: '1982' }\r\n   *                                    //=> ]\r\n   */\r\n  toLocaleParts(opts = {}) {\r\n    return this.isValid\r\n      ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this)\r\n      : [];\r\n  }\r\n\r\n  /**\r\n   * Returns an ISO 8601-compliant string representation of this DateTime\r\n   * @param {Object} opts - options\r\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\r\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\r\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\r\n   * @example DateTime.utc(1982, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'\r\n   * @example DateTime.local().toISO() //=> '2017-04-22T20:47:05.335-04:00'\r\n   * @example DateTime.local().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'\r\n   * @return {string}\r\n   */\r\n  toISO(opts = {}) {\r\n    if (!this.isValid) {\r\n      return null;\r\n    }\r\n\r\n    return `${this.toISODate()}T${this.toISOTime(opts)}`;\r\n  }\r\n\r\n  /**\r\n   * Returns an ISO 8601-compliant string representation of this DateTime's date component\r\n   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'\r\n   * @return {string}\r\n   */\r\n  toISODate() {\r\n    let format = \"yyyy-MM-dd\";\r\n    if (this.year > 9999) {\r\n      format = \"+\" + format;\r\n    }\r\n\r\n    return toTechFormat(this, format);\r\n  }\r\n\r\n  /**\r\n   * Returns an ISO 8601-compliant string representation of this DateTime's week date\r\n   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'\r\n   * @return {string}\r\n   */\r\n  toISOWeekDate() {\r\n    return toTechFormat(this, \"kkkk-'W'WW-c\");\r\n  }\r\n\r\n  /**\r\n   * Returns an ISO 8601-compliant string representation of this DateTime's time component\r\n   * @param {Object} opts - options\r\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\r\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\r\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\r\n   * @example DateTime.utc().hour(7).minute(34).toISOTime() //=> '07:34:19.361Z'\r\n   * @example DateTime.utc().hour(7).minute(34).toISOTime({ suppressSeconds: true }) //=> '07:34Z'\r\n   * @return {string}\r\n   */\r\n  toISOTime({ suppressMilliseconds = false, suppressSeconds = false, includeOffset = true } = {}) {\r\n    return toTechTimeFormat(this, {\r\n      suppressSeconds,\r\n      suppressMilliseconds,\r\n      includeOffset\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns an RFC 2822-compatible string representation of this DateTime, always in UTC\r\n   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'\r\n   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'\r\n   * @return {string}\r\n   */\r\n  toRFC2822() {\r\n    return toTechFormat(this, \"EEE, dd LLL yyyy HH:mm:ss ZZZ\");\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of this DateTime appropriate for use in HTTP headers.\r\n   * Specifically, the string conforms to RFC 1123.\r\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\r\n   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'\r\n   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'\r\n   * @return {string}\r\n   */\r\n  toHTTP() {\r\n    return toTechFormat(this.toUTC(), \"EEE, dd LLL yyyy HH:mm:ss 'GMT'\");\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of this DateTime appropriate for use in SQL Date\r\n   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'\r\n   * @return {string}\r\n   */\r\n  toSQLDate() {\r\n    return toTechFormat(this, \"yyyy-MM-dd\");\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of this DateTime appropriate for use in SQL Time\r\n   * @param {Object} opts - options\r\n   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.\r\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\r\n   * @example DateTime.utc().toSQL() //=> '05:15:16.345'\r\n   * @example DateTime.local().toSQL() //=> '05:15:16.345 -04:00'\r\n   * @example DateTime.local().toSQL({ includeOffset: false }) //=> '05:15:16.345'\r\n   * @example DateTime.local().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'\r\n   * @return {string}\r\n   */\r\n  toSQLTime({ includeOffset = true, includeZone = false } = {}) {\r\n    return toTechTimeFormat(this, {\r\n      includeOffset,\r\n      includeZone,\r\n      spaceZone: true\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of this DateTime appropriate for use in SQL DateTime\r\n   * @param {Object} opts - options\r\n   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.\r\n   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'\r\n   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'\r\n   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'\r\n   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'\r\n   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'\r\n   * @return {string}\r\n   */\r\n  toSQL(opts = {}) {\r\n    if (!this.isValid) {\r\n      return null;\r\n    }\r\n\r\n    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of this DateTime appropriate for debugging\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    return this.isValid ? this.toISO() : INVALID;\r\n  }\r\n\r\n  /**\r\n   * Returns the epoch milliseconds of this DateTime. Alias of {@link toMillis}\r\n   * @return {number}\r\n   */\r\n  valueOf() {\r\n    return this.toMillis();\r\n  }\r\n\r\n  /**\r\n   * Returns the epoch milliseconds of this DateTime.\r\n   * @return {number}\r\n   */\r\n  toMillis() {\r\n    return this.isValid ? this.ts : NaN;\r\n  }\r\n\r\n  /**\r\n   * Returns the epoch seconds of this DateTime.\r\n   * @return {number}\r\n   */\r\n  toSeconds() {\r\n    return this.isValid ? this.ts / 1000 : NaN;\r\n  }\r\n\r\n  /**\r\n   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.\r\n   * @return {string}\r\n   */\r\n  toJSON() {\r\n    return this.toISO();\r\n  }\r\n\r\n  /**\r\n   * Returns a BSON serializable equivalent to this DateTime.\r\n   * @return {Date}\r\n   */\r\n  toBSON() {\r\n    return this.toJSDate();\r\n  }\r\n\r\n  /**\r\n   * Returns a Javascript object with this DateTime's year, month, day, and so on.\r\n   * @param opts - options for generating the object\r\n   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output\r\n   * @example DateTime.local().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }\r\n   * @return {Object}\r\n   */\r\n  toObject(opts = {}) {\r\n    if (!this.isValid) return {};\r\n\r\n    const base = Object.assign({}, this.c);\r\n\r\n    if (opts.includeConfig) {\r\n      base.outputCalendar = this.outputCalendar;\r\n      base.numberingSystem = this.loc.numberingSystem;\r\n      base.locale = this.loc.locale;\r\n    }\r\n    return base;\r\n  }\r\n\r\n  /**\r\n   * Returns a Javascript Date equivalent to this DateTime.\r\n   * @return {Date}\r\n   */\r\n  toJSDate() {\r\n    return new Date(this.isValid ? this.ts : NaN);\r\n  }\r\n\r\n  // COMPARE\r\n\r\n  /**\r\n   * Return the difference between two DateTimes as a Duration.\r\n   * @param {DateTime} otherDateTime - the DateTime to compare this one to\r\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.\r\n   * @param {Object} opts - options that affect the creation of the Duration\r\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\r\n   * @example\r\n   * var i1 = DateTime.fromISO('1982-05-25T09:45'),\r\n   *     i2 = DateTime.fromISO('1983-10-14T10:30');\r\n   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }\r\n   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }\r\n   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }\r\n   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }\r\n   * @return {Duration}\r\n   */\r\n  diff(otherDateTime, unit = \"milliseconds\", opts = {}) {\r\n    if (!this.isValid || !otherDateTime.isValid) {\r\n      return Duration.invalid(\r\n        this.invalid || otherDateTime.invalid,\r\n        \"created by diffing an invalid DateTime\"\r\n      );\r\n    }\r\n\r\n    const durOpts = Object.assign(\r\n      { locale: this.locale, numberingSystem: this.numberingSystem },\r\n      opts\r\n    );\r\n\r\n    const units = maybeArray(unit).map(Duration.normalizeUnit),\r\n      otherIsLater = otherDateTime.valueOf() > this.valueOf(),\r\n      earlier = otherIsLater ? this : otherDateTime,\r\n      later = otherIsLater ? otherDateTime : this,\r\n      diffed = diff(earlier, later, units, durOpts);\r\n\r\n    return otherIsLater ? diffed.negate() : diffed;\r\n  }\r\n\r\n  /**\r\n   * Return the difference between this DateTime and right now.\r\n   * See {@link diff}\r\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration\r\n   * @param {Object} opts - options that affect the creation of the Duration\r\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\r\n   * @return {Duration}\r\n   */\r\n  diffNow(unit = \"milliseconds\", opts = {}) {\r\n    return this.diff(DateTime.local(), unit, opts);\r\n  }\r\n\r\n  /**\r\n   * Return an Interval spanning between this DateTime and another DateTime\r\n   * @param {DateTime} otherDateTime - the other end point of the Interval\r\n   * @return {Interval}\r\n   */\r\n  until(otherDateTime) {\r\n    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;\r\n  }\r\n\r\n  /**\r\n   * Return whether this DateTime is in the same unit of time as another DateTime\r\n   * @param {DateTime} otherDateTime - the other DateTime\r\n   * @param {string} unit - the unit of time to check sameness on\r\n   * @example DateTime.local().hasSame(otherDT, 'day'); //~> true if both the same calendar day\r\n   * @return {boolean}\r\n   */\r\n  hasSame(otherDateTime, unit) {\r\n    if (!this.isValid) return false;\r\n    if (unit === \"millisecond\") {\r\n      return this.valueOf() === otherDateTime.valueOf();\r\n    } else {\r\n      const inputMs = otherDateTime.valueOf();\r\n      return this.startOf(unit) <= inputMs && inputMs <= this.endOf(unit);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Equality check\r\n   * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.\r\n   * To compare just the millisecond values, use `+dt1 === ~dt2`.\r\n   * @param {DateTime} other - the other DateTime\r\n   * @return {boolean}\r\n   */\r\n  equals(other) {\r\n    return (\r\n      this.isValid &&\r\n      other.isValid &&\r\n      this.valueOf() === other.valueOf() &&\r\n      this.zone.equals(other.zone) &&\r\n      this.loc.equals(other.loc)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of a this time relative to now, such as \"in two days\". Can only internationalize if your\r\n   * platform supports Intl.RelativeDateFormat, **which it probably doesn't yet!** (As of this writing, only Chrome supports that). Rounds down by default.\r\n   * @param {Object} options - options that affect the output\r\n   * @param {DateTime} [options.base=DateTime.local()] - the DateTime to use as the basis to which this time is compared. Defaults to now.\r\n   * @param {string} [options.style=\"long\"] - the style of units, must be \"long\", \"short\", or \"narrow\"\r\n   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of \"year\", \"quarter\", \"month\", \"week\", \"day\", \"hour\", \"minute\", or \"second\"\r\n   * @param {boolean} [options.round=true] - whether to round the numbers in the output.\r\n   * @param {boolean} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.\r\n   * @param {string} options.locale - override the locale of this DateTime\r\n   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\r\n   * @example DateTime.local().plus({ days: 1 }).toRelative() //=> \"in 1 day\"\r\n   * @example DateTime.local().setLocale(\"es\").toRelative({ days: 1 }) //=> \"dentro de 1 da\"\r\n   * @example DateTime.local().plus({ days: 1 }).toRelative({ locale: \"fr\" }) //=> \"dans 23 heures\"\r\n   * @example DateTime.local().minus({ days: 2 }).toRelative() //=> \"2 days ago\"\r\n   * @example DateTime.local().minus({ days: 2 }).toRelative({ unit: \"hours\" }) //=> \"48 hours ago\"\r\n   * @example DateTime.local().minus({ hours: 36 }).toRelative({ round: false }) //=> \"1.5 days ago\"\r\n   */\r\n  toRelative(options = {}) {\r\n    if (!this.isValid) return null;\r\n    const base = options.base || DateTime.fromObject({ zone: this.zone }),\r\n      padding = options.padding ? (this < base ? -options.padding : options.padding) : 0;\r\n    return diffRelative(\r\n      base,\r\n      this.plus(padding),\r\n      Object.assign(options, {\r\n        numeric: \"always\",\r\n        units: [\"years\", \"months\", \"days\", \"hours\", \"minutes\", \"seconds\"]\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of this date relative to today, such as \"yesterday\" or \"next month\"\r\n   * platform supports Intl.RelativeDateFormat.\r\n   * @param {Object} options - options that affect the output\r\n   * @param {DateTime} [options.base=DateTime.local()] - the DateTime to use as the basis to which this time is compared. Defaults to now.\r\n   * @param {string} options.locale - override the locale of this DateTime\r\n   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of \"year\", \"quarter\", \"month\", \"week\", or \"day\"\r\n   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\r\n   * @example DateTime.local().plus({ days: 1 }).toRelativeCalendar() //=> \"tomorrow\"\r\n   * @example DateTime.local().setLocale(\"es\").plus({ days: 1 }).toRelative() //=> \"\"maana\"\r\n   * @example DateTime.local().plus({ days: 1 }).toRelativeCalendar({ locale: \"fr\" }) //=> \"demain\"\r\n   * @example DateTime.local().minus({ days: 2 }).toRelativeCalendar() //=> \"2 days ago\"\r\n   */\r\n  toRelativeCalendar(options = {}) {\r\n    if (!this.isValid) return null;\r\n\r\n    return diffRelative(\r\n      options.base || DateTime.fromObject({ zone: this.zone }),\r\n      this,\r\n      Object.assign(options, {\r\n        numeric: \"auto\",\r\n        units: [\"years\", \"months\", \"days\"],\r\n        calendary: true\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the min of several date times\r\n   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum\r\n   * @return {DateTime} the min DateTime, or undefined if called with no argument\r\n   */\r\n  static min(...dateTimes) {\r\n    return bestBy(dateTimes, i => i.valueOf(), Math.min);\r\n  }\r\n\r\n  /**\r\n   * Return the max of several date times\r\n   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum\r\n   * @return {DateTime} the max DateTime, or undefined if called with no argument\r\n   */\r\n  static max(...dateTimes) {\r\n    return bestBy(dateTimes, i => i.valueOf(), Math.max);\r\n  }\r\n\r\n  // MISC\r\n\r\n  /**\r\n   * Explain how a string would be parsed by fromFormat()\r\n   * @param {string} text - the string to parse\r\n   * @param {string} fmt - the format the string is expected to be in (see description)\r\n   * @param {Object} options - options taken by fromFormat()\r\n   * @return {Object}\r\n   */\r\n  static fromFormatExplain(text, fmt, options = {}) {\r\n    const { locale = null, numberingSystem = null } = options,\r\n      localeToUse = Locale.fromOpts({\r\n        locale,\r\n        numberingSystem,\r\n        defaultToEN: true\r\n      });\r\n    return explainFromTokens(localeToUse, text, fmt);\r\n  }\r\n\r\n  /**\r\n   * @deprecated use fromFormatExplain instead\r\n   */\r\n  static fromStringExplain(text, fmt, options = {}) {\r\n    return DateTime.fromFormatExplain(text, fmt, options);\r\n  }\r\n\r\n  // FORMAT PRESETS\r\n\r\n  /**\r\n   * {@link toLocaleString} format like 10/14/1983\r\n   * @type {Object}\r\n   */\r\n  static get DATE_SHORT() {\r\n    return Formats.DATE_SHORT;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like 'Oct 14, 1983'\r\n   * @type {Object}\r\n   */\r\n  static get DATE_MED() {\r\n    return Formats.DATE_MED;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like 'October 14, 1983'\r\n   * @type {Object}\r\n   */\r\n  static get DATE_FULL() {\r\n    return Formats.DATE_FULL;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like 'Tuesday, October 14, 1983'\r\n   * @type {Object}\r\n   */\r\n  static get DATE_HUGE() {\r\n    return Formats.DATE_HUGE;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.\r\n   * @type {Object}\r\n   */\r\n  static get TIME_SIMPLE() {\r\n    return Formats.TIME_SIMPLE;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.\r\n   * @type {Object}\r\n   */\r\n  static get TIME_WITH_SECONDS() {\r\n    return Formats.TIME_WITH_SECONDS;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.\r\n   * @type {Object}\r\n   */\r\n  static get TIME_WITH_SHORT_OFFSET() {\r\n    return Formats.TIME_WITH_SHORT_OFFSET;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.\r\n   * @type {Object}\r\n   */\r\n  static get TIME_WITH_LONG_OFFSET() {\r\n    return Formats.TIME_WITH_LONG_OFFSET;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like '09:30', always 24-hour.\r\n   * @type {Object}\r\n   */\r\n  static get TIME_24_SIMPLE() {\r\n    return Formats.TIME_24_SIMPLE;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like '09:30:23', always 24-hour.\r\n   * @type {Object}\r\n   */\r\n  static get TIME_24_WITH_SECONDS() {\r\n    return Formats.TIME_24_WITH_SECONDS;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like '09:30:23 EDT', always 24-hour.\r\n   * @type {Object}\r\n   */\r\n  static get TIME_24_WITH_SHORT_OFFSET() {\r\n    return Formats.TIME_24_WITH_SHORT_OFFSET;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.\r\n   * @type {Object}\r\n   */\r\n  static get TIME_24_WITH_LONG_OFFSET() {\r\n    return Formats.TIME_24_WITH_LONG_OFFSET;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.\r\n   * @type {Object}\r\n   */\r\n  static get DATETIME_SHORT() {\r\n    return Formats.DATETIME_SHORT;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.\r\n   * @type {Object}\r\n   */\r\n  static get DATETIME_SHORT_WITH_SECONDS() {\r\n    return Formats.DATETIME_SHORT_WITH_SECONDS;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.\r\n   * @type {Object}\r\n   */\r\n  static get DATETIME_MED() {\r\n    return Formats.DATETIME_MED;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.\r\n   * @type {Object}\r\n   */\r\n  static get DATETIME_MED_WITH_SECONDS() {\r\n    return Formats.DATETIME_MED_WITH_SECONDS;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.\r\n   * @type {Object}\r\n   */\r\n  static get DATETIME_FULL() {\r\n    return Formats.DATETIME_FULL;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.\r\n   * @type {Object}\r\n   */\r\n  static get DATETIME_FULL_WITH_SECONDS() {\r\n    return Formats.DATETIME_FULL_WITH_SECONDS;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.\r\n   * @type {Object}\r\n   */\r\n  static get DATETIME_HUGE() {\r\n    return Formats.DATETIME_HUGE;\r\n  }\r\n\r\n  /**\r\n   * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.\r\n   * @type {Object}\r\n   */\r\n  static get DATETIME_HUGE_WITH_SECONDS() {\r\n    return Formats.DATETIME_HUGE_WITH_SECONDS;\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function friendlyDateTime(dateTimeish) {\r\n  if (DateTime.isDateTime(dateTimeish)) {\r\n    return dateTimeish;\r\n  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {\r\n    return DateTime.fromJSDate(dateTimeish);\r\n  } else if (dateTimeish && typeof dateTimeish === \"object\") {\r\n    return DateTime.fromObject(dateTimeish);\r\n  } else {\r\n    throw new InvalidArgumentError(\r\n      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`\r\n    );\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "/Users/isaac/code/luxon/src/datetime.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "variable",
    "name": "INVALID",
    "memberof": "src/datetime.js",
    "static": true,
    "longname": "src/datetime.js~INVALID",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 50,
    "kind": "function",
    "name": "unsupportedZone",
    "memberof": "src/datetime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~unsupportedZone",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "zone",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 51,
    "kind": "function",
    "name": "possiblyCachedWeekData",
    "memberof": "src/datetime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~possiblyCachedWeekData",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "params": [
      {
        "name": "dt",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 52,
    "kind": "function",
    "name": "clone",
    "memberof": "src/datetime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~clone",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "params": [
      {
        "name": "inst",
        "types": [
          "*"
        ]
      },
      {
        "name": "alts",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 53,
    "kind": "function",
    "name": "fixOffset",
    "memberof": "src/datetime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~fixOffset",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "params": [
      {
        "name": "localTS",
        "types": [
          "*"
        ]
      },
      {
        "name": "o",
        "types": [
          "*"
        ]
      },
      {
        "name": "tz",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 54,
    "kind": "function",
    "name": "tsToObj",
    "memberof": "src/datetime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~tsToObj",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "params": [
      {
        "name": "ts",
        "types": [
          "*"
        ]
      },
      {
        "name": "offset",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"year\": *, \"month\": *, \"day\": *, \"hour\": *, \"minute\": *, \"second\": *, \"millisecond\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 55,
    "kind": "function",
    "name": "objToTS",
    "memberof": "src/datetime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~objToTS",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 118,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "offset",
        "types": [
          "*"
        ]
      },
      {
        "name": "zone",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 56,
    "kind": "function",
    "name": "adjustTime",
    "memberof": "src/datetime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~adjustTime",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 123,
    "undocument": true,
    "params": [
      {
        "name": "inst",
        "types": [
          "*"
        ]
      },
      {
        "name": "dur",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"ts\": *, \"o\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 57,
    "kind": "function",
    "name": "parseDataToDateTime",
    "memberof": "src/datetime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~parseDataToDateTime",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 153,
    "undocument": true,
    "params": [
      {
        "name": "parsed",
        "types": [
          "*"
        ]
      },
      {
        "name": "parsedZone",
        "types": [
          "*"
        ]
      },
      {
        "name": "opts",
        "types": [
          "*"
        ]
      },
      {
        "name": "format",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 58,
    "kind": "function",
    "name": "toTechFormat",
    "memberof": "src/datetime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~toTechFormat",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 174,
    "undocument": true,
    "params": [
      {
        "name": "dt",
        "types": [
          "*"
        ]
      },
      {
        "name": "format",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 59,
    "kind": "function",
    "name": "toTechTimeFormat",
    "memberof": "src/datetime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~toTechTimeFormat",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 185,
    "undocument": true,
    "params": [
      {
        "name": "dt",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern1",
        "types": [
          "{\"suppressSeconds\": *, \"suppressMilliseconds\": *, \"includeOffset\": *, \"includeZone\": *, \"spaceZone\": *}"
        ],
        "defaultRaw": {
          "suppressSeconds": null,
          "suppressMilliseconds": null,
          "includeOffset": null,
          "includeZone": null,
          "spaceZone": null
        },
        "defaultValue": "{\"suppressSeconds\":null,\"suppressMilliseconds\":null,\"includeOffset\":null,\"includeZone\":null,\"spaceZone\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 60,
    "kind": "variable",
    "name": "defaultUnitValues",
    "memberof": "src/datetime.js",
    "static": true,
    "longname": "src/datetime.js~defaultUnitValues",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 218,
    "undocument": true,
    "type": {
      "types": [
        "{\"month\": number, \"day\": number, \"hour\": *, \"minute\": *, \"second\": *, \"millisecond\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 61,
    "kind": "variable",
    "name": "orderedUnits",
    "memberof": "src/datetime.js",
    "static": true,
    "longname": "src/datetime.js~orderedUnits",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 243,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 62,
    "kind": "function",
    "name": "normalizeUnit",
    "memberof": "src/datetime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~normalizeUnit",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 256,
    "undocument": true,
    "params": [
      {
        "name": "unit",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 63,
    "kind": "function",
    "name": "quickDT",
    "memberof": "src/datetime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~quickDT",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 290,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "zone",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 64,
    "kind": "function",
    "name": "diffRelative",
    "memberof": "src/datetime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~diffRelative",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/datetime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 314,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      },
      {
        "name": "opts",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 65,
    "kind": "class",
    "name": "DateTime",
    "memberof": "src/datetime.js",
    "static": true,
    "longname": "src/datetime.js~DateTime",
    "access": "public",
    "export": true,
    "importPath": "luxon/src/datetime.js",
    "importStyle": "DateTime",
    "description": "A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.\n\nA DateTime comprises of:\n* A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.\n* A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).\n* Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.\n\nHere is a brief overview of the most commonly used functionality it provides:\n\n* **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link local}, {@link utc}, and (most flexibly) {@link fromObject}. To create one from a standard string format, use {@link fromISO}, {@link fromHTTP}, and {@link fromRFC2822}. To create one from a custom string format, use {@link fromFormat}. To create one from a native JS date, use {@link fromJSDate}.\n* **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link toObject}), use the {@link year}, {@link month},\n{@link day}, {@link hour}, {@link minute}, {@link second}, {@link millisecond} accessors.\n* **Week calendar**: For ISO week calendar attributes, see the {@link weekYear}, {@link weekNumber}, and {@link weekday} accessors.\n* **Configuration** See the {@link locale} and {@link numberingSystem} accessors.\n* **Transformation**: To transform the DateTime into other DateTimes, use {@link set}, {@link reconfigure}, {@link setZone}, {@link setLocale}, {@link plus}, {@link minus}, {@link endOf}, {@link startOf}, {@link toUTC}, and {@link toLocal}.\n* **Output**: To convert the DateTime to other representations, use the {@link toRelative}, {@link toRelativeCalendar}, {@link toJSON}, {@link toISO}, {@link toHTTP}, {@link toObject}, {@link toRFC2822}, {@link toString}, {@link toLocaleString}, {@link toFormat}, {@link toMillis} and {@link toJSDate}.\n\nThere's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.",
    "lineNumber": 367,
    "interface": false
  },
  {
    "__docId__": 66,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 371,
    "ignore": true
  },
  {
    "__docId__": 67,
    "kind": "member",
    "name": "ts",
    "memberof": "src/datetime.js~DateTime",
    "static": false,
    "longname": "src/datetime.js~DateTime#ts",
    "access": "private",
    "description": "",
    "lineNumber": 380,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "member",
    "name": "_zone",
    "memberof": "src/datetime.js~DateTime",
    "static": false,
    "longname": "src/datetime.js~DateTime#_zone",
    "access": "private",
    "description": "",
    "lineNumber": 393,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "member",
    "name": "loc",
    "memberof": "src/datetime.js~DateTime",
    "static": false,
    "longname": "src/datetime.js~DateTime#loc",
    "access": "private",
    "description": "",
    "lineNumber": 397,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "member",
    "name": "invalid",
    "memberof": "src/datetime.js~DateTime",
    "static": false,
    "longname": "src/datetime.js~DateTime#invalid",
    "access": "private",
    "description": "",
    "lineNumber": 401,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "member",
    "name": "weekData",
    "memberof": "src/datetime.js~DateTime",
    "static": false,
    "longname": "src/datetime.js~DateTime#weekData",
    "access": "private",
    "description": "",
    "lineNumber": 405,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "member",
    "name": "c",
    "memberof": "src/datetime.js~DateTime",
    "static": false,
    "longname": "src/datetime.js~DateTime#c",
    "access": "private",
    "description": "",
    "lineNumber": 409,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "member",
    "name": "o",
    "memberof": "src/datetime.js~DateTime",
    "static": false,
    "longname": "src/datetime.js~DateTime#o",
    "access": "private",
    "description": "",
    "lineNumber": 413,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "isLuxonDateTime",
    "memberof": "src/datetime.js~DateTime",
    "static": false,
    "longname": "src/datetime.js~DateTime#isLuxonDateTime",
    "access": "private",
    "description": "",
    "lineNumber": 417,
    "ignore": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "method",
    "name": "local",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.local",
    "access": "public",
    "description": "Create a local DateTime",
    "examples": [
      "DateTime.local()                            //~> now",
      "DateTime.local(2017)                        //~> 2017-01-01T00:00:00",
      "DateTime.local(2017, 3)                     //~> 2017-03-01T00:00:00",
      "DateTime.local(2017, 3, 12)                 //~> 2017-03-12T00:00:00",
      "DateTime.local(2017, 3, 12, 5)              //~> 2017-03-12T05:00:00",
      "DateTime.local(2017, 3, 12, 5, 45)          //~> 2017-03-12T05:45:00",
      "DateTime.local(2017, 3, 12, 5, 45, 10)      //~> 2017-03-12T05:45:10",
      "DateTime.local(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765"
    ],
    "lineNumber": 441,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "month",
        "description": "The month, 1-indexed"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "day",
        "description": "The day of the month"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "hour",
        "description": "The hour of the day, in 24-hour time"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "minute",
        "description": "The minute of the hour, i.e. a number between 0 and 59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "second",
        "description": "The second of the minute, i.e. a number between 0 and 59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "millisecond",
        "description": "The millisecond of the second, i.e. a number between 0 and 999"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 76,
    "kind": "method",
    "name": "utc",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.utc",
    "access": "public",
    "description": "Create a DateTime in UTC",
    "examples": [
      "DateTime.utc()                            //~> now",
      "DateTime.utc(2017)                        //~> 2017-01-01T00:00:00Z",
      "DateTime.utc(2017, 3)                     //~> 2017-03-01T00:00:00Z",
      "DateTime.utc(2017, 3, 12)                 //~> 2017-03-12T00:00:00Z",
      "DateTime.utc(2017, 3, 12, 5)              //~> 2017-03-12T05:00:00Z",
      "DateTime.utc(2017, 3, 12, 5, 45)          //~> 2017-03-12T05:45:00Z",
      "DateTime.utc(2017, 3, 12, 5, 45, 10)      //~> 2017-03-12T05:45:10Z",
      "DateTime.utc(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765Z"
    ],
    "lineNumber": 479,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "month",
        "description": "The month, 1-indexed"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "day",
        "description": "The day of the month"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "hour",
        "description": "The hour of the day, in 24-hour time"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "minute",
        "description": "The minute of the hour, i.e. a number between 0 and 59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "second",
        "description": "The second of the minute, i.e. a number between 0 and 59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "millisecond",
        "description": "The millisecond of the second, i.e. a number between 0 and 999"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 77,
    "kind": "method",
    "name": "fromJSDate",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.fromJSDate",
    "access": "public",
    "description": "Create a DateTime from a Javascript Date object. Uses the default zone.",
    "lineNumber": 508,
    "params": [
      {
        "nullable": null,
        "types": [
          "Date"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "a Javascript Date object"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "configuration options for the DateTime"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Zone"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'local'",
        "defaultRaw": "'local'",
        "name": "options.zone",
        "description": "the zone to place the DateTime into"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "fromMillis",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.fromMillis",
    "access": "public",
    "description": "Create a DateTime from a number of milliseconds since the epoch (i.e. since 1 January 1970 00:00:00 UTC). Uses the default zone.",
    "lineNumber": 536,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "milliseconds",
        "description": "a number of milliseconds since 1970 UTC"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "configuration options for the DateTime"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Zone"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'local'",
        "defaultRaw": "'local'",
        "name": "options.zone",
        "description": "the zone to place the DateTime into"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.locale",
        "description": "a locale to set on the resulting DateTime instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.outputCalendar",
        "description": "the output calendar to set on the resulting DateTime instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.numberingSystem",
        "description": "the numbering system to set on the resulting DateTime instance"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "fromSeconds",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.fromSeconds",
    "access": "public",
    "description": "Create a DateTime from a number of seconds since the epoch (i.e. since 1 January 1970 00:00:00 UTC). Uses the default zone.",
    "lineNumber": 558,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": "a number of seconds since 1970 UTC"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "configuration options for the DateTime"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Zone"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'local'",
        "defaultRaw": "'local'",
        "name": "options.zone",
        "description": "the zone to place the DateTime into"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.locale",
        "description": "a locale to set on the resulting DateTime instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.outputCalendar",
        "description": "the output calendar to set on the resulting DateTime instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.numberingSystem",
        "description": "the numbering system to set on the resulting DateTime instance"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "fromObject",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.fromObject",
    "access": "public",
    "description": "Create a DateTime from a Javascript object with keys like 'year' and 'hour' with reasonable defaults.",
    "examples": [
      "DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'",
      "DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'",
      "DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06",
      "DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'utc' }),",
      "DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'local' })",
      "DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'America/New_York' })",
      "DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'"
    ],
    "lineNumber": 597,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the object to create the DateTime from"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.year",
        "description": "a year, such as 1987"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.month",
        "description": "a month, 1-12"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.day",
        "description": "a day of the month, 1-31, depending on the month"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.ordinal",
        "description": "day of the year, 1-365 or 366"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.weekYear",
        "description": "an ISO week year"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.weekNumber",
        "description": "an ISO week number, between 1 and 52 or 53, depending on the year"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.weekday",
        "description": "an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.hour",
        "description": "hour of the day, 0-23"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.minute",
        "description": "minute of the hour, 0-59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.second",
        "description": "second of the minute, 0-59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.millisecond",
        "description": "millisecond of the second, 0-999"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Zone"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'local'",
        "defaultRaw": "'local'",
        "name": "obj.zone",
        "description": "interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'system's locale'",
        "defaultRaw": "'system's locale'",
        "name": "obj.locale",
        "description": "a locale to set on the resulting DateTime instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.outputCalendar",
        "description": "the output calendar to set on the resulting DateTime instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.numberingSystem",
        "description": "the numbering system to set on the resulting DateTime instance"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 81,
    "kind": "method",
    "name": "fromISO",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.fromISO",
    "access": "public",
    "description": "Create a DateTime from an ISO 8601 string",
    "examples": [
      "DateTime.fromISO('2016-05-25T09:08:34.123')",
      "DateTime.fromISO('2016-05-25T09:08:34.123+06:00')",
      "DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})",
      "DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})",
      "DateTime.fromISO('2016-W05-4')"
    ],
    "lineNumber": 719,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the ISO string"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options to affect the creation"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Zone"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'local'",
        "defaultRaw": "'local'",
        "name": "opts.zone",
        "description": "use this zone if no offset is specified in the input string itself. Will also convert the time to this zone"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "opts.setZone",
        "description": "override the zone with a fixed-offset zone specified in the string itself, if it specifies one"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'system's locale'",
        "defaultRaw": "'system's locale'",
        "name": "opts.locale",
        "description": "a locale to set on the resulting DateTime instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.outputCalendar",
        "description": "the output calendar to set on the resulting DateTime instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.numberingSystem",
        "description": "the numbering system to set on the resulting DateTime instance"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "fromRFC2822",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.fromRFC2822",
    "access": "public",
    "description": "Create a DateTime from an RFC 2822 string",
    "examples": [
      "DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')",
      "DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')",
      "DateTime.fromRFC2822('25 Nov 2016 13:23 Z')"
    ],
    "lineNumber": 738,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the RFC 2822 string"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options to affect the creation"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Zone"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'local'",
        "defaultRaw": "'local'",
        "name": "opts.zone",
        "description": "convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "opts.setZone",
        "description": "override the zone with a fixed-offset zone specified in the string itself, if it specifies one"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'system's locale'",
        "defaultRaw": "'system's locale'",
        "name": "opts.locale",
        "description": "a locale to set on the resulting DateTime instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.outputCalendar",
        "description": "the output calendar to set on the resulting DateTime instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.numberingSystem",
        "description": "the numbering system to set on the resulting DateTime instance"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 83,
    "kind": "method",
    "name": "fromHTTP",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.fromHTTP",
    "access": "public",
    "description": "Create a DateTime from an HTTP header date",
    "examples": [
      "DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')",
      "DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')",
      "DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')"
    ],
    "see": [
      "https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1"
    ],
    "lineNumber": 758,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the HTTP header date"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options to affect the creation"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Zone"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'local'",
        "defaultRaw": "'local'",
        "name": "opts.zone",
        "description": "convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "opts.setZone",
        "description": "override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'system's locale'",
        "defaultRaw": "'system's locale'",
        "name": "opts.locale",
        "description": "a locale to set on the resulting DateTime instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.outputCalendar",
        "description": "the output calendar to set on the resulting DateTime instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.numberingSystem",
        "description": "the numbering system to set on the resulting DateTime instance"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "fromFormat",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.fromFormat",
    "access": "public",
    "description": "Create a DateTime from an input string and format string.\nDefaults to en-US if no locale has been specified, regardless of the system's locale.",
    "see": [
      "https://moment.github.io/luxon/docs/manual/parsing.html#table-of-tokens"
    ],
    "lineNumber": 777,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the string to parse"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "fmt",
        "description": "the format the string is expected to be in (see the link below for the formats)"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options to affect the creation"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Zone"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'local'",
        "defaultRaw": "'local'",
        "name": "opts.zone",
        "description": "use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "opts.setZone",
        "description": "override the zone with a zone specified in the string itself, if it specifies one"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'en-US'",
        "defaultRaw": "'en-US'",
        "name": "opts.locale",
        "description": "a locale string to use when parsing. Will also set the DateTime to this locale"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.numberingSystem",
        "description": "the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.outputCalendar",
        "description": "the output calendar to set on the resulting DateTime instance"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "fromString",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.fromString",
    "access": "public",
    "description": "",
    "lineNumber": 799,
    "deprecated": "use fromFormat instead",
    "params": [
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "fmt",
        "types": [
          "*"
        ]
      },
      {
        "name": "opts",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "fromSQL",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.fromSQL",
    "access": "public",
    "description": "Create a DateTime from a SQL date, time, or datetime\nDefaults to en-US if no locale has been specified, regardless of the system's locale",
    "examples": [
      "DateTime.fromSQL('2017-05-15')",
      "DateTime.fromSQL('2017-05-15 09:12:34')",
      "DateTime.fromSQL('2017-05-15 09:12:34.342')",
      "DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')",
      "DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')",
      "DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })",
      "DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })",
      "DateTime.fromSQL('09:12:34.342')"
    ],
    "lineNumber": 823,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the string to parse"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options to affect the creation"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Zone"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'local'",
        "defaultRaw": "'local'",
        "name": "opts.zone",
        "description": "use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "opts.setZone",
        "description": "override the zone with a zone specified in the string itself, if it specifies one"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'en-US'",
        "defaultRaw": "'en-US'",
        "name": "opts.locale",
        "description": "a locale string to use when parsing. Will also set the DateTime to this locale"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.numberingSystem",
        "description": "the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.outputCalendar",
        "description": "the output calendar to set on the resulting DateTime instance"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "invalid",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.invalid",
    "access": "public",
    "description": "Create an invalid DateTime.",
    "lineNumber": 834,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "reason",
        "description": "simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "explanation",
        "description": "longer explanation, may include parameters and other useful debugging information"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "isDateTime",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.isDateTime",
    "access": "public",
    "description": "Check if an object is a DateTime. Works across context boundaries",
    "lineNumber": 853,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "o",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 89,
    "kind": "method",
    "name": "get",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#get",
    "access": "public",
    "description": "Get the value of unit.",
    "examples": [
      "DateTime.local(2017, 7, 4).get('month'); //=> 7",
      "DateTime.local(2017, 7, 4).get('day'); //=> 4"
    ],
    "lineNumber": 866,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "a unit such as 'minute' or 'day'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 90,
    "kind": "get",
    "name": "isValid",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#isValid",
    "access": "public",
    "description": "Returns whether the DateTime is valid. Invalid DateTimes occur when:\n* The DateTime was created from invalid calendar information, such as the 13th month or February 30\n* The DateTime was created by an operation on another invalid date",
    "lineNumber": 876,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 91,
    "kind": "get",
    "name": "invalidReason",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#invalidReason",
    "access": "public",
    "description": "Returns an error code if this DateTime is invalid, or null if the DateTime is valid",
    "lineNumber": 884,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 92,
    "kind": "get",
    "name": "invalidExplanation",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#invalidExplanation",
    "access": "public",
    "description": "Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid",
    "lineNumber": 892,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 93,
    "kind": "get",
    "name": "locale",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#locale",
    "access": "public",
    "description": "Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime",
    "lineNumber": 901,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 94,
    "kind": "get",
    "name": "numberingSystem",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#numberingSystem",
    "access": "public",
    "description": "Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime",
    "lineNumber": 910,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 95,
    "kind": "get",
    "name": "outputCalendar",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#outputCalendar",
    "access": "public",
    "description": "Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime",
    "lineNumber": 919,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 96,
    "kind": "get",
    "name": "zone",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#zone",
    "access": "public",
    "description": "Get the time zone associated with this DateTime.",
    "lineNumber": 927,
    "type": {
      "nullable": null,
      "types": [
        "Zone"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 97,
    "kind": "get",
    "name": "zoneName",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#zoneName",
    "access": "public",
    "description": "Get the name of the time zone.",
    "lineNumber": 935,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 98,
    "kind": "get",
    "name": "year",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#year",
    "access": "public",
    "description": "Get the year",
    "examples": [
      "DateTime.local(2017, 5, 25).year //=> 2017"
    ],
    "lineNumber": 944,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 99,
    "kind": "get",
    "name": "quarter",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#quarter",
    "access": "public",
    "description": "Get the quarter",
    "examples": [
      "DateTime.local(2017, 5, 25).quarter //=> 2"
    ],
    "lineNumber": 953,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 100,
    "kind": "get",
    "name": "month",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#month",
    "access": "public",
    "description": "Get the month (1-12).",
    "examples": [
      "DateTime.local(2017, 5, 25).month //=> 5"
    ],
    "lineNumber": 962,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 101,
    "kind": "get",
    "name": "day",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#day",
    "access": "public",
    "description": "Get the day of the month (1-30ish).",
    "examples": [
      "DateTime.local(2017, 5, 25).day //=> 25"
    ],
    "lineNumber": 971,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 102,
    "kind": "get",
    "name": "hour",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#hour",
    "access": "public",
    "description": "Get the hour of the day (0-23).",
    "examples": [
      "DateTime.local(2017, 5, 25, 9).hour //=> 9"
    ],
    "lineNumber": 980,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 103,
    "kind": "get",
    "name": "minute",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#minute",
    "access": "public",
    "description": "Get the minute of the hour (0-59).",
    "examples": [
      "DateTime.local(2017, 5, 25, 9, 30).minute //=> 30"
    ],
    "lineNumber": 989,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 104,
    "kind": "get",
    "name": "second",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#second",
    "access": "public",
    "description": "Get the second of the minute (0-59).",
    "examples": [
      "DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52"
    ],
    "lineNumber": 998,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 105,
    "kind": "get",
    "name": "millisecond",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#millisecond",
    "access": "public",
    "description": "Get the millisecond of the second (0-999).",
    "examples": [
      "DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654"
    ],
    "lineNumber": 1007,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 106,
    "kind": "get",
    "name": "weekYear",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#weekYear",
    "access": "public",
    "description": "Get the week year",
    "examples": [
      "DateTime.local(2014, 11, 31).weekYear //=> 2015"
    ],
    "see": [
      "https://en.wikipedia.org/wiki/ISO_week_date"
    ],
    "lineNumber": 1017,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 107,
    "kind": "get",
    "name": "weekNumber",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#weekNumber",
    "access": "public",
    "description": "Get the week number of the week year (1-52ish).",
    "examples": [
      "DateTime.local(2017, 5, 25).weekNumber //=> 21"
    ],
    "see": [
      "https://en.wikipedia.org/wiki/ISO_week_date"
    ],
    "lineNumber": 1027,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 108,
    "kind": "get",
    "name": "weekday",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#weekday",
    "access": "public",
    "description": "Get the day of the week.\n1 is Monday and 7 is Sunday",
    "examples": [
      "DateTime.local(2014, 11, 31).weekday //=> 4"
    ],
    "see": [
      "https://en.wikipedia.org/wiki/ISO_week_date"
    ],
    "lineNumber": 1038,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 109,
    "kind": "get",
    "name": "ordinal",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#ordinal",
    "access": "public",
    "description": "Get the ordinal (i.e. the day of the year)",
    "examples": [
      "DateTime.local(2017, 5, 25).ordinal //=> 145"
    ],
    "lineNumber": 1047,
    "type": {
      "nullable": null,
      "types": [
        "number",
        "DateTime"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 110,
    "kind": "get",
    "name": "monthShort",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#monthShort",
    "access": "public",
    "description": "Get the human readable short month name, such as 'Oct'.\nDefaults to the system's locale if no locale has been specified",
    "examples": [
      "DateTime.local(2017, 10, 30).monthShort //=> Oct"
    ],
    "lineNumber": 1057,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 111,
    "kind": "get",
    "name": "monthLong",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#monthLong",
    "access": "public",
    "description": "Get the human readable long month name, such as 'October'.\nDefaults to the system's locale if no locale has been specified",
    "examples": [
      "DateTime.local(2017, 10, 30).monthLong //=> October"
    ],
    "lineNumber": 1067,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 112,
    "kind": "get",
    "name": "weekdayShort",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#weekdayShort",
    "access": "public",
    "description": "Get the human readable short weekday, such as 'Mon'.\nDefaults to the system's locale if no locale has been specified",
    "examples": [
      "DateTime.local(2017, 10, 30).weekdayShort //=> Mon"
    ],
    "lineNumber": 1077,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 113,
    "kind": "get",
    "name": "weekdayLong",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#weekdayLong",
    "access": "public",
    "description": "Get the human readable long weekday, such as 'Monday'.\nDefaults to the system's locale if no locale has been specified",
    "examples": [
      "DateTime.local(2017, 10, 30).weekdayLong //=> Monday"
    ],
    "lineNumber": 1087,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 114,
    "kind": "get",
    "name": "offset",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#offset",
    "access": "public",
    "description": "Get the UTC offset of this DateTime in minutes",
    "examples": [
      "DateTime.local().offset //=> -240",
      "DateTime.utc().offset //=> 0"
    ],
    "lineNumber": 1097,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 115,
    "kind": "get",
    "name": "offsetNameShort",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#offsetNameShort",
    "access": "public",
    "description": "Get the short human name for the zone's current offset, for example \"EST\" or \"EDT\".\nDefaults to the system's locale if no locale has been specified",
    "lineNumber": 1106,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 116,
    "kind": "get",
    "name": "offsetNameLong",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#offsetNameLong",
    "access": "public",
    "description": "Get the long human name for the zone's current offset, for example \"Eastern Standard Time\" or \"Eastern Daylight Time\".\nDefaults to the system's locale if no locale has been specified",
    "lineNumber": 1122,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 117,
    "kind": "get",
    "name": "isOffsetFixed",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#isOffsetFixed",
    "access": "public",
    "description": "Get whether this zone's offset ever changes, as in a DST.",
    "lineNumber": 1137,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 118,
    "kind": "get",
    "name": "isInDST",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#isInDST",
    "access": "public",
    "description": "Get whether the DateTime is in a DST.",
    "lineNumber": 1145,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 119,
    "kind": "get",
    "name": "isInLeapYear",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#isInLeapYear",
    "access": "public",
    "description": "Returns true if this DateTime is in a leap year, false otherwise",
    "examples": [
      "DateTime.local(2016).isInLeapYear //=> true",
      "DateTime.local(2013).isInLeapYear //=> false"
    ],
    "lineNumber": 1161,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 120,
    "kind": "get",
    "name": "daysInMonth",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#daysInMonth",
    "access": "public",
    "description": "Returns the number of days in this DateTime's month",
    "examples": [
      "DateTime.local(2016, 2).daysInMonth //=> 29",
      "DateTime.local(2016, 3).daysInMonth //=> 31"
    ],
    "lineNumber": 1171,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 121,
    "kind": "get",
    "name": "daysInYear",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#daysInYear",
    "access": "public",
    "description": "Returns the number of days in this DateTime's year",
    "examples": [
      "DateTime.local(2016).daysInYear //=> 366",
      "DateTime.local(2013).daysInYear //=> 365"
    ],
    "lineNumber": 1181,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 122,
    "kind": "get",
    "name": "weeksInWeekYear",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#weeksInWeekYear",
    "access": "public",
    "description": "Returns the number of weeks in this DateTime's year",
    "examples": [
      "DateTime.local(2004).weeksInWeekYear //=> 53",
      "DateTime.local(2013).weeksInWeekYear //=> 52"
    ],
    "see": [
      "https://en.wikipedia.org/wiki/ISO_week_date"
    ],
    "lineNumber": 1192,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "resolvedLocaleOpts",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#resolvedLocaleOpts",
    "access": "public",
    "description": "Returns the resolved Intl options for this DateTime.\nThis is useful in understanding the behavior of formatting methods",
    "lineNumber": 1202,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "the same options as toLocaleString"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "toUTC",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toUTC",
    "access": "public",
    "description": "\"Set\" the DateTime's zone to UTC. Returns a newly-constructed DateTime.\n\nEquivalent to {@link setZone}('utc')",
    "lineNumber": 1220,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "offset",
        "description": "optionally, an offset from UTC in minutes"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "opts",
        "description": "options to pass to `setZone()`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "toLocal",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toLocal",
    "access": "public",
    "description": "\"Set\" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.\n\nEquivalent to `setZone('local')`",
    "lineNumber": 1230,
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "setZone",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#setZone",
    "access": "public",
    "description": "\"Set\" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.\n\nBy default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link plus}. You may wish to use {@link toLocal} and {@link toUTC} which provide simple convenience wrappers for commonly used zones.",
    "lineNumber": 1243,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Zone"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'local'",
        "defaultRaw": "'local'",
        "name": "zone",
        "description": "a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link Zone} class."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "opts.keepLocalTime",
        "description": "If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "reconfigure",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#reconfigure",
    "access": "public",
    "description": "\"Set\" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.",
    "examples": [
      "DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })"
    ],
    "lineNumber": 1264,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "properties",
        "description": "the properties to set"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "setLocale",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#setLocale",
    "access": "public",
    "description": "\"Set\" the locale. Returns a newly-constructed DateTime.\nJust a convenient alias for reconfigure({ locale })",
    "examples": [
      "DateTime.local(2017, 5, 25).setLocale('en-GB')"
    ],
    "lineNumber": 1275,
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    },
    "params": [
      {
        "name": "locale",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "set",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#set",
    "access": "public",
    "description": "\"Set\" the values of specified units. Returns a newly-constructed DateTime.\nYou can only set units with this method; for \"setting\" metadata, see {@link reconfigure} and {@link setZone}.",
    "examples": [
      "dt.set({ year: 2017 })",
      "dt.set({ hour: 8, minute: 30 })",
      "dt.set({ weekday: 5 })",
      "dt.set({ year: 2005, ordinal: 234 })"
    ],
    "lineNumber": 1289,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "a mapping of units to numbers"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "plus",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#plus",
    "access": "public",
    "description": "Add a period of time to this DateTime and return the resulting DateTime\n\nAdding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.",
    "examples": [
      "DateTime.local().plus(123) //~> in 123 milliseconds",
      "DateTime.local().plus({ minutes: 15 }) //~> in 15 minutes",
      "DateTime.local().plus({ days: 1 }) //~> this time tomorrow",
      "DateTime.local().plus({ days: -1 }) //~> this time yesterday",
      "DateTime.local().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min",
      "DateTime.local().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min"
    ],
    "lineNumber": 1330,
    "params": [
      {
        "nullable": null,
        "types": [
          "Duration",
          "Object",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "duration",
        "description": "The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "minus",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#minus",
    "access": "public",
    "description": "Subtract a period of time to this DateTime and return the resulting DateTime\nSee {@link plus}",
    "lineNumber": 1342,
    "params": [
      {
        "nullable": null,
        "types": [
          "Duration",
          "Object",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "duration",
        "description": "The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "startOf",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#startOf",
    "access": "public",
    "description": "\"Set\" this DateTime to the beginning of a unit of time.",
    "examples": [
      "DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'",
      "DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'",
      "DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'",
      "DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'"
    ],
    "lineNumber": 1357,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "endOf",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#endOf",
    "access": "public",
    "description": "\"Set\" this DateTime to the end (i.e. the last millisecond) of a unit of time",
    "examples": [
      "DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'",
      "DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'",
      "DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'",
      "DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'"
    ],
    "lineNumber": 1408,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "The unit to go to the end of. Can be 'year', 'month', 'day', 'hour', 'minute', 'second', or 'millisecond'."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "toFormat",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toFormat",
    "access": "public",
    "description": "Returns a string representation of this DateTime formatted according to the specified format string.\n**You may not want this.** See {@link toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens).\nDefaults to en-US if no locale has been specified, regardless of the system's locale.",
    "examples": [
      "DateTime.local().toFormat('yyyy LLL dd') //=> '2017 Apr 22'",
      "DateTime.local().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'",
      "DateTime.local().toFormat('yyyy LLL dd', { locale: \"fr\" }) //=> '2017 avr. 22'",
      "DateTime.local().toFormat(\"HH 'hours and' mm 'minutes'\") //=> '20 hours and 55 minutes'"
    ],
    "see": [
      "https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens"
    ],
    "lineNumber": 1431,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "fmt",
        "description": "the format string"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "opts to override the configuration options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "toLocaleString",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toLocaleString",
    "access": "public",
    "description": "Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.\nThe exact behavior of this method is browser-specific, but in general it will return an appropriate representation\nof the DateTime in the assigned locale.\nDefaults to the system's locale if no locale has been specified",
    "examples": [
      "DateTime.local().toLocaleString(); //=> 4/20/2017",
      "DateTime.local().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'",
      "DateTime.local().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'",
      "DateTime.local().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'",
      "DateTime.local().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'",
      "DateTime.local().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'",
      "DateTime.local().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'",
      "DateTime.local().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'",
      "DateTime.local().toLocaleString({ hour: '2-digit', minute: '2-digit', hour12: false }); //=> '11:32'"
    ],
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat"
    ],
    "lineNumber": 1455,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "{Object} - Intl.DateTimeFormat constructor options and configuration options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 136,
    "kind": "method",
    "name": "toLocaleParts",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toLocaleParts",
    "access": "public",
    "description": "Returns an array of format \"parts\", i.e. individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.\nDefaults to the system's locale if no locale has been specified",
    "examples": [
      "DateTime.local().toLocaleString(); //=> [\n                                   //=>   { type: 'day', value: '25' },\n                                   //=>   { type: 'literal', value: '/' },\n                                   //=>   { type: 'month', value: '05' },\n                                   //=>   { type: 'literal', value: '/' },\n                                   //=>   { type: 'year', value: '1982' }\n                                   //=> ]"
    ],
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts"
    ],
    "lineNumber": 1474,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "{Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "method",
    "name": "toISO",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toISO",
    "access": "public",
    "description": "Returns an ISO 8601-compliant string representation of this DateTime",
    "examples": [
      "DateTime.utc(1982, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'",
      "DateTime.local().toISO() //=> '2017-04-22T20:47:05.335-04:00'",
      "DateTime.local().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'"
    ],
    "lineNumber": 1491,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "opts.suppressMilliseconds",
        "description": "exclude milliseconds from the format if they're 0"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "opts.suppressSeconds",
        "description": "exclude seconds from the format if they're 0"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "opts.includeOffset",
        "description": "include the offset, such as 'Z' or '-04:00'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 138,
    "kind": "method",
    "name": "toISODate",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toISODate",
    "access": "public",
    "description": "Returns an ISO 8601-compliant string representation of this DateTime's date component",
    "examples": [
      "DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'"
    ],
    "lineNumber": 1504,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 139,
    "kind": "method",
    "name": "toISOWeekDate",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toISOWeekDate",
    "access": "public",
    "description": "Returns an ISO 8601-compliant string representation of this DateTime's week date",
    "examples": [
      "DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'"
    ],
    "lineNumber": 1518,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 140,
    "kind": "method",
    "name": "toISOTime",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toISOTime",
    "access": "public",
    "description": "Returns an ISO 8601-compliant string representation of this DateTime's time component",
    "examples": [
      "DateTime.utc().hour(7).minute(34).toISOTime() //=> '07:34:19.361Z'",
      "DateTime.utc().hour(7).minute(34).toISOTime({ suppressSeconds: true }) //=> '07:34Z'"
    ],
    "lineNumber": 1532,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "opts.suppressMilliseconds",
        "description": "exclude milliseconds from the format if they're 0"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "opts.suppressSeconds",
        "description": "exclude seconds from the format if they're 0"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "opts.includeOffset",
        "description": "include the offset, such as 'Z' or '-04:00'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 141,
    "kind": "method",
    "name": "toRFC2822",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toRFC2822",
    "access": "public",
    "description": "Returns an RFC 2822-compatible string representation of this DateTime, always in UTC",
    "examples": [
      "DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'",
      "DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'"
    ],
    "lineNumber": 1546,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "toHTTP",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toHTTP",
    "access": "public",
    "description": "Returns a string representation of this DateTime appropriate for use in HTTP headers.\nSpecifically, the string conforms to RFC 1123.",
    "examples": [
      "DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'",
      "DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'"
    ],
    "see": [
      "https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1"
    ],
    "lineNumber": 1558,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "toSQLDate",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toSQLDate",
    "access": "public",
    "description": "Returns a string representation of this DateTime appropriate for use in SQL Date",
    "examples": [
      "DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'"
    ],
    "lineNumber": 1567,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "toSQLTime",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toSQLTime",
    "access": "public",
    "description": "Returns a string representation of this DateTime appropriate for use in SQL Time",
    "examples": [
      "DateTime.utc().toSQL() //=> '05:15:16.345'",
      "DateTime.local().toSQL() //=> '05:15:16.345 -04:00'",
      "DateTime.local().toSQL({ includeOffset: false }) //=> '05:15:16.345'",
      "DateTime.local().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'"
    ],
    "lineNumber": 1582,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "opts.includeZone",
        "description": "include the zone, such as 'America/New_York'. Overrides includeOffset."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "opts.includeOffset",
        "description": "include the offset, such as 'Z' or '-04:00'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "toSQL",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toSQL",
    "access": "public",
    "description": "Returns a string representation of this DateTime appropriate for use in SQL DateTime",
    "examples": [
      "DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'",
      "DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'",
      "DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'",
      "DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'"
    ],
    "lineNumber": 1601,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "opts.includeZone",
        "description": "include the zone, such as 'America/New_York'. Overrides includeOffset."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "opts.includeOffset",
        "description": "include the offset, such as 'Z' or '-04:00'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "toString",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toString",
    "access": "public",
    "description": "Returns a string representation of this DateTime appropriate for debugging",
    "lineNumber": 1613,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "valueOf",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#valueOf",
    "access": "public",
    "description": "Returns the epoch milliseconds of this DateTime. Alias of {@link toMillis}",
    "lineNumber": 1621,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "toMillis",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toMillis",
    "access": "public",
    "description": "Returns the epoch milliseconds of this DateTime.",
    "lineNumber": 1629,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "toSeconds",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toSeconds",
    "access": "public",
    "description": "Returns the epoch seconds of this DateTime.",
    "lineNumber": 1637,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "toJSON",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toJSON",
    "access": "public",
    "description": "Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.",
    "lineNumber": 1645,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "toBSON",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toBSON",
    "access": "public",
    "description": "Returns a BSON serializable equivalent to this DateTime.",
    "lineNumber": 1653,
    "return": {
      "nullable": null,
      "types": [
        "Date"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "toObject",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toObject",
    "access": "public",
    "description": "Returns a Javascript object with this DateTime's year, month, day, and so on.",
    "examples": [
      "DateTime.local().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }"
    ],
    "lineNumber": 1664,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options for generating the object"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "opts.includeConfig",
        "description": "include configuration attributes in the output"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "toJSDate",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toJSDate",
    "access": "public",
    "description": "Returns a Javascript Date equivalent to this DateTime.",
    "lineNumber": 1681,
    "return": {
      "nullable": null,
      "types": [
        "Date"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 154,
    "kind": "method",
    "name": "diff",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#diff",
    "access": "public",
    "description": "Return the difference between two DateTimes as a Duration.",
    "examples": [
      "var i1 = DateTime.fromISO('1982-05-25T09:45'),\n    i2 = DateTime.fromISO('1983-10-14T10:30');\ni2.diff(i1).toObject() //=> { milliseconds: 43807500000 }\ni2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }\ni2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }\ni2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }"
    ],
    "lineNumber": 1702,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "otherDateTime",
        "description": "the DateTime to compare this one to"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "string[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "['milliseconds']",
        "defaultRaw": "['milliseconds']",
        "name": "unit",
        "description": "the unit or array of units (such as 'hours' or 'days') to include in the duration."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options that affect the creation of the Duration"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'casual'",
        "defaultRaw": "'casual'",
        "name": "opts.conversionAccuracy",
        "description": "the conversion system to use"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "diffNow",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#diffNow",
    "access": "public",
    "description": "Return the difference between this DateTime and right now.\nSee {@link diff}",
    "lineNumber": 1732,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "string[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "['milliseconds']",
        "defaultRaw": "['milliseconds']",
        "name": "unit",
        "description": "the unit or units units (such as 'hours' or 'days') to include in the duration"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options that affect the creation of the Duration"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'casual'",
        "defaultRaw": "'casual'",
        "name": "opts.conversionAccuracy",
        "description": "the conversion system to use"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "until",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#until",
    "access": "public",
    "description": "Return an Interval spanning between this DateTime and another DateTime",
    "lineNumber": 1741,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "otherDateTime",
        "description": "the other end point of the Interval"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "hasSame",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#hasSame",
    "access": "public",
    "description": "Return whether this DateTime is in the same unit of time as another DateTime",
    "examples": [
      "DateTime.local().hasSame(otherDT, 'day'); //~> true if both the same calendar day"
    ],
    "lineNumber": 1752,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "otherDateTime",
        "description": "the other DateTime"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of time to check sameness on"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "equals",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#equals",
    "access": "public",
    "description": "Equality check\nTwo DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.\nTo compare just the millisecond values, use `+dt1 === ~dt2`.",
    "lineNumber": 1769,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other DateTime"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "toRelative",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toRelative",
    "access": "public",
    "description": "Returns a string representation of a this time relative to now, such as \"in two days\". Can only internationalize if your\nplatform supports Intl.RelativeDateFormat, **which it probably doesn't yet!** (As of this writing, only Chrome supports that). Rounds down by default.",
    "examples": [
      "DateTime.local().plus({ days: 1 }).toRelative() //=> \"in 1 day\"",
      "DateTime.local().setLocale(\"es\").toRelative({ days: 1 }) //=> \"dentro de 1 da\"",
      "DateTime.local().plus({ days: 1 }).toRelative({ locale: \"fr\" }) //=> \"dans 23 heures\"",
      "DateTime.local().minus({ days: 2 }).toRelative() //=> \"2 days ago\"",
      "DateTime.local().minus({ days: 2 }).toRelative({ unit: \"hours\" }) //=> \"48 hours ago\"",
      "DateTime.local().minus({ hours: 36 }).toRelative({ round: false }) //=> \"1.5 days ago\""
    ],
    "lineNumber": 1797,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "options that affect the output"
      },
      {
        "nullable": null,
        "types": [
          "DateTime"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DateTime.local()",
        "defaultRaw": "DateTime.local()",
        "name": "options.base",
        "description": "the DateTime to use as the basis to which this time is compared. Defaults to now."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"long\"",
        "defaultRaw": "long",
        "name": "options.style",
        "description": "the style of units, must be \"long\", \"short\", or \"narrow\""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.unit",
        "description": "use a specific unit; if omitted, the method will pick the unit. Use one of \"year\", \"quarter\", \"month\", \"week\", \"day\", \"hour\", \"minute\", or \"second\""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.round",
        "description": "whether to round the numbers in the output."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "options.padding",
        "description": "padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.locale",
        "description": "override the locale of this DateTime"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.numberingSystem",
        "description": "override the numberingSystem of this DateTime. The Intl system may choose not to honor this"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "toRelativeCalendar",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/datetime.js~DateTime#toRelativeCalendar",
    "access": "public",
    "description": "Returns a string representation of this date relative to today, such as \"yesterday\" or \"next month\"\nplatform supports Intl.RelativeDateFormat.",
    "examples": [
      "DateTime.local().plus({ days: 1 }).toRelativeCalendar() //=> \"tomorrow\"",
      "DateTime.local().setLocale(\"es\").plus({ days: 1 }).toRelative() //=> \"\"maana\"",
      "DateTime.local().plus({ days: 1 }).toRelativeCalendar({ locale: \"fr\" }) //=> \"demain\"",
      "DateTime.local().minus({ days: 2 }).toRelativeCalendar() //=> \"2 days ago\""
    ],
    "lineNumber": 1824,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "options that affect the output"
      },
      {
        "nullable": null,
        "types": [
          "DateTime"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DateTime.local()",
        "defaultRaw": "DateTime.local()",
        "name": "options.base",
        "description": "the DateTime to use as the basis to which this time is compared. Defaults to now."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.locale",
        "description": "override the locale of this DateTime"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.unit",
        "description": "use a specific unit; if omitted, the method will pick the unit. Use one of \"year\", \"quarter\", \"month\", \"week\", or \"day\""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.numberingSystem",
        "description": "override the numberingSystem of this DateTime. The Intl system may choose not to honor this"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "min",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.min",
    "access": "public",
    "description": "Return the min of several date times",
    "lineNumber": 1843,
    "params": [
      {
        "nullable": null,
        "types": [
          "...DateTime"
        ],
        "spread": true,
        "optional": false,
        "name": "dateTimes",
        "description": "the DateTimes from which to choose the minimum"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": "the min DateTime, or undefined if called with no argument"
    }
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "max",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.max",
    "access": "public",
    "description": "Return the max of several date times",
    "lineNumber": 1852,
    "params": [
      {
        "nullable": null,
        "types": [
          "...DateTime"
        ],
        "spread": true,
        "optional": false,
        "name": "dateTimes",
        "description": "the DateTimes from which to choose the maximum"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": "the max DateTime, or undefined if called with no argument"
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "fromFormatExplain",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.fromFormatExplain",
    "access": "public",
    "description": "Explain how a string would be parsed by fromFormat()",
    "lineNumber": 1865,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the string to parse"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "fmt",
        "description": "the format the string is expected to be in (see description)"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "options taken by fromFormat()"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "fromStringExplain",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.fromStringExplain",
    "access": "public",
    "description": "",
    "lineNumber": 1878,
    "deprecated": "use fromFormatExplain instead",
    "params": [
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "fmt",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "get",
    "name": "DATE_SHORT",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.DATE_SHORT",
    "access": "public",
    "description": "{@link toLocaleString} format like 10/14/1983",
    "lineNumber": 1888,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 166,
    "kind": "get",
    "name": "DATE_MED",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.DATE_MED",
    "access": "public",
    "description": "{@link toLocaleString} format like 'Oct 14, 1983'",
    "lineNumber": 1896,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 167,
    "kind": "get",
    "name": "DATE_FULL",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.DATE_FULL",
    "access": "public",
    "description": "{@link toLocaleString} format like 'October 14, 1983'",
    "lineNumber": 1904,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 168,
    "kind": "get",
    "name": "DATE_HUGE",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.DATE_HUGE",
    "access": "public",
    "description": "{@link toLocaleString} format like 'Tuesday, October 14, 1983'",
    "lineNumber": 1912,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 169,
    "kind": "get",
    "name": "TIME_SIMPLE",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.TIME_SIMPLE",
    "access": "public",
    "description": "{@link toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.",
    "lineNumber": 1920,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 170,
    "kind": "get",
    "name": "TIME_WITH_SECONDS",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.TIME_WITH_SECONDS",
    "access": "public",
    "description": "{@link toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.",
    "lineNumber": 1928,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 171,
    "kind": "get",
    "name": "TIME_WITH_SHORT_OFFSET",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.TIME_WITH_SHORT_OFFSET",
    "access": "public",
    "description": "{@link toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.",
    "lineNumber": 1936,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 172,
    "kind": "get",
    "name": "TIME_WITH_LONG_OFFSET",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.TIME_WITH_LONG_OFFSET",
    "access": "public",
    "description": "{@link toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.",
    "lineNumber": 1944,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 173,
    "kind": "get",
    "name": "TIME_24_SIMPLE",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.TIME_24_SIMPLE",
    "access": "public",
    "description": "{@link toLocaleString} format like '09:30', always 24-hour.",
    "lineNumber": 1952,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 174,
    "kind": "get",
    "name": "TIME_24_WITH_SECONDS",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.TIME_24_WITH_SECONDS",
    "access": "public",
    "description": "{@link toLocaleString} format like '09:30:23', always 24-hour.",
    "lineNumber": 1960,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 175,
    "kind": "get",
    "name": "TIME_24_WITH_SHORT_OFFSET",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.TIME_24_WITH_SHORT_OFFSET",
    "access": "public",
    "description": "{@link toLocaleString} format like '09:30:23 EDT', always 24-hour.",
    "lineNumber": 1968,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 176,
    "kind": "get",
    "name": "TIME_24_WITH_LONG_OFFSET",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.TIME_24_WITH_LONG_OFFSET",
    "access": "public",
    "description": "{@link toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.",
    "lineNumber": 1976,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 177,
    "kind": "get",
    "name": "DATETIME_SHORT",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.DATETIME_SHORT",
    "access": "public",
    "description": "{@link toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.",
    "lineNumber": 1984,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 178,
    "kind": "get",
    "name": "DATETIME_SHORT_WITH_SECONDS",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.DATETIME_SHORT_WITH_SECONDS",
    "access": "public",
    "description": "{@link toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.",
    "lineNumber": 1992,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 179,
    "kind": "get",
    "name": "DATETIME_MED",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.DATETIME_MED",
    "access": "public",
    "description": "{@link toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.",
    "lineNumber": 2000,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 180,
    "kind": "get",
    "name": "DATETIME_MED_WITH_SECONDS",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.DATETIME_MED_WITH_SECONDS",
    "access": "public",
    "description": "{@link toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.",
    "lineNumber": 2008,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 181,
    "kind": "get",
    "name": "DATETIME_FULL",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.DATETIME_FULL",
    "access": "public",
    "description": "{@link toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.",
    "lineNumber": 2016,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 182,
    "kind": "get",
    "name": "DATETIME_FULL_WITH_SECONDS",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.DATETIME_FULL_WITH_SECONDS",
    "access": "public",
    "description": "{@link toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.",
    "lineNumber": 2024,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 183,
    "kind": "get",
    "name": "DATETIME_HUGE",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.DATETIME_HUGE",
    "access": "public",
    "description": "{@link toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.",
    "lineNumber": 2032,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 184,
    "kind": "get",
    "name": "DATETIME_HUGE_WITH_SECONDS",
    "memberof": "src/datetime.js~DateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~DateTime.DATETIME_HUGE_WITH_SECONDS",
    "access": "public",
    "description": "{@link toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.",
    "lineNumber": 2040,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 185,
    "kind": "function",
    "name": "friendlyDateTime",
    "memberof": "src/datetime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/datetime.js~friendlyDateTime",
    "access": "private",
    "export": true,
    "importPath": "luxon/src/datetime.js",
    "importStyle": "{friendlyDateTime}",
    "description": "",
    "lineNumber": 2048,
    "ignore": true,
    "params": [
      {
        "name": "dateTimeish",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 186,
    "kind": "file",
    "name": "src/duration.js",
    "content": "import { isUndefined, isNumber, normalizeObject } from \"./impl/util.js\";\r\nimport Locale from \"./impl/locale.js\";\r\nimport Formatter from \"./impl/formatter.js\";\r\nimport { parseISODuration } from \"./impl/regexParser.js\";\r\nimport Settings from \"./settings.js\";\r\nimport { InvalidArgumentError, InvalidDurationError, InvalidUnitError } from \"./errors.js\";\r\nimport Invalid from \"./impl/invalid.js\";\r\n\r\nconst INVALID = \"Invalid Duration\";\r\n\r\n// unit conversion constants\r\nconst lowOrderMatrix = {\r\n    weeks: {\r\n      days: 7,\r\n      hours: 7 * 24,\r\n      minutes: 7 * 24 * 60,\r\n      seconds: 7 * 24 * 60 * 60,\r\n      milliseconds: 7 * 24 * 60 * 60 * 1000\r\n    },\r\n    days: {\r\n      hours: 24,\r\n      minutes: 24 * 60,\r\n      seconds: 24 * 60 * 60,\r\n      milliseconds: 24 * 60 * 60 * 1000\r\n    },\r\n    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1000 },\r\n    minutes: { seconds: 60, milliseconds: 60 * 1000 },\r\n    seconds: { milliseconds: 1000 }\r\n  },\r\n  casualMatrix = Object.assign(\r\n    {\r\n      years: {\r\n        months: 12,\r\n        weeks: 52,\r\n        days: 365,\r\n        hours: 365 * 24,\r\n        minutes: 365 * 24 * 60,\r\n        seconds: 365 * 24 * 60 * 60,\r\n        milliseconds: 365 * 24 * 60 * 60 * 1000\r\n      },\r\n      quarters: {\r\n        months: 3,\r\n        weeks: 13,\r\n        days: 91,\r\n        hours: 91 * 24,\r\n        minutes: 91 * 24 * 60,\r\n        milliseconds: 91 * 24 * 60 * 60 * 1000\r\n      },\r\n      months: {\r\n        weeks: 4,\r\n        days: 30,\r\n        hours: 30 * 24,\r\n        minutes: 30 * 24 * 60,\r\n        seconds: 30 * 24 * 60 * 60,\r\n        milliseconds: 30 * 24 * 60 * 60 * 1000\r\n      }\r\n    },\r\n    lowOrderMatrix\r\n  ),\r\n  daysInYearAccurate = 146097.0 / 400,\r\n  daysInMonthAccurate = 146097.0 / 4800,\r\n  accurateMatrix = Object.assign(\r\n    {\r\n      years: {\r\n        months: 12,\r\n        weeks: daysInYearAccurate / 7,\r\n        days: daysInYearAccurate,\r\n        hours: daysInYearAccurate * 24,\r\n        minutes: daysInYearAccurate * 24 * 60,\r\n        seconds: daysInYearAccurate * 24 * 60 * 60,\r\n        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000\r\n      },\r\n      quarters: {\r\n        months: 3,\r\n        weeks: daysInYearAccurate / 28,\r\n        days: daysInYearAccurate / 4,\r\n        hours: (daysInYearAccurate * 24) / 4,\r\n        minutes: (daysInYearAccurate * 24 * 60) / 4,\r\n        seconds: (daysInYearAccurate * 24 * 60 * 60) / 4,\r\n        milliseconds: (daysInYearAccurate * 24 * 60 * 60 * 1000) / 4\r\n      },\r\n      months: {\r\n        weeks: daysInMonthAccurate / 7,\r\n        days: daysInMonthAccurate,\r\n        hours: daysInMonthAccurate * 24,\r\n        minutes: daysInMonthAccurate * 24 * 60,\r\n        seconds: daysInMonthAccurate * 24 * 60 * 60,\r\n        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000\r\n      }\r\n    },\r\n    lowOrderMatrix\r\n  );\r\n\r\n// units ordered by size\r\nconst orderedUnits = [\r\n  \"years\",\r\n  \"quarters\",\r\n  \"months\",\r\n  \"weeks\",\r\n  \"days\",\r\n  \"hours\",\r\n  \"minutes\",\r\n  \"seconds\",\r\n  \"milliseconds\"\r\n];\r\n\r\nconst reverseUnits = orderedUnits.slice(0).reverse();\r\n\r\n// clone really means \"create another instance just like this one, but with these changes\"\r\nfunction clone(dur, alts, clear = false) {\r\n  // deep merge for vals\r\n  const conf = {\r\n    values: clear ? alts.values : Object.assign({}, dur.values, alts.values || {}),\r\n    loc: dur.loc.clone(alts.loc),\r\n    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy\r\n  };\r\n  return new Duration(conf);\r\n}\r\n\r\nfunction antiTrunc(n) {\r\n  return n < 0 ? Math.floor(n) : Math.ceil(n);\r\n}\r\n\r\n// NB: mutates parameters\r\nfunction convert(matrix, fromMap, fromUnit, toMap, toUnit) {\r\n  const conv = matrix[toUnit][fromUnit],\r\n    raw = fromMap[fromUnit] / conv,\r\n    sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]),\r\n    // ok, so this is wild, but see the matrix in the tests\r\n    added =\r\n      !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);\r\n  toMap[toUnit] += added;\r\n  fromMap[fromUnit] -= added * conv;\r\n}\r\n\r\n// NB: mutates parameters\r\nfunction normalizeValues(matrix, vals) {\r\n  reverseUnits.reduce((previous, current) => {\r\n    if (!isUndefined(vals[current])) {\r\n      if (previous) {\r\n        convert(matrix, vals, previous, vals, current);\r\n      }\r\n      return current;\r\n    } else {\r\n      return previous;\r\n    }\r\n  }, null);\r\n}\r\n\r\n/**\r\n * A Duration object represents a period of time, like \"2 months\" or \"1 day, 1 hour\". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime.plus} to add a Duration object to a DateTime, producing another DateTime.\r\n *\r\n * Here is a brief overview of commonly used methods and getters in Duration:\r\n *\r\n * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.\r\n * * **Unit values** See the {@link Duration.years}, {@link Duration.months}, {@link Duration.weeks}, {@link Duration.days}, {@link Duration.hours}, {@link Duration.minutes}, {@link Duration.seconds}, {@link Duration.milliseconds} accessors.\r\n * * **Configuration** See  {@link Duration.locale} and {@link Duration.numberingSystem} accessors.\r\n * * **Transformation** To create new Durations out of old ones use {@link Duration.plus}, {@link Duration.minus}, {@link Duration.normalize}, {@link Duration.set}, {@link Duration.reconfigure}, {@link Duration.shiftTo}, and {@link Duration.negate}.\r\n * * **Output** To convert the Duration into other representations, see {@link Duration.as}, {@link Duration.toISO}, {@link Duration.toFormat}, and {@link Duration.toJSON}\r\n *\r\n * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.\r\n */\r\nexport default class Duration {\r\n  /**\r\n   * @private\r\n   */\r\n  constructor(config) {\r\n    const accurate = config.conversionAccuracy === \"longterm\" || false;\r\n    /**\r\n     * @access private\r\n     */\r\n    this.values = config.values;\r\n    /**\r\n     * @access private\r\n     */\r\n    this.loc = config.loc || Locale.create();\r\n    /**\r\n     * @access private\r\n     */\r\n    this.conversionAccuracy = accurate ? \"longterm\" : \"casual\";\r\n    /**\r\n     * @access private\r\n     */\r\n    this.invalid = config.invalid || null;\r\n    /**\r\n     * @access private\r\n     */\r\n    this.matrix = accurate ? accurateMatrix : casualMatrix;\r\n    /**\r\n     * @access private\r\n     */\r\n    this.isLuxonDuration = true;\r\n  }\r\n\r\n  /**\r\n   * Create Duration from a number of milliseconds.\r\n   * @param {number} count of milliseconds\r\n   * @param {Object} opts - options for parsing\r\n   * @param {string} [opts.locale='en-US'] - the locale to use\r\n   * @param {string} opts.numberingSystem - the numbering system to use\r\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\r\n   * @return {Duration}\r\n   */\r\n  static fromMillis(count, opts) {\r\n    return Duration.fromObject(Object.assign({ milliseconds: count }, opts));\r\n  }\r\n\r\n  /**\r\n   * Create a Duration from a Javascript object with keys like 'years' and 'hours.\r\n   * If this object is empty then a zero milliseconds duration is returned.\r\n   * @param {Object} obj - the object to create the DateTime from\r\n   * @param {number} obj.years\r\n   * @param {number} obj.quarters\r\n   * @param {number} obj.months\r\n   * @param {number} obj.weeks\r\n   * @param {number} obj.days\r\n   * @param {number} obj.hours\r\n   * @param {number} obj.minutes\r\n   * @param {number} obj.seconds\r\n   * @param {number} obj.milliseconds\r\n   * @param {string} [obj.locale='en-US'] - the locale to use\r\n   * @param {string} obj.numberingSystem - the numbering system to use\r\n   * @param {string} [obj.conversionAccuracy='casual'] - the conversion system to use\r\n   * @return {Duration}\r\n   */\r\n  static fromObject(obj) {\r\n    if (obj == null || typeof obj !== \"object\") {\r\n      throw new InvalidArgumentError(\r\n        `Duration.fromObject: argument expected to be an object, got ${typeof obj}`\r\n      );\r\n    }\r\n    return new Duration({\r\n      values: normalizeObject(obj, Duration.normalizeUnit, [\r\n        \"locale\",\r\n        \"numberingSystem\",\r\n        \"conversionAccuracy\"\r\n      ]),\r\n      loc: Locale.fromObject(obj),\r\n      conversionAccuracy: obj.conversionAccuracy\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create a Duration from an ISO 8601 duration string.\r\n   * @param {string} text - text to parse\r\n   * @param {Object} opts - options for parsing\r\n   * @param {string} [opts.locale='en-US'] - the locale to use\r\n   * @param {string} opts.numberingSystem - the numbering system to use\r\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\r\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\r\n   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }\r\n   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }\r\n   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }\r\n   * @return {Duration}\r\n   */\r\n  static fromISO(text, opts) {\r\n    const [parsed] = parseISODuration(text);\r\n    if (parsed) {\r\n      const obj = Object.assign(parsed, opts);\r\n      return Duration.fromObject(obj);\r\n    } else {\r\n      return Duration.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create an invalid Duration.\r\n   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent\r\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\r\n   * @return {Duration}\r\n   */\r\n  static invalid(reason, explanation = null) {\r\n    if (!reason) {\r\n      throw new InvalidArgumentError(\"need to specify a reason the Duration is invalid\");\r\n    }\r\n\r\n    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);\r\n\r\n    if (Settings.throwOnInvalid) {\r\n      throw new InvalidDurationError(invalid);\r\n    } else {\r\n      return new Duration({ invalid });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  static normalizeUnit(unit) {\r\n    const normalized = {\r\n      year: \"years\",\r\n      years: \"years\",\r\n      quarter: \"quarters\",\r\n      quarters: \"quarters\",\r\n      month: \"months\",\r\n      months: \"months\",\r\n      week: \"weeks\",\r\n      weeks: \"weeks\",\r\n      day: \"days\",\r\n      days: \"days\",\r\n      hour: \"hours\",\r\n      hours: \"hours\",\r\n      minute: \"minutes\",\r\n      minutes: \"minutes\",\r\n      second: \"seconds\",\r\n      seconds: \"seconds\",\r\n      millisecond: \"milliseconds\",\r\n      milliseconds: \"milliseconds\"\r\n    }[unit ? unit.toLowerCase() : unit];\r\n\r\n    if (!normalized) throw new InvalidUnitError(unit);\r\n\r\n    return normalized;\r\n  }\r\n\r\n  /**\r\n   * Check if an object is a Duration. Works across context boundaries\r\n   * @param {object} o\r\n   * @return {boolean}\r\n   */\r\n  static isDuration(o) {\r\n    return (o && o.isLuxonDuration) || false;\r\n  }\r\n\r\n  /**\r\n   * Get  the locale of a Duration, such 'en-GB'\r\n   * @type {string}\r\n   */\r\n  get locale() {\r\n    return this.isValid ? this.loc.locale : null;\r\n  }\r\n\r\n  /**\r\n   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration\r\n   *\r\n   * @type {string}\r\n   */\r\n  get numberingSystem() {\r\n    return this.isValid ? this.loc.numberingSystem : null;\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:\r\n   * * `S` for milliseconds\r\n   * * `s` for seconds\r\n   * * `m` for minutes\r\n   * * `h` for hours\r\n   * * `d` for days\r\n   * * `M` for months\r\n   * * `y` for years\r\n   * Notes:\r\n   * * Add padding by repeating the token, e.g. \"yy\" pads the years to two digits, \"hhhh\" pads the hours out to four digits\r\n   * * The duration will be converted to the set of units in the format string using {@link Duration.shiftTo} and the Durations's conversion accuracy setting.\r\n   * @param {string} fmt - the format string\r\n   * @param {Object} opts - options\r\n   * @param {boolean} [opts.floor=true] - floor numerical values\r\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"y d s\") //=> \"1 6 2\"\r\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"yy dd sss\") //=> \"01 06 002\"\r\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"M S\") //=> \"12 518402000\"\r\n   * @return {string}\r\n   */\r\n  toFormat(fmt, opts = {}) {\r\n    // reverse-compat since 1.2; we always round down now, never up, and we do it by default\r\n    const fmtOpts = Object.assign({}, opts, {\r\n      floor: opts.round !== false && opts.floor !== false\r\n    });\r\n    return this.isValid\r\n      ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt)\r\n      : INVALID;\r\n  }\r\n\r\n  /**\r\n   * Returns a Javascript object with this Duration's values.\r\n   * @param opts - options for generating the object\r\n   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output\r\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }\r\n   * @return {Object}\r\n   */\r\n  toObject(opts = {}) {\r\n    if (!this.isValid) return {};\r\n\r\n    const base = Object.assign({}, this.values);\r\n\r\n    if (opts.includeConfig) {\r\n      base.conversionAccuracy = this.conversionAccuracy;\r\n      base.numberingSystem = this.loc.numberingSystem;\r\n      base.locale = this.loc.locale;\r\n    }\r\n    return base;\r\n  }\r\n\r\n  /**\r\n   * Returns an ISO 8601-compliant string representation of this Duration.\r\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\r\n   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'\r\n   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'\r\n   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'\r\n   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'\r\n   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'\r\n   * @return {string}\r\n   */\r\n  toISO() {\r\n    // we could use the formatter, but this is an easier way to get the minimum string\r\n    if (!this.isValid) return null;\r\n\r\n    let s = \"P\";\r\n    if (this.years !== 0) s += this.years + \"Y\";\r\n    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + \"M\";\r\n    if (this.weeks !== 0) s += this.weeks + \"W\";\r\n    if (this.days !== 0) s += this.days + \"D\";\r\n    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)\r\n      s += \"T\";\r\n    if (this.hours !== 0) s += this.hours + \"H\";\r\n    if (this.minutes !== 0) s += this.minutes + \"M\";\r\n    if (this.seconds !== 0 || this.milliseconds !== 0)\r\n      s += this.seconds + this.milliseconds / 1000 + \"S\";\r\n    if (s === \"P\") s += \"T0S\";\r\n    return s;\r\n  }\r\n\r\n  /**\r\n   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.\r\n   * @return {string}\r\n   */\r\n  toJSON() {\r\n    return this.toISO();\r\n  }\r\n\r\n  /**\r\n   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    return this.toISO();\r\n  }\r\n\r\n  /**\r\n   * Returns an milliseconds value of this Duration.\r\n   * @return {number}\r\n   */\r\n  valueOf() {\r\n    return this.as(\"milliseconds\");\r\n  }\r\n\r\n  /**\r\n   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.\r\n   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\r\n   * @return {Duration}\r\n   */\r\n  plus(duration) {\r\n    if (!this.isValid) return this;\r\n\r\n    const dur = friendlyDuration(duration),\r\n      result = {};\r\n\r\n    for (const k of orderedUnits) {\r\n      if (dur.values.hasOwnProperty(k) || this.values.hasOwnProperty(k)) {\r\n        result[k] = dur.get(k) + this.get(k);\r\n      }\r\n    }\r\n\r\n    return clone(this, { values: result }, true);\r\n  }\r\n\r\n  /**\r\n   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.\r\n   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\r\n   * @return {Duration}\r\n   */\r\n  minus(duration) {\r\n    if (!this.isValid) return this;\r\n\r\n    const dur = friendlyDuration(duration);\r\n    return this.plus(dur.negate());\r\n  }\r\n\r\n  /**\r\n   * Get the value of unit.\r\n   * @param {string} unit - a unit such as 'minute' or 'day'\r\n   * @example Duration.fromObject({years: 2, days: 3}).years //=> 2\r\n   * @example Duration.fromObject({years: 2, days: 3}).months //=> 0\r\n   * @example Duration.fromObject({years: 2, days: 3}).days //=> 3\r\n   * @return {number}\r\n   */\r\n  get(unit) {\r\n    return this[Duration.normalizeUnit(unit)];\r\n  }\r\n\r\n  /**\r\n   * \"Set\" the values of specified units. Return a newly-constructed Duration.\r\n   * @param {Object} values - a mapping of units to numbers\r\n   * @example dur.set({ years: 2017 })\r\n   * @example dur.set({ hours: 8, minutes: 30 })\r\n   * @return {Duration}\r\n   */\r\n  set(values) {\r\n    if (!this.isValid) return this;\r\n\r\n    const mixed = Object.assign(this.values, normalizeObject(values, Duration.normalizeUnit, []));\r\n    return clone(this, { values: mixed });\r\n  }\r\n\r\n  /**\r\n   * \"Set\" the locale and/or numberingSystem.  Returns a newly-constructed Duration.\r\n   * @example dur.reconfigure({ locale: 'en-GB' })\r\n   * @return {Duration}\r\n   */\r\n  reconfigure({ locale, numberingSystem, conversionAccuracy } = {}) {\r\n    const loc = this.loc.clone({ locale, numberingSystem }),\r\n      opts = { loc };\r\n\r\n    if (conversionAccuracy) {\r\n      opts.conversionAccuracy = conversionAccuracy;\r\n    }\r\n\r\n    return clone(this, opts);\r\n  }\r\n\r\n  /**\r\n   * Return the length of the duration in the specified unit.\r\n   * @param {string} unit - a unit such as 'minutes' or 'days'\r\n   * @example Duration.fromObject({years: 1}).as('days') //=> 365\r\n   * @example Duration.fromObject({years: 1}).as('months') //=> 12\r\n   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5\r\n   * @return {number}\r\n   */\r\n  as(unit) {\r\n    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;\r\n  }\r\n\r\n  /**\r\n   * Reduce this Duration to its canonical representation in its current units.\r\n   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }\r\n   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }\r\n   * @return {Duration}\r\n   */\r\n  normalize() {\r\n    if (!this.isValid) return this;\r\n    const vals = this.toObject();\r\n    normalizeValues(this.matrix, vals);\r\n    return Duration.fromObject(vals);\r\n  }\r\n\r\n  /**\r\n   * Convert this Duration into its representation in a different set of units.\r\n   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }\r\n   * @return {Duration}\r\n   */\r\n  shiftTo(...units) {\r\n    if (!this.isValid) return this;\r\n\r\n    if (units.length === 0) {\r\n      return this;\r\n    }\r\n\r\n    units = units.map(u => Duration.normalizeUnit(u));\r\n\r\n    const built = {},\r\n      accumulated = {},\r\n      vals = this.toObject();\r\n    let lastUnit;\r\n\r\n    normalizeValues(this.matrix, vals);\r\n\r\n    for (const k of orderedUnits) {\r\n      if (units.indexOf(k) >= 0) {\r\n        lastUnit = k;\r\n\r\n        let own = 0;\r\n\r\n        // anything we haven't boiled down yet should get boiled to this unit\r\n        for (const ak in accumulated) {\r\n          own += this.matrix[ak][k] * accumulated[ak];\r\n          accumulated[ak] = 0;\r\n        }\r\n\r\n        // plus anything that's already in this unit\r\n        if (isNumber(vals[k])) {\r\n          own += vals[k];\r\n        }\r\n\r\n        const i = Math.trunc(own);\r\n        built[k] = i;\r\n        accumulated[k] = own - i; // we'd like to absorb these fractions in another unit\r\n\r\n        // plus anything further down the chain that should be rolled up in to this\r\n        for (const down in vals) {\r\n          if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k)) {\r\n            convert(this.matrix, vals, down, built, k);\r\n          }\r\n        }\r\n        // otherwise, keep it in the wings to boil it later\r\n      } else if (isNumber(vals[k])) {\r\n        accumulated[k] = vals[k];\r\n      }\r\n    }\r\n\r\n    // anything leftover becomes the decimal for the last unit\r\n    // lastUnit must be defined since units is not empty\r\n    for (const key in accumulated) {\r\n      if (accumulated[key] !== 0) {\r\n        built[lastUnit] +=\r\n          key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];\r\n      }\r\n    }\r\n\r\n    return clone(this, { values: built }, true);\r\n  }\r\n\r\n  /**\r\n   * Return the negative of this Duration.\r\n   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }\r\n   * @return {Duration}\r\n   */\r\n  negate() {\r\n    if (!this.isValid) return this;\r\n    const negated = {};\r\n    for (const k of Object.keys(this.values)) {\r\n      negated[k] = -this.values[k];\r\n    }\r\n    return clone(this, { values: negated }, true);\r\n  }\r\n\r\n  /**\r\n   * Get the years.\r\n   * @type {number}\r\n   */\r\n  get years() {\r\n    return this.isValid ? this.values.years || 0 : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the quarters.\r\n   * @type {number}\r\n   */\r\n  get quarters() {\r\n    return this.isValid ? this.values.quarters || 0 : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the months.\r\n   * @type {number}\r\n   */\r\n  get months() {\r\n    return this.isValid ? this.values.months || 0 : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the weeks\r\n   * @type {number}\r\n   */\r\n  get weeks() {\r\n    return this.isValid ? this.values.weeks || 0 : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the days.\r\n   * @type {number}\r\n   */\r\n  get days() {\r\n    return this.isValid ? this.values.days || 0 : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the hours.\r\n   * @type {number}\r\n   */\r\n  get hours() {\r\n    return this.isValid ? this.values.hours || 0 : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the minutes.\r\n   * @type {number}\r\n   */\r\n  get minutes() {\r\n    return this.isValid ? this.values.minutes || 0 : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the seconds.\r\n   * @return {number}\r\n   */\r\n  get seconds() {\r\n    return this.isValid ? this.values.seconds || 0 : NaN;\r\n  }\r\n\r\n  /**\r\n   * Get the milliseconds.\r\n   * @return {number}\r\n   */\r\n  get milliseconds() {\r\n    return this.isValid ? this.values.milliseconds || 0 : NaN;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations\r\n   * on invalid DateTimes or Intervals.\r\n   * @return {boolean}\r\n   */\r\n  get isValid() {\r\n    return this.invalid === null;\r\n  }\r\n\r\n  /**\r\n   * Returns an error code if this Duration became invalid, or null if the Duration is valid\r\n   * @return {string}\r\n   */\r\n  get invalidReason() {\r\n    return this.invalid ? this.invalid.reason : null;\r\n  }\r\n\r\n  /**\r\n   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid\r\n   * @type {string}\r\n   */\r\n  get invalidExplanation() {\r\n    return this.invalid ? this.invalid.explanation : null;\r\n  }\r\n\r\n  /**\r\n   * Equality check\r\n   * Two Durations are equal iff they have the same units and the same values for each unit.\r\n   * @param {Duration} other\r\n   * @return {boolean}\r\n   */\r\n  equals(other) {\r\n    if (!this.isValid || !other.isValid) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.loc.equals(other.loc)) {\r\n      return false;\r\n    }\r\n\r\n    for (const u of orderedUnits) {\r\n      if (this.values[u] !== other.values[u]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function friendlyDuration(durationish) {\r\n  if (isNumber(durationish)) {\r\n    return Duration.fromMillis(durationish);\r\n  } else if (Duration.isDuration(durationish)) {\r\n    return durationish;\r\n  } else if (typeof durationish === \"object\") {\r\n    return Duration.fromObject(durationish);\r\n  } else {\r\n    throw new InvalidArgumentError(\r\n      `Unknown duration argument ${durationish} of type ${typeof durationish}`\r\n    );\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "/Users/isaac/code/luxon/src/duration.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 187,
    "kind": "variable",
    "name": "INVALID",
    "memberof": "src/duration.js",
    "static": true,
    "longname": "src/duration.js~INVALID",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/duration.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 188,
    "kind": "variable",
    "name": "lowOrderMatrix",
    "memberof": "src/duration.js",
    "static": true,
    "longname": "src/duration.js~lowOrderMatrix",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/duration.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "{\"weeks\": *, \"days\": *, \"hours\": *, \"minutes\": *, \"seconds\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 189,
    "kind": "variable",
    "name": "orderedUnits",
    "memberof": "src/duration.js",
    "static": true,
    "longname": "src/duration.js~orderedUnits",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/duration.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 190,
    "kind": "variable",
    "name": "reverseUnits",
    "memberof": "src/duration.js",
    "static": true,
    "longname": "src/duration.js~reverseUnits",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/duration.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 107,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 191,
    "kind": "function",
    "name": "clone",
    "memberof": "src/duration.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/duration.js~clone",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/duration.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 110,
    "undocument": true,
    "params": [
      {
        "name": "dur",
        "types": [
          "*"
        ]
      },
      {
        "name": "alts",
        "types": [
          "*"
        ]
      },
      {
        "name": "clear",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": false,
        "defaultValue": "false"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 192,
    "kind": "function",
    "name": "antiTrunc",
    "memberof": "src/duration.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/duration.js~antiTrunc",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/duration.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "params": [
      {
        "name": "n",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 193,
    "kind": "function",
    "name": "convert",
    "memberof": "src/duration.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/duration.js~convert",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/duration.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 125,
    "undocument": true,
    "params": [
      {
        "name": "matrix",
        "types": [
          "*"
        ]
      },
      {
        "name": "fromMap",
        "types": [
          "*"
        ]
      },
      {
        "name": "fromUnit",
        "types": [
          "*"
        ]
      },
      {
        "name": "toMap",
        "types": [
          "*"
        ]
      },
      {
        "name": "toUnit",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 194,
    "kind": "function",
    "name": "normalizeValues",
    "memberof": "src/duration.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/duration.js~normalizeValues",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/duration.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 137,
    "undocument": true,
    "params": [
      {
        "name": "matrix",
        "types": [
          "*"
        ]
      },
      {
        "name": "vals",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 195,
    "kind": "class",
    "name": "Duration",
    "memberof": "src/duration.js",
    "static": true,
    "longname": "src/duration.js~Duration",
    "access": "public",
    "export": true,
    "importPath": "luxon/src/duration.js",
    "importStyle": "Duration",
    "description": "A Duration object represents a period of time, like \"2 months\" or \"1 day, 1 hour\". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime.plus} to add a Duration object to a DateTime, producing another DateTime.\n\nHere is a brief overview of commonly used methods and getters in Duration:\n\n* **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.\n* **Unit values** See the {@link Duration.years}, {@link Duration.months}, {@link Duration.weeks}, {@link Duration.days}, {@link Duration.hours}, {@link Duration.minutes}, {@link Duration.seconds}, {@link Duration.milliseconds} accessors.\n* **Configuration** See  {@link Duration.locale} and {@link Duration.numberingSystem} accessors.\n* **Transformation** To create new Durations out of old ones use {@link Duration.plus}, {@link Duration.minus}, {@link Duration.normalize}, {@link Duration.set}, {@link Duration.reconfigure}, {@link Duration.shiftTo}, and {@link Duration.negate}.\n* **Output** To convert the Duration into other representations, see {@link Duration.as}, {@link Duration.toISO}, {@link Duration.toFormat}, and {@link Duration.toJSON}\n\nThere's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.",
    "lineNumber": 163,
    "interface": false
  },
  {
    "__docId__": 196,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 167,
    "ignore": true
  },
  {
    "__docId__": 197,
    "kind": "member",
    "name": "values",
    "memberof": "src/duration.js~Duration",
    "static": false,
    "longname": "src/duration.js~Duration#values",
    "access": "private",
    "description": "",
    "lineNumber": 172,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "member",
    "name": "loc",
    "memberof": "src/duration.js~Duration",
    "static": false,
    "longname": "src/duration.js~Duration#loc",
    "access": "private",
    "description": "",
    "lineNumber": 176,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "member",
    "name": "conversionAccuracy",
    "memberof": "src/duration.js~Duration",
    "static": false,
    "longname": "src/duration.js~Duration#conversionAccuracy",
    "access": "private",
    "description": "",
    "lineNumber": 180,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "member",
    "name": "invalid",
    "memberof": "src/duration.js~Duration",
    "static": false,
    "longname": "src/duration.js~Duration#invalid",
    "access": "private",
    "description": "",
    "lineNumber": 184,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 201,
    "kind": "member",
    "name": "matrix",
    "memberof": "src/duration.js~Duration",
    "static": false,
    "longname": "src/duration.js~Duration#matrix",
    "access": "private",
    "description": "",
    "lineNumber": 188,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 202,
    "kind": "member",
    "name": "isLuxonDuration",
    "memberof": "src/duration.js~Duration",
    "static": false,
    "longname": "src/duration.js~Duration#isLuxonDuration",
    "access": "private",
    "description": "",
    "lineNumber": 192,
    "ignore": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 203,
    "kind": "method",
    "name": "fromMillis",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/duration.js~Duration.fromMillis",
    "access": "public",
    "description": "Create Duration from a number of milliseconds.",
    "lineNumber": 204,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "count",
        "description": "of milliseconds"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options for parsing"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'en-US'",
        "defaultRaw": "'en-US'",
        "name": "opts.locale",
        "description": "the locale to use"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.numberingSystem",
        "description": "the numbering system to use"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'casual'",
        "defaultRaw": "'casual'",
        "name": "opts.conversionAccuracy",
        "description": "the conversion system to use"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 204,
    "kind": "method",
    "name": "fromObject",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/duration.js~Duration.fromObject",
    "access": "public",
    "description": "Create a Duration from a Javascript object with keys like 'years' and 'hours.\nIf this object is empty then a zero milliseconds duration is returned.",
    "lineNumber": 226,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the object to create the DateTime from"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.years",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.quarters",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.months",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.weeks",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.days",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.hours",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.minutes",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.seconds",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.milliseconds",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'en-US'",
        "defaultRaw": "'en-US'",
        "name": "obj.locale",
        "description": "the locale to use"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "obj.numberingSystem",
        "description": "the numbering system to use"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'casual'",
        "defaultRaw": "'casual'",
        "name": "obj.conversionAccuracy",
        "description": "the conversion system to use"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 205,
    "kind": "method",
    "name": "fromISO",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/duration.js~Duration.fromISO",
    "access": "public",
    "description": "Create a Duration from an ISO 8601 duration string.",
    "examples": [
      "Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }",
      "Duration.fromISO('PT23H').toObject() //=> { hours: 23 }",
      "Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }"
    ],
    "see": [
      "https://en.wikipedia.org/wiki/ISO_8601#Durations"
    ],
    "lineNumber": 256,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "text to parse"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options for parsing"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'en-US'",
        "defaultRaw": "'en-US'",
        "name": "opts.locale",
        "description": "the locale to use"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.numberingSystem",
        "description": "the numbering system to use"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'casual'",
        "defaultRaw": "'casual'",
        "name": "opts.conversionAccuracy",
        "description": "the conversion system to use"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "invalid",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/duration.js~Duration.invalid",
    "access": "public",
    "description": "Create an invalid Duration.",
    "lineNumber": 272,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "reason",
        "description": "simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "explanation",
        "description": "longer explanation, may include parameters and other useful debugging information"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 207,
    "kind": "method",
    "name": "normalizeUnit",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/duration.js~Duration.normalizeUnit",
    "access": "private",
    "description": "",
    "lineNumber": 289,
    "ignore": true,
    "params": [
      {
        "name": "unit",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "method",
    "name": "isDuration",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/duration.js~Duration.isDuration",
    "access": "public",
    "description": "Check if an object is a Duration. Works across context boundaries",
    "lineNumber": 321,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "o",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 209,
    "kind": "get",
    "name": "locale",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#locale",
    "access": "public",
    "description": "Get  the locale of a Duration, such 'en-GB'",
    "lineNumber": 329,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 210,
    "kind": "get",
    "name": "numberingSystem",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#numberingSystem",
    "access": "public",
    "description": "Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration",
    "lineNumber": 338,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "toFormat",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#toFormat",
    "access": "public",
    "description": "Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:\n* `S` for milliseconds\n* `s` for seconds\n* `m` for minutes\n* `h` for hours\n* `d` for days\n* `M` for months\n* `y` for years\nNotes:\n* Add padding by repeating the token, e.g. \"yy\" pads the years to two digits, \"hhhh\" pads the hours out to four digits\n* The duration will be converted to the set of units in the format string using {@link Duration.shiftTo} and the Durations's conversion accuracy setting.",
    "examples": [
      "Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"y d s\") //=> \"1 6 2\"",
      "Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"yy dd sss\") //=> \"01 06 002\"",
      "Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"M S\") //=> \"12 518402000\""
    ],
    "lineNumber": 362,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "fmt",
        "description": "the format string"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "opts.floor",
        "description": "floor numerical values"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "toObject",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#toObject",
    "access": "public",
    "description": "Returns a Javascript object with this Duration's values.",
    "examples": [
      "Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }"
    ],
    "lineNumber": 379,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options for generating the object"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "opts.includeConfig",
        "description": "include configuration attributes in the output"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "toISO",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#toISO",
    "access": "public",
    "description": "Returns an ISO 8601-compliant string representation of this Duration.",
    "examples": [
      "Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'",
      "Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'",
      "Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'",
      "Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'",
      "Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'"
    ],
    "see": [
      "https://en.wikipedia.org/wiki/ISO_8601#Durations"
    ],
    "lineNumber": 402,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 214,
    "kind": "method",
    "name": "toJSON",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#toJSON",
    "access": "public",
    "description": "Returns an ISO 8601 representation of this Duration appropriate for use in JSON.",
    "lineNumber": 425,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "toString",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#toString",
    "access": "public",
    "description": "Returns an ISO 8601 representation of this Duration appropriate for use in debugging.",
    "lineNumber": 433,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "valueOf",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#valueOf",
    "access": "public",
    "description": "Returns an milliseconds value of this Duration.",
    "lineNumber": 441,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 217,
    "kind": "method",
    "name": "plus",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#plus",
    "access": "public",
    "description": "Make this Duration longer by the specified amount. Return a newly-constructed Duration.",
    "lineNumber": 450,
    "params": [
      {
        "nullable": null,
        "types": [
          "Duration",
          "Object",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "duration",
        "description": "The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 218,
    "kind": "method",
    "name": "minus",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#minus",
    "access": "public",
    "description": "Make this Duration shorter by the specified amount. Return a newly-constructed Duration.",
    "lineNumber": 470,
    "params": [
      {
        "nullable": null,
        "types": [
          "Duration",
          "Object",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "duration",
        "description": "The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 219,
    "kind": "method",
    "name": "get",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#get",
    "access": "public",
    "description": "Get the value of unit.",
    "examples": [
      "Duration.fromObject({years: 2, days: 3}).years //=> 2",
      "Duration.fromObject({years: 2, days: 3}).months //=> 0",
      "Duration.fromObject({years: 2, days: 3}).days //=> 3"
    ],
    "lineNumber": 485,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "a unit such as 'minute' or 'day'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 220,
    "kind": "method",
    "name": "set",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#set",
    "access": "public",
    "description": "\"Set\" the values of specified units. Return a newly-constructed Duration.",
    "examples": [
      "dur.set({ years: 2017 })",
      "dur.set({ hours: 8, minutes: 30 })"
    ],
    "lineNumber": 496,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "a mapping of units to numbers"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 221,
    "kind": "method",
    "name": "reconfigure",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#reconfigure",
    "access": "public",
    "description": "\"Set\" the locale and/or numberingSystem.  Returns a newly-constructed Duration.",
    "examples": [
      "dur.reconfigure({ locale: 'en-GB' })"
    ],
    "lineNumber": 508,
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    },
    "params": [
      {
        "name": "objectPattern",
        "optional": true,
        "types": [
          "{\"locale\": *, \"numberingSystem\": *, \"conversionAccuracy\": *}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ]
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "as",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#as",
    "access": "public",
    "description": "Return the length of the duration in the specified unit.",
    "examples": [
      "Duration.fromObject({years: 1}).as('days') //=> 365",
      "Duration.fromObject({years: 1}).as('months') //=> 12",
      "Duration.fromObject({hours: 60}).as('days') //=> 2.5"
    ],
    "lineNumber": 527,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "a unit such as 'minutes' or 'days'"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "normalize",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#normalize",
    "access": "public",
    "description": "Reduce this Duration to its canonical representation in its current units.",
    "examples": [
      "Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }",
      "Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }"
    ],
    "lineNumber": 537,
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "shiftTo",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#shiftTo",
    "access": "public",
    "description": "Convert this Duration into its representation in a different set of units.",
    "examples": [
      "Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }"
    ],
    "lineNumber": 549,
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    },
    "params": [
      {
        "name": "units",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ]
  },
  {
    "__docId__": 225,
    "kind": "method",
    "name": "negate",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#negate",
    "access": "public",
    "description": "Return the negative of this Duration.",
    "examples": [
      "Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }"
    ],
    "lineNumber": 615,
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 226,
    "kind": "get",
    "name": "years",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#years",
    "access": "public",
    "description": "Get the years.",
    "lineNumber": 628,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 227,
    "kind": "get",
    "name": "quarters",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#quarters",
    "access": "public",
    "description": "Get the quarters.",
    "lineNumber": 636,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 228,
    "kind": "get",
    "name": "months",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#months",
    "access": "public",
    "description": "Get the months.",
    "lineNumber": 644,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 229,
    "kind": "get",
    "name": "weeks",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#weeks",
    "access": "public",
    "description": "Get the weeks",
    "lineNumber": 652,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 230,
    "kind": "get",
    "name": "days",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#days",
    "access": "public",
    "description": "Get the days.",
    "lineNumber": 660,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 231,
    "kind": "get",
    "name": "hours",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#hours",
    "access": "public",
    "description": "Get the hours.",
    "lineNumber": 668,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 232,
    "kind": "get",
    "name": "minutes",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#minutes",
    "access": "public",
    "description": "Get the minutes.",
    "lineNumber": 676,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 233,
    "kind": "get",
    "name": "seconds",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#seconds",
    "access": "public",
    "description": "Get the seconds.",
    "lineNumber": 684,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 234,
    "kind": "get",
    "name": "milliseconds",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#milliseconds",
    "access": "public",
    "description": "Get the milliseconds.",
    "lineNumber": 692,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 235,
    "kind": "get",
    "name": "isValid",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#isValid",
    "access": "public",
    "description": "Returns whether the Duration is invalid. Invalid durations are returned by diff operations\non invalid DateTimes or Intervals.",
    "lineNumber": 701,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 236,
    "kind": "get",
    "name": "invalidReason",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#invalidReason",
    "access": "public",
    "description": "Returns an error code if this Duration became invalid, or null if the Duration is valid",
    "lineNumber": 709,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 237,
    "kind": "get",
    "name": "invalidExplanation",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#invalidExplanation",
    "access": "public",
    "description": "Returns an explanation of why this Duration became invalid, or null if the Duration is valid",
    "lineNumber": 717,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 238,
    "kind": "method",
    "name": "equals",
    "memberof": "src/duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/duration.js~Duration#equals",
    "access": "public",
    "description": "Equality check\nTwo Durations are equal iff they have the same units and the same values for each unit.",
    "lineNumber": 727,
    "params": [
      {
        "nullable": null,
        "types": [
          "Duration"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 239,
    "kind": "function",
    "name": "friendlyDuration",
    "memberof": "src/duration.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/duration.js~friendlyDuration",
    "access": "private",
    "export": true,
    "importPath": "luxon/src/duration.js",
    "importStyle": "{friendlyDuration}",
    "description": "",
    "lineNumber": 748,
    "ignore": true,
    "params": [
      {
        "name": "durationish",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 240,
    "kind": "file",
    "name": "src/errors.js",
    "content": "// these aren't really private, but nor are they really useful to document\r\n\r\n/**\r\n * @private\r\n */\r\nclass LuxonError extends Error {}\r\n\r\n/**\r\n * @private\r\n */\r\nexport class InvalidDateTimeError extends LuxonError {\r\n  constructor(reason) {\r\n    super(`Invalid DateTime: ${reason.toMessage()}`);\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport class InvalidIntervalError extends LuxonError {\r\n  constructor(reason) {\r\n    super(`Invalid Interval: ${reason.toMessage()}`);\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport class InvalidDurationError extends LuxonError {\r\n  constructor(reason) {\r\n    super(`Invalid Duration: ${reason.toMessage()}`);\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport class ConflictingSpecificationError extends LuxonError {}\r\n\r\n/**\r\n * @private\r\n */\r\nexport class InvalidUnitError extends LuxonError {\r\n  constructor(unit) {\r\n    super(`Invalid unit ${unit}`);\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport class InvalidArgumentError extends LuxonError {}\r\n\r\n/**\r\n * @private\r\n */\r\nexport class ZoneIsAbstractError extends LuxonError {\r\n  constructor() {\r\n    super(\"Zone is an abstract class\");\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "/Users/isaac/code/luxon/src/errors.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 241,
    "kind": "class",
    "name": "LuxonError",
    "memberof": "src/errors.js",
    "static": true,
    "longname": "src/errors.js~LuxonError",
    "access": "private",
    "export": false,
    "importPath": "luxon/src/errors.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 6,
    "interface": false,
    "extends": [
      "Error"
    ],
    "ignore": true
  },
  {
    "__docId__": 242,
    "kind": "class",
    "name": "InvalidDateTimeError",
    "memberof": "src/errors.js",
    "static": true,
    "longname": "src/errors.js~InvalidDateTimeError",
    "access": "private",
    "export": true,
    "importPath": "luxon/src/errors.js",
    "importStyle": "{InvalidDateTimeError}",
    "description": "",
    "lineNumber": 11,
    "interface": false,
    "extends": [
      "LuxonError"
    ],
    "ignore": true
  },
  {
    "__docId__": 243,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/errors.js~InvalidDateTimeError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/errors.js~InvalidDateTimeError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true
  },
  {
    "__docId__": 244,
    "kind": "class",
    "name": "InvalidIntervalError",
    "memberof": "src/errors.js",
    "static": true,
    "longname": "src/errors.js~InvalidIntervalError",
    "access": "private",
    "export": true,
    "importPath": "luxon/src/errors.js",
    "importStyle": "{InvalidIntervalError}",
    "description": "",
    "lineNumber": 20,
    "interface": false,
    "extends": [
      "LuxonError"
    ],
    "ignore": true
  },
  {
    "__docId__": 245,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/errors.js~InvalidIntervalError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/errors.js~InvalidIntervalError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true
  },
  {
    "__docId__": 246,
    "kind": "class",
    "name": "InvalidDurationError",
    "memberof": "src/errors.js",
    "static": true,
    "longname": "src/errors.js~InvalidDurationError",
    "access": "private",
    "export": true,
    "importPath": "luxon/src/errors.js",
    "importStyle": "{InvalidDurationError}",
    "description": "",
    "lineNumber": 29,
    "interface": false,
    "extends": [
      "LuxonError"
    ],
    "ignore": true
  },
  {
    "__docId__": 247,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/errors.js~InvalidDurationError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/errors.js~InvalidDurationError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true
  },
  {
    "__docId__": 248,
    "kind": "class",
    "name": "ConflictingSpecificationError",
    "memberof": "src/errors.js",
    "static": true,
    "longname": "src/errors.js~ConflictingSpecificationError",
    "access": "private",
    "export": true,
    "importPath": "luxon/src/errors.js",
    "importStyle": "{ConflictingSpecificationError}",
    "description": "",
    "lineNumber": 38,
    "interface": false,
    "extends": [
      "LuxonError"
    ],
    "ignore": true
  },
  {
    "__docId__": 249,
    "kind": "class",
    "name": "InvalidUnitError",
    "memberof": "src/errors.js",
    "static": true,
    "longname": "src/errors.js~InvalidUnitError",
    "access": "private",
    "export": true,
    "importPath": "luxon/src/errors.js",
    "importStyle": "{InvalidUnitError}",
    "description": "",
    "lineNumber": 43,
    "interface": false,
    "extends": [
      "LuxonError"
    ],
    "ignore": true
  },
  {
    "__docId__": 250,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/errors.js~InvalidUnitError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/errors.js~InvalidUnitError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true
  },
  {
    "__docId__": 251,
    "kind": "class",
    "name": "InvalidArgumentError",
    "memberof": "src/errors.js",
    "static": true,
    "longname": "src/errors.js~InvalidArgumentError",
    "access": "private",
    "export": true,
    "importPath": "luxon/src/errors.js",
    "importStyle": "{InvalidArgumentError}",
    "description": "",
    "lineNumber": 52,
    "interface": false,
    "extends": [
      "LuxonError"
    ],
    "ignore": true
  },
  {
    "__docId__": 252,
    "kind": "class",
    "name": "ZoneIsAbstractError",
    "memberof": "src/errors.js",
    "static": true,
    "longname": "src/errors.js~ZoneIsAbstractError",
    "access": "private",
    "export": true,
    "importPath": "luxon/src/errors.js",
    "importStyle": "{ZoneIsAbstractError}",
    "description": "",
    "lineNumber": 57,
    "interface": false,
    "extends": [
      "LuxonError"
    ],
    "ignore": true
  },
  {
    "__docId__": 253,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/errors.js~ZoneIsAbstractError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/errors.js~ZoneIsAbstractError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true
  },
  {
    "__docId__": 254,
    "kind": "file",
    "name": "src/info.js",
    "content": "import DateTime from \"./datetime.js\";\r\nimport Settings from \"./settings.js\";\r\nimport Locale from \"./impl/locale.js\";\r\nimport IANAZone from \"./zones/IANAZone.js\";\r\nimport { normalizeZone } from \"./impl/zoneUtil.js\";\r\n\r\nimport { hasFormatToParts, hasIntl, hasRelative } from \"./impl/util.js\";\r\n\r\n/**\r\n * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.\r\n */\r\nexport default class Info {\r\n  /**\r\n   * Return whether the specified zone contains a DST.\r\n   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.\r\n   * @return {boolean}\r\n   */\r\n  static hasDST(zone = Settings.defaultZone) {\r\n    const proto = DateTime.local()\r\n      .setZone(zone)\r\n      .set({ month: 12 });\r\n\r\n    return !zone.universal && proto.offset !== proto.set({ month: 6 }).offset;\r\n  }\r\n\r\n  /**\r\n   * Return whether the specified zone is a valid IANA specifier.\r\n   * @param {string} zone - Zone to check\r\n   * @return {boolean}\r\n   */\r\n  static isValidIANAZone(zone) {\r\n    return !!IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);\r\n  }\r\n\r\n  /**\r\n   * Converts the input into a {@link Zone} instance.\r\n   *\r\n   * * If `input` is already a Zone instance, it is returned unchanged.\r\n   * * If `input` is a string containing a valid time zone name, a Zone instance\r\n   *   with that name is returned.\r\n   * * If `input` is a string that doesn't refer to a known time zone, a Zone\r\n   *   instance with {@link Zone.isValid} == false is returned.\r\n   * * If `input is a number, a Zone instance with the specified fixed offset\r\n   *   in minutes is returned.\r\n   * * If `input` is `null` or `undefined`, the default zone is returned.\r\n   * @param {string|Zone|number} [input] - the value to be converted\r\n   * @return {Zone}\r\n   */\r\n  static normalizeZone(input) {\r\n    return normalizeZone(input, Settings.defaultZone);\r\n  }\r\n\r\n  /**\r\n   * Return an array of standalone month names.\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\r\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\r\n   * @param {Object} opts - options\r\n   * @param {string} [opts.locale] - the locale code\r\n   * @param {string} [opts.numberingSystem=null] - the numbering system\r\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\r\n   * @example Info.months()[0] //=> 'January'\r\n   * @example Info.months('short')[0] //=> 'Jan'\r\n   * @example Info.months('numeric')[0] //=> '1'\r\n   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'\r\n   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''\r\n   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'\r\n   * @return {[string]}\r\n   */\r\n  static months(\r\n    length = \"long\",\r\n    { locale = null, numberingSystem = null, outputCalendar = \"gregory\" } = {}\r\n  ) {\r\n    return Locale.create(locale, numberingSystem, outputCalendar).months(length);\r\n  }\r\n\r\n  /**\r\n   * Return an array of format month names.\r\n   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that\r\n   * changes the string.\r\n   * See {@link months}\r\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\r\n   * @param {Object} opts - options\r\n   * @param {string} [opts.locale] - the locale code\r\n   * @param {string} [opts.numberingSystem=null] - the numbering system\r\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\r\n   * @return {[string]}\r\n   */\r\n  static monthsFormat(\r\n    length = \"long\",\r\n    { locale = null, numberingSystem = null, outputCalendar = \"gregory\" } = {}\r\n  ) {\r\n    return Locale.create(locale, numberingSystem, outputCalendar).months(length, true);\r\n  }\r\n\r\n  /**\r\n   * Return an array of standalone week names.\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\r\n   * @param {string} [length='long'] - the length of the month representation, such as \"narrow\", \"short\", \"long\".\r\n   * @param {Object} opts - options\r\n   * @param {string} [opts.locale] - the locale code\r\n   * @param {string} [opts.numberingSystem=null] - the numbering system\r\n   * @example Info.weekdays()[0] //=> 'Monday'\r\n   * @example Info.weekdays('short')[0] //=> 'Mon'\r\n   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'\r\n   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''\r\n   * @return {[string]}\r\n   */\r\n  static weekdays(length = \"long\", { locale = null, numberingSystem = null } = {}) {\r\n    return Locale.create(locale, numberingSystem, null).weekdays(length);\r\n  }\r\n\r\n  /**\r\n   * Return an array of format week names.\r\n   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that\r\n   * changes the string.\r\n   * See {@link weekdays}\r\n   * @param {string} [length='long'] - the length of the month representation, such as \"narrow\", \"short\", \"long\".\r\n   * @param {Object} opts - options\r\n   * @param {string} [opts.locale=null] - the locale code\r\n   * @param {string} [opts.numberingSystem=null] - the numbering system\r\n   * @return {[string]}\r\n   */\r\n  static weekdaysFormat(length = \"long\", { locale = null, numberingSystem = null } = {}) {\r\n    return Locale.create(locale, numberingSystem, null).weekdays(length, true);\r\n  }\r\n\r\n  /**\r\n   * Return an array of meridiems.\r\n   * @param {Object} opts - options\r\n   * @param {string} [opts.locale] - the locale code\r\n   * @example Info.meridiems() //=> [ 'AM', 'PM' ]\r\n   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]\r\n   * @return {[string]}\r\n   */\r\n  static meridiems({ locale = null } = {}) {\r\n    return Locale.create(locale).meridiems();\r\n  }\r\n\r\n  /**\r\n   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.\r\n   * @param {string} [length='short'] - the length of the era representation, such as \"short\" or \"long\".\r\n   * @param {Object} opts - options\r\n   * @param {string} [opts.locale] - the locale code\r\n   * @example Info.eras() //=> [ 'BC', 'AD' ]\r\n   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]\r\n   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]\r\n   * @return {[string]}\r\n   */\r\n  static eras(length = \"short\", { locale = null } = {}) {\r\n    return Locale.create(locale, null, \"gregory\").eras(length);\r\n  }\r\n\r\n  /**\r\n   * Return the set of available features in this environment.\r\n   * Some features of Luxon are not available in all environments. For example, on older browsers, timezone support is not available. Use this function to figure out if that's the case.\r\n   * Keys:\r\n   * * `zones`: whether this environment supports IANA timezones\r\n   * * `intlTokens`: whether this environment supports internationalized token-based formatting/parsing\r\n   * * `intl`: whether this environment supports general internationalization\r\n   * * `relative`: whether this environment supports relative time formatting\r\n   * @example Info.features() //=> { intl: true, intlTokens: false, zones: true, relative: false }\r\n   * @return {Object}\r\n   */\r\n  static features() {\r\n    let intl = false,\r\n      intlTokens = false,\r\n      zones = false,\r\n      relative = hasRelative();\r\n\r\n    if (hasIntl()) {\r\n      intl = true;\r\n      intlTokens = hasFormatToParts();\r\n\r\n      try {\r\n        zones =\r\n          new Intl.DateTimeFormat(\"en\", { timeZone: \"America/New_York\" }).resolvedOptions()\r\n            .timeZone === \"America/New_York\";\r\n      } catch (e) {\r\n        zones = false;\r\n      }\r\n    }\r\n\r\n    return { intl, intlTokens, zones, relative };\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "/Users/isaac/code/luxon/src/info.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 255,
    "kind": "class",
    "name": "Info",
    "memberof": "src/info.js",
    "static": true,
    "longname": "src/info.js~Info",
    "access": "public",
    "export": true,
    "importPath": "luxon/src/info.js",
    "importStyle": "Info",
    "description": "The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.",
    "lineNumber": 12,
    "interface": false
  },
  {
    "__docId__": 256,
    "kind": "method",
    "name": "hasDST",
    "memberof": "src/info.js~Info",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/info.js~Info.hasDST",
    "access": "public",
    "description": "Return whether the specified zone contains a DST.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Zone"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'local'",
        "defaultRaw": "'local'",
        "name": "zone",
        "description": "Zone to check. Defaults to the environment's local zone."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 257,
    "kind": "method",
    "name": "isValidIANAZone",
    "memberof": "src/info.js~Info",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/info.js~Info.isValidIANAZone",
    "access": "public",
    "description": "Return whether the specified zone is a valid IANA specifier.",
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "Zone to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 258,
    "kind": "method",
    "name": "normalizeZone",
    "memberof": "src/info.js~Info",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/info.js~Info.normalizeZone",
    "access": "public",
    "description": "Converts the input into a {@link Zone} instance.\n\n* If `input` is already a Zone instance, it is returned unchanged.\n* If `input` is a string containing a valid time zone name, a Zone instance\n  with that name is returned.\n* If `input` is a string that doesn't refer to a known time zone, a Zone\n  instance with {@link Zone.isValid} == false is returned.\n* If `input is a number, a Zone instance with the specified fixed offset\n  in minutes is returned.\n* If `input` is `null` or `undefined`, the default zone is returned.",
    "lineNumber": 49,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Zone",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "input",
        "description": "the value to be converted"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Zone"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 259,
    "kind": "method",
    "name": "months",
    "memberof": "src/info.js~Info",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/info.js~Info.months",
    "access": "public",
    "description": "Return an array of standalone month names.",
    "examples": [
      "Info.months()[0] //=> 'January'",
      "Info.months('short')[0] //=> 'Jan'",
      "Info.months('numeric')[0] //=> '1'",
      "Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'",
      "Info.months('numeric', { locale: 'ar' })[0] //=> ''",
      "Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'"
    ],
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat"
    ],
    "lineNumber": 69,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'long'",
        "defaultRaw": "'long'",
        "name": "length",
        "description": "the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.locale",
        "description": "the locale code"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "opts.numberingSystem",
        "description": "the numbering system"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'gregory'",
        "defaultRaw": "'gregory'",
        "name": "opts.outputCalendar",
        "description": "the calendar"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "[string]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 260,
    "kind": "method",
    "name": "monthsFormat",
    "memberof": "src/info.js~Info",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/info.js~Info.monthsFormat",
    "access": "public",
    "description": "Return an array of format month names.\nFormat months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that\nchanges the string.\nSee {@link months}",
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'long'",
        "defaultRaw": "'long'",
        "name": "length",
        "description": "the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.locale",
        "description": "the locale code"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "opts.numberingSystem",
        "description": "the numbering system"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'gregory'",
        "defaultRaw": "'gregory'",
        "name": "opts.outputCalendar",
        "description": "the calendar"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "[string]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 261,
    "kind": "method",
    "name": "weekdays",
    "memberof": "src/info.js~Info",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/info.js~Info.weekdays",
    "access": "public",
    "description": "Return an array of standalone week names.",
    "examples": [
      "Info.weekdays()[0] //=> 'Monday'",
      "Info.weekdays('short')[0] //=> 'Mon'",
      "Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'",
      "Info.weekdays('short', { locale: 'ar' })[0] //=> ''"
    ],
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat"
    ],
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'long'",
        "defaultRaw": "'long'",
        "name": "length",
        "description": "the length of the month representation, such as \"narrow\", \"short\", \"long\"."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.locale",
        "description": "the locale code"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "opts.numberingSystem",
        "description": "the numbering system"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "[string]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 262,
    "kind": "method",
    "name": "weekdaysFormat",
    "memberof": "src/info.js~Info",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/info.js~Info.weekdaysFormat",
    "access": "public",
    "description": "Return an array of format week names.\nFormat weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that\nchanges the string.\nSee {@link weekdays}",
    "lineNumber": 123,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'long'",
        "defaultRaw": "'long'",
        "name": "length",
        "description": "the length of the month representation, such as \"narrow\", \"short\", \"long\"."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "opts.locale",
        "description": "the locale code"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "opts.numberingSystem",
        "description": "the numbering system"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "[string]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 263,
    "kind": "method",
    "name": "meridiems",
    "memberof": "src/info.js~Info",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/info.js~Info.meridiems",
    "access": "public",
    "description": "Return an array of meridiems.",
    "examples": [
      "Info.meridiems() //=> [ 'AM', 'PM' ]",
      "Info.meridiems({ locale: 'my' }) //=> [ '', '' ]"
    ],
    "lineNumber": 135,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.locale",
        "description": "the locale code"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "[string]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 264,
    "kind": "method",
    "name": "eras",
    "memberof": "src/info.js~Info",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/info.js~Info.eras",
    "access": "public",
    "description": "Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.",
    "examples": [
      "Info.eras() //=> [ 'BC', 'AD' ]",
      "Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]",
      "Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]"
    ],
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'short'",
        "defaultRaw": "'short'",
        "name": "length",
        "description": "the length of the era representation, such as \"short\" or \"long\"."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.locale",
        "description": "the locale code"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "[string]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 265,
    "kind": "method",
    "name": "features",
    "memberof": "src/info.js~Info",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/info.js~Info.features",
    "access": "public",
    "description": "Return the set of available features in this environment.\nSome features of Luxon are not available in all environments. For example, on older browsers, timezone support is not available. Use this function to figure out if that's the case.\nKeys:\n* `zones`: whether this environment supports IANA timezones\n* `intlTokens`: whether this environment supports internationalized token-based formatting/parsing\n* `intl`: whether this environment supports general internationalization\n* `relative`: whether this environment supports relative time formatting",
    "examples": [
      "Info.features() //=> { intl: true, intlTokens: false, zones: true, relative: false }"
    ],
    "lineNumber": 164,
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 266,
    "kind": "file",
    "name": "src/interval.js",
    "content": "import DateTime, { friendlyDateTime } from \"./datetime.js\";\r\nimport Duration, { friendlyDuration } from \"./duration.js\";\r\nimport Settings from \"./settings.js\";\r\nimport { InvalidArgumentError, InvalidIntervalError } from \"./errors.js\";\r\nimport Invalid from \"./impl/invalid.js\";\r\n\r\nconst INVALID = \"Invalid Interval\";\r\n\r\n// checks if the start is equal to or before the end\r\nfunction validateStartEnd(start, end) {\r\n  if (!start || !start.isValid) {\r\n    return new Invalid(\"missing or invalid start\");\r\n  } else if (!end || !end.isValid) {\r\n    return new Invalid(\"missing or invalid end\");\r\n  } else if (end < start) {\r\n    return new Invalid(\r\n      \"end before start\",\r\n      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`\r\n    );\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.\r\n *\r\n * Here is a brief overview of the most commonly used methods and getters in Interval:\r\n *\r\n * * **Creation** To create an Interval, use {@link fromDateTimes}, {@link after}, {@link before}, or {@link fromISO}.\r\n * * **Accessors** Use {@link start} and {@link end} to get the start and end.\r\n * * **Interrogation** To analyze the Interval, use {@link count}, {@link length}, {@link hasSame}, {@link contains}, {@link isAfter}, or {@link isBefore}.\r\n * * **Transformation** To create other Intervals out of this one, use {@link set}, {@link splitAt}, {@link splitBy}, {@link divideEqually}, {@link merge}, {@link xor}, {@link union}, {@link intersection}, or {@link difference}.\r\n * * **Comparison** To compare this Interval to another one, use {@link equals}, {@link overlaps}, {@link abutsStart}, {@link abutsEnd}, {@link engulfs}\r\n * * **Output*** To convert the Interval into other representations, see {@link toString}, {@link toISO}, {@link toFormat}, and {@link toDuration}.\r\n */\r\nexport default class Interval {\r\n  /**\r\n   * @private\r\n   */\r\n  constructor(config) {\r\n    /**\r\n     * @access private\r\n     */\r\n    this.s = config.start;\r\n    /**\r\n     * @access private\r\n     */\r\n    this.e = config.end;\r\n    /**\r\n     * @access private\r\n     */\r\n    this.invalid = config.invalid || null;\r\n    /**\r\n     * @access private\r\n     */\r\n    this.isLuxonInterval = true;\r\n  }\r\n\r\n  /**\r\n   * Create an invalid Interval.\r\n   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent\r\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\r\n   * @return {Interval}\r\n   */\r\n  static invalid(reason, explanation = null) {\r\n    if (!reason) {\r\n      throw new InvalidArgumentError(\"need to specify a reason the Interval is invalid\");\r\n    }\r\n\r\n    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);\r\n\r\n    if (Settings.throwOnInvalid) {\r\n      throw new InvalidIntervalError(invalid);\r\n    } else {\r\n      return new Interval({ invalid });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.\r\n   * @param {DateTime|Date|Object} start\r\n   * @param {DateTime|Date|Object} end\r\n   * @return {Interval}\r\n   */\r\n  static fromDateTimes(start, end) {\r\n    const builtStart = friendlyDateTime(start),\r\n      builtEnd = friendlyDateTime(end);\r\n\r\n    return new Interval({\r\n      start: builtStart,\r\n      end: builtEnd,\r\n      invalid: validateStartEnd(builtStart, builtEnd)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create an Interval from a start DateTime and a Duration to extend to.\r\n   * @param {DateTime|Date|Object} start\r\n   * @param {Duration|Object|number} duration - the length of the Interval.\r\n   * @return {Interval}\r\n   */\r\n  static after(start, duration) {\r\n    const dur = friendlyDuration(duration),\r\n      dt = friendlyDateTime(start);\r\n    return Interval.fromDateTimes(dt, dt.plus(dur));\r\n  }\r\n\r\n  /**\r\n   * Create an Interval from an end DateTime and a Duration to extend backwards to.\r\n   * @param {DateTime|Date|Object} end\r\n   * @param {Duration|Object|number} duration - the length of the Interval.\r\n   * @return {Interval}\r\n   */\r\n  static before(end, duration) {\r\n    const dur = friendlyDuration(duration),\r\n      dt = friendlyDateTime(end);\r\n    return Interval.fromDateTimes(dt.minus(dur), dt);\r\n  }\r\n\r\n  /**\r\n   * Create an Interval from an ISO 8601 string.\r\n   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.\r\n   * @param {string} text - the ISO string to parse\r\n   * @param {Object} [opts] - options to pass {@link DateTime.fromISO} and optionally {@link Duration.fromISO}\r\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\r\n   * @return {Interval}\r\n   */\r\n  static fromISO(text, opts) {\r\n    const [s, e] = (text || \"\").split(\"/\", 2);\r\n    if (s && e) {\r\n      const start = DateTime.fromISO(s, opts),\r\n        end = DateTime.fromISO(e, opts);\r\n\r\n      if (start.isValid && end.isValid) {\r\n        return Interval.fromDateTimes(start, end);\r\n      }\r\n\r\n      if (start.isValid) {\r\n        const dur = Duration.fromISO(e, opts);\r\n        if (dur.isValid) {\r\n          return Interval.after(start, dur);\r\n        }\r\n      } else if (end.isValid) {\r\n        const dur = Duration.fromISO(s, opts);\r\n        if (dur.isValid) {\r\n          return Interval.before(end, dur);\r\n        }\r\n      }\r\n    }\r\n    return Interval.invalid(\"unparsable\", `the input \"${text}\" can't be parsed asISO 8601`);\r\n  }\r\n\r\n  /**\r\n   * Check if an object is an Interval. Works across context boundaries\r\n   * @param {object} o\r\n   * @return {boolean}\r\n   */\r\n  static isInterval(o) {\r\n    return (o && o.isLuxonInterval) || false;\r\n  }\r\n\r\n  /**\r\n   * Returns the start of the Interval\r\n   * @type {DateTime}\r\n   */\r\n  get start() {\r\n    return this.isValid ? this.s : null;\r\n  }\r\n\r\n  /**\r\n   * Returns the end of the Interval\r\n   * @type {DateTime}\r\n   */\r\n  get end() {\r\n    return this.isValid ? this.e : null;\r\n  }\r\n\r\n  /**\r\n   * Returns whether this Interval's end is at least its start, i.e. that the Interval isn't 'backwards'.\r\n   * @type {boolean}\r\n   */\r\n  get isValid() {\r\n    return this.invalidReason === null;\r\n  }\r\n\r\n  /**\r\n   * Returns an error code if this Interval is invalid, or null if the Interval is valid\r\n   * @type {string}\r\n   */\r\n  get invalidReason() {\r\n    return this.invalid ? this.invalid.reason : null;\r\n  }\r\n\r\n  /**\r\n   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid\r\n   * @type {string}\r\n   */\r\n  get invalidExplanation() {\r\n    return this.invalid ? this.invalid.explanation : null;\r\n  }\r\n\r\n  /**\r\n   * Returns the length of the Interval in the specified unit.\r\n   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.\r\n   * @return {number}\r\n   */\r\n  length(unit = \"milliseconds\") {\r\n    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;\r\n  }\r\n\r\n  /**\r\n   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.\r\n   * Unlike {@link length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'\r\n   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'\r\n   * @param {string} [unit='milliseconds'] - the unit of time to count.\r\n   * @return {number}\r\n   */\r\n  count(unit = \"milliseconds\") {\r\n    if (!this.isValid) return NaN;\r\n    const start = this.start.startOf(unit),\r\n      end = this.end.startOf(unit);\r\n    return Math.floor(end.diff(start, unit).get(unit)) + 1;\r\n  }\r\n\r\n  /**\r\n   * Returns whether this Interval's start and end are both in the same unit of time\r\n   * @param {string} unit - the unit of time to check sameness on\r\n   * @return {boolean}\r\n   */\r\n  hasSame(unit) {\r\n    return this.isValid ? this.e.minus(1).hasSame(this.s, unit) : false;\r\n  }\r\n\r\n  /**\r\n   * Return whether this Interval has the same start and end DateTimes.\r\n   * @return {boolean}\r\n   */\r\n  isEmpty() {\r\n    return this.s.valueOf() === this.e.valueOf();\r\n  }\r\n\r\n  /**\r\n   * Return whether this Interval's start is after the specified DateTime.\r\n   * @param {DateTime} dateTime\r\n   * @return {boolean}\r\n   */\r\n  isAfter(dateTime) {\r\n    if (!this.isValid) return false;\r\n    return this.s > dateTime;\r\n  }\r\n\r\n  /**\r\n   * Return whether this Interval's end is before the specified DateTime.\r\n   * @param {DateTime} dateTime\r\n   * @return {boolean}\r\n   */\r\n  isBefore(dateTime) {\r\n    if (!this.isValid) return false;\r\n    return this.e <= dateTime;\r\n  }\r\n\r\n  /**\r\n   * Return whether this Interval contains the specified DateTime.\r\n   * @param {DateTime} dateTime\r\n   * @return {boolean}\r\n   */\r\n  contains(dateTime) {\r\n    if (!this.isValid) return false;\r\n    return this.s <= dateTime && this.e > dateTime;\r\n  }\r\n\r\n  /**\r\n   * \"Sets\" the start and/or end dates. Returns a newly-constructed Interval.\r\n   * @param {Object} values - the values to set\r\n   * @param {DateTime} values.start - the starting DateTime\r\n   * @param {DateTime} values.end - the ending DateTime\r\n   * @return {Interval}\r\n   */\r\n  set({ start, end } = {}) {\r\n    if (!this.isValid) return this;\r\n    return Interval.fromDateTimes(start || this.s, end || this.e);\r\n  }\r\n\r\n  /**\r\n   * Split this Interval at each of the specified DateTimes\r\n   * @param {...[DateTime]} dateTimes - the unit of time to count.\r\n   * @return {[Interval]}\r\n   */\r\n  splitAt(...dateTimes) {\r\n    if (!this.isValid) return [];\r\n    const sorted = dateTimes.map(friendlyDateTime).sort(),\r\n      results = [];\r\n    let { s } = this,\r\n      i = 0;\r\n\r\n    while (s < this.e) {\r\n      const added = sorted[i] || this.e,\r\n        next = +added > +this.e ? this.e : added;\r\n      results.push(Interval.fromDateTimes(s, next));\r\n      s = next;\r\n      i += 1;\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Split this Interval into smaller Intervals, each of the specified length.\r\n   * Left over time is grouped into a smaller interval\r\n   * @param {Duration|Object|number} duration - The length of each resulting interval.\r\n   * @return {[Interval]}\r\n   */\r\n  splitBy(duration) {\r\n    const dur = friendlyDuration(duration);\r\n\r\n    if (!this.isValid || !dur.isValid || dur.as(\"milliseconds\") === 0) {\r\n      return [];\r\n    }\r\n\r\n    let { s } = this,\r\n      added,\r\n      next;\r\n\r\n    const results = [];\r\n    while (s < this.e) {\r\n      added = s.plus(dur);\r\n      next = +added > +this.e ? this.e : added;\r\n      results.push(Interval.fromDateTimes(s, next));\r\n      s = next;\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Split this Interval into the specified number of smaller intervals.\r\n   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.\r\n   * @return {[Interval]}\r\n   */\r\n  divideEqually(numberOfParts) {\r\n    if (!this.isValid) return [];\r\n    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);\r\n  }\r\n\r\n  /**\r\n   * Return whether this Interval overlaps with the specified Interval\r\n   * @param {Interval} other\r\n   * @return {boolean}\r\n   */\r\n  overlaps(other) {\r\n    return this.e > other.s && this.s < other.e;\r\n  }\r\n\r\n  /**\r\n   * Return whether this Interval's end is adjacent to the specified Interval's start.\r\n   * @param {Interval} other\r\n   * @return {boolean}\r\n   */\r\n  abutsStart(other) {\r\n    if (!this.isValid) return false;\r\n    return +this.e === +other.s;\r\n  }\r\n\r\n  /**\r\n   * Return whether this Interval's start is adjacent to the specified Interval's end.\r\n   * @param {Interval} other\r\n   * @return {boolean}\r\n   */\r\n  abutsEnd(other) {\r\n    if (!this.isValid) return false;\r\n    return +other.e === +this.s;\r\n  }\r\n\r\n  /**\r\n   * Return whether this Interval engulfs the start and end of the specified Interval.\r\n   * @param {Interval} other\r\n   * @return {boolean}\r\n   */\r\n  engulfs(other) {\r\n    if (!this.isValid) return false;\r\n    return this.s <= other.s && this.e >= other.e;\r\n  }\r\n\r\n  /**\r\n   * Return whether this Interval has the same start and end as the specified Interval.\r\n   * @param {Interval} other\r\n   * @return {boolean}\r\n   */\r\n  equals(other) {\r\n    if (!this.isValid || !other.isValid) {\r\n      return false;\r\n    }\r\n\r\n    return this.s.equals(other.s) && this.e.equals(other.e);\r\n  }\r\n\r\n  /**\r\n   * Return an Interval representing the intersection of this Interval and the specified Interval.\r\n   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.\r\n   * Returns null if the intersection is empty, i.e., the intervals don't intersect.\r\n   * @param {Interval} other\r\n   * @return {Interval}\r\n   */\r\n  intersection(other) {\r\n    if (!this.isValid) return this;\r\n    const s = this.s > other.s ? this.s : other.s,\r\n      e = this.e < other.e ? this.e : other.e;\r\n\r\n    if (s > e) {\r\n      return null;\r\n    } else {\r\n      return Interval.fromDateTimes(s, e);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return an Interval representing the union of this Interval and the specified Interval.\r\n   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.\r\n   * @param {Interval} other\r\n   * @return {Interval}\r\n   */\r\n  union(other) {\r\n    if (!this.isValid) return this;\r\n    const s = this.s < other.s ? this.s : other.s,\r\n      e = this.e > other.e ? this.e : other.e;\r\n    return Interval.fromDateTimes(s, e);\r\n  }\r\n\r\n  /**\r\n   * Merge an array of Intervals into a equivalent minimal set of Intervals.\r\n   * Combines overlapping and adjacent Intervals.\r\n   * @param {[Interval]} intervals\r\n   * @return {[Interval]}\r\n   */\r\n  static merge(intervals) {\r\n    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(\r\n      ([sofar, current], item) => {\r\n        if (!current) {\r\n          return [sofar, item];\r\n        } else if (current.overlaps(item) || current.abutsStart(item)) {\r\n          return [sofar, current.union(item)];\r\n        } else {\r\n          return [sofar.concat([current]), item];\r\n        }\r\n      },\r\n      [[], null]\r\n    );\r\n    if (final) {\r\n      found.push(final);\r\n    }\r\n    return found;\r\n  }\r\n\r\n  /**\r\n   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.\r\n   * @param {[Interval]} intervals\r\n   * @return {[Interval]}\r\n   */\r\n  static xor(intervals) {\r\n    let start = null,\r\n      currentCount = 0;\r\n    const results = [],\r\n      ends = intervals.map(i => [{ time: i.s, type: \"s\" }, { time: i.e, type: \"e\" }]),\r\n      flattened = Array.prototype.concat(...ends),\r\n      arr = flattened.sort((a, b) => a.time - b.time);\r\n\r\n    for (const i of arr) {\r\n      currentCount += i.type === \"s\" ? 1 : -1;\r\n\r\n      if (currentCount === 1) {\r\n        start = i.time;\r\n      } else {\r\n        if (start && +start !== +i.time) {\r\n          results.push(Interval.fromDateTimes(start, i.time));\r\n        }\r\n\r\n        start = null;\r\n      }\r\n    }\r\n\r\n    return Interval.merge(results);\r\n  }\r\n\r\n  /**\r\n   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.\r\n   * @param {...Interval} intervals\r\n   * @return {[Interval]}\r\n   */\r\n  difference(...intervals) {\r\n    return Interval.xor([this].concat(intervals))\r\n      .map(i => this.intersection(i))\r\n      .filter(i => i && !i.isEmpty());\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of this Interval appropriate for debugging.\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    if (!this.isValid) return INVALID;\r\n    return `[${this.s.toISO()}  ${this.e.toISO()})`;\r\n  }\r\n\r\n  /**\r\n   * Returns an ISO 8601-compliant string representation of this Interval.\r\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\r\n   * @param {Object} opts - The same options as {@link DateTime.toISO}\r\n   * @return {string}\r\n   */\r\n  toISO(opts) {\r\n    if (!this.isValid) return INVALID;\r\n    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of this Interval formatted according to the specified format string.\r\n   * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime.toFormat} for details.\r\n   * @param {Object} opts - options\r\n   * @param {string} [opts.separator =  '  '] - a separator to place between the start and end representations\r\n   * @return {string}\r\n   */\r\n  toFormat(dateFormat, { separator = \"  \" } = {}) {\r\n    if (!this.isValid) return INVALID;\r\n    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;\r\n  }\r\n\r\n  /**\r\n   * Return a Duration representing the time spanned by this interval.\r\n   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.\r\n   * @param {Object} opts - options that affect the creation of the Duration\r\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\r\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }\r\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }\r\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }\r\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }\r\n   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }\r\n   * @return {Duration}\r\n   */\r\n  toDuration(unit, opts) {\r\n    if (!this.isValid) {\r\n      return Duration.invalid(this.invalidReason);\r\n    }\r\n    return this.e.diff(this.s, unit, opts);\r\n  }\r\n\r\n  /**\r\n   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes\r\n   * @param {function} mapFn\r\n   * @return {Interval}\r\n   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())\r\n   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))\r\n   */\r\n  mapEndpoints(mapFn) {\r\n    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "/Users/isaac/code/luxon/src/interval.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 267,
    "kind": "variable",
    "name": "INVALID",
    "memberof": "src/interval.js",
    "static": true,
    "longname": "src/interval.js~INVALID",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/interval.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 268,
    "kind": "function",
    "name": "validateStartEnd",
    "memberof": "src/interval.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/interval.js~validateStartEnd",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/interval.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 269,
    "kind": "class",
    "name": "Interval",
    "memberof": "src/interval.js",
    "static": true,
    "longname": "src/interval.js~Interval",
    "access": "public",
    "export": true,
    "importPath": "luxon/src/interval.js",
    "importStyle": "Interval",
    "description": "An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.\n\nHere is a brief overview of the most commonly used methods and getters in Interval:\n\n* **Creation** To create an Interval, use {@link fromDateTimes}, {@link after}, {@link before}, or {@link fromISO}.\n* **Accessors** Use {@link start} and {@link end} to get the start and end.\n* **Interrogation** To analyze the Interval, use {@link count}, {@link length}, {@link hasSame}, {@link contains}, {@link isAfter}, or {@link isBefore}.\n* **Transformation** To create other Intervals out of this one, use {@link set}, {@link splitAt}, {@link splitBy}, {@link divideEqually}, {@link merge}, {@link xor}, {@link union}, {@link intersection}, or {@link difference}.\n* **Comparison** To compare this Interval to another one, use {@link equals}, {@link overlaps}, {@link abutsStart}, {@link abutsEnd}, {@link engulfs}\n* **Output*** To convert the Interval into other representations, see {@link toString}, {@link toISO}, {@link toFormat}, and {@link toDuration}.",
    "lineNumber": 37,
    "interface": false
  },
  {
    "__docId__": 270,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 41,
    "ignore": true
  },
  {
    "__docId__": 271,
    "kind": "member",
    "name": "s",
    "memberof": "src/interval.js~Interval",
    "static": false,
    "longname": "src/interval.js~Interval#s",
    "access": "private",
    "description": "",
    "lineNumber": 45,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 272,
    "kind": "member",
    "name": "e",
    "memberof": "src/interval.js~Interval",
    "static": false,
    "longname": "src/interval.js~Interval#e",
    "access": "private",
    "description": "",
    "lineNumber": 49,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 273,
    "kind": "member",
    "name": "invalid",
    "memberof": "src/interval.js~Interval",
    "static": false,
    "longname": "src/interval.js~Interval#invalid",
    "access": "private",
    "description": "",
    "lineNumber": 53,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 274,
    "kind": "member",
    "name": "isLuxonInterval",
    "memberof": "src/interval.js~Interval",
    "static": false,
    "longname": "src/interval.js~Interval#isLuxonInterval",
    "access": "private",
    "description": "",
    "lineNumber": 57,
    "ignore": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 275,
    "kind": "method",
    "name": "invalid",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/interval.js~Interval.invalid",
    "access": "public",
    "description": "Create an invalid Interval.",
    "lineNumber": 66,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "reason",
        "description": "simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "explanation",
        "description": "longer explanation, may include parameters and other useful debugging information"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 276,
    "kind": "method",
    "name": "fromDateTimes",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/interval.js~Interval.fromDateTimes",
    "access": "public",
    "description": "Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.",
    "lineNumber": 86,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTime",
          "Date",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "start",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "DateTime",
          "Date",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 277,
    "kind": "method",
    "name": "after",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/interval.js~Interval.after",
    "access": "public",
    "description": "Create an Interval from a start DateTime and a Duration to extend to.",
    "lineNumber": 103,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTime",
          "Date",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "start",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Duration",
          "Object",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "duration",
        "description": "the length of the Interval."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 278,
    "kind": "method",
    "name": "before",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/interval.js~Interval.before",
    "access": "public",
    "description": "Create an Interval from an end DateTime and a Duration to extend backwards to.",
    "lineNumber": 115,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTime",
          "Date",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Duration",
          "Object",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "duration",
        "description": "the length of the Interval."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 279,
    "kind": "method",
    "name": "fromISO",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/interval.js~Interval.fromISO",
    "access": "public",
    "description": "Create an Interval from an ISO 8601 string.\nAccepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.",
    "see": [
      "https://en.wikipedia.org/wiki/ISO_8601#Time_intervals"
    ],
    "lineNumber": 129,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the ISO string to parse"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "opts",
        "description": "options to pass {@link DateTime.fromISO} and optionally {@link Duration.fromISO}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 280,
    "kind": "method",
    "name": "isInterval",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/interval.js~Interval.isInterval",
    "access": "public",
    "description": "Check if an object is an Interval. Works across context boundaries",
    "lineNumber": 159,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "o",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 281,
    "kind": "get",
    "name": "start",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#start",
    "access": "public",
    "description": "Returns the start of the Interval",
    "lineNumber": 167,
    "type": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 282,
    "kind": "get",
    "name": "end",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#end",
    "access": "public",
    "description": "Returns the end of the Interval",
    "lineNumber": 175,
    "type": {
      "nullable": null,
      "types": [
        "DateTime"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 283,
    "kind": "get",
    "name": "isValid",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#isValid",
    "access": "public",
    "description": "Returns whether this Interval's end is at least its start, i.e. that the Interval isn't 'backwards'.",
    "lineNumber": 183,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 284,
    "kind": "get",
    "name": "invalidReason",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#invalidReason",
    "access": "public",
    "description": "Returns an error code if this Interval is invalid, or null if the Interval is valid",
    "lineNumber": 191,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 285,
    "kind": "get",
    "name": "invalidExplanation",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#invalidExplanation",
    "access": "public",
    "description": "Returns an explanation of why this Interval became invalid, or null if the Interval is valid",
    "lineNumber": 199,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 286,
    "kind": "method",
    "name": "length",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#length",
    "access": "public",
    "description": "Returns the length of the Interval in the specified unit.",
    "lineNumber": 208,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit (such as 'hours' or 'days') to return the length in."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 287,
    "kind": "method",
    "name": "count",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#count",
    "access": "public",
    "description": "Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.\nUnlike {@link length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'\nasks 'what dates are included in this interval?', not 'how many days long is this interval?'",
    "lineNumber": 219,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'milliseconds'",
        "defaultRaw": "'milliseconds'",
        "name": "unit",
        "description": "the unit of time to count."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 288,
    "kind": "method",
    "name": "hasSame",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#hasSame",
    "access": "public",
    "description": "Returns whether this Interval's start and end are both in the same unit of time",
    "lineNumber": 231,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of time to check sameness on"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 289,
    "kind": "method",
    "name": "isEmpty",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#isEmpty",
    "access": "public",
    "description": "Return whether this Interval has the same start and end DateTimes.",
    "lineNumber": 239,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 290,
    "kind": "method",
    "name": "isAfter",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#isAfter",
    "access": "public",
    "description": "Return whether this Interval's start is after the specified DateTime.",
    "lineNumber": 248,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "dateTime",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 291,
    "kind": "method",
    "name": "isBefore",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#isBefore",
    "access": "public",
    "description": "Return whether this Interval's end is before the specified DateTime.",
    "lineNumber": 258,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "dateTime",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 292,
    "kind": "method",
    "name": "contains",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#contains",
    "access": "public",
    "description": "Return whether this Interval contains the specified DateTime.",
    "lineNumber": 268,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "dateTime",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 293,
    "kind": "method",
    "name": "set",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#set",
    "access": "public",
    "description": "\"Sets\" the start and/or end dates. Returns a newly-constructed Interval.",
    "lineNumber": 280,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "the values to set"
      },
      {
        "nullable": null,
        "types": [
          "DateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "values.start",
        "description": "the starting DateTime"
      },
      {
        "nullable": null,
        "types": [
          "DateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "values.end",
        "description": "the ending DateTime"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 294,
    "kind": "method",
    "name": "splitAt",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#splitAt",
    "access": "public",
    "description": "Split this Interval at each of the specified DateTimes",
    "lineNumber": 290,
    "params": [
      {
        "nullable": null,
        "types": [
          "...[DateTime]"
        ],
        "spread": true,
        "optional": false,
        "name": "dateTimes",
        "description": "the unit of time to count."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "[Interval]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 295,
    "kind": "method",
    "name": "splitBy",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#splitBy",
    "access": "public",
    "description": "Split this Interval into smaller Intervals, each of the specified length.\nLeft over time is grouped into a smaller interval",
    "lineNumber": 314,
    "params": [
      {
        "nullable": null,
        "types": [
          "Duration",
          "Object",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "duration",
        "description": "The length of each resulting interval."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "[Interval]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 296,
    "kind": "method",
    "name": "divideEqually",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#divideEqually",
    "access": "public",
    "description": "Split this Interval into the specified number of smaller intervals.",
    "lineNumber": 341,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numberOfParts",
        "description": "The number of Intervals to divide the Interval into."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "[Interval]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 297,
    "kind": "method",
    "name": "overlaps",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#overlaps",
    "access": "public",
    "description": "Return whether this Interval overlaps with the specified Interval",
    "lineNumber": 351,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 298,
    "kind": "method",
    "name": "abutsStart",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#abutsStart",
    "access": "public",
    "description": "Return whether this Interval's end is adjacent to the specified Interval's start.",
    "lineNumber": 360,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 299,
    "kind": "method",
    "name": "abutsEnd",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#abutsEnd",
    "access": "public",
    "description": "Return whether this Interval's start is adjacent to the specified Interval's end.",
    "lineNumber": 370,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 300,
    "kind": "method",
    "name": "engulfs",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#engulfs",
    "access": "public",
    "description": "Return whether this Interval engulfs the start and end of the specified Interval.",
    "lineNumber": 380,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 301,
    "kind": "method",
    "name": "equals",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#equals",
    "access": "public",
    "description": "Return whether this Interval has the same start and end as the specified Interval.",
    "lineNumber": 390,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 302,
    "kind": "method",
    "name": "intersection",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#intersection",
    "access": "public",
    "description": "Return an Interval representing the intersection of this Interval and the specified Interval.\nSpecifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.\nReturns null if the intersection is empty, i.e., the intervals don't intersect.",
    "lineNumber": 405,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 303,
    "kind": "method",
    "name": "union",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#union",
    "access": "public",
    "description": "Return an Interval representing the union of this Interval and the specified Interval.\nSpecifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.",
    "lineNumber": 423,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 304,
    "kind": "method",
    "name": "merge",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/interval.js~Interval.merge",
    "access": "public",
    "description": "Merge an array of Intervals into a equivalent minimal set of Intervals.\nCombines overlapping and adjacent Intervals.",
    "lineNumber": 436,
    "params": [
      {
        "nullable": null,
        "types": [
          "[Interval]"
        ],
        "spread": false,
        "optional": false,
        "name": "intervals",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "[Interval]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 305,
    "kind": "method",
    "name": "xor",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/interval.js~Interval.xor",
    "access": "public",
    "description": "Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.",
    "lineNumber": 460,
    "params": [
      {
        "nullable": null,
        "types": [
          "[Interval]"
        ],
        "spread": false,
        "optional": false,
        "name": "intervals",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "[Interval]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 306,
    "kind": "method",
    "name": "difference",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#difference",
    "access": "public",
    "description": "Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.",
    "lineNumber": 490,
    "params": [
      {
        "nullable": null,
        "types": [
          "...Interval"
        ],
        "spread": true,
        "optional": false,
        "name": "intervals",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "[Interval]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 307,
    "kind": "method",
    "name": "toString",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#toString",
    "access": "public",
    "description": "Returns a string representation of this Interval appropriate for debugging.",
    "lineNumber": 500,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 308,
    "kind": "method",
    "name": "toISO",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#toISO",
    "access": "public",
    "description": "Returns an ISO 8601-compliant string representation of this Interval.",
    "see": [
      "https://en.wikipedia.org/wiki/ISO_8601#Time_intervals"
    ],
    "lineNumber": 511,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "The same options as {@link DateTime.toISO}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 309,
    "kind": "method",
    "name": "toFormat",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#toFormat",
    "access": "public",
    "description": "Returns a string representation of this Interval formatted according to the specified format string.",
    "lineNumber": 523,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dateFormat",
        "description": "the format string. This string formats the start and end time. See {@link DateTime.toFormat} for details."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "  '  '",
        "defaultRaw": "  '  '",
        "name": "opts.separator",
        "description": "a separator to place between the start and end representations"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 310,
    "kind": "method",
    "name": "toDuration",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#toDuration",
    "access": "public",
    "description": "Return a Duration representing the time spanned by this interval.",
    "examples": [
      "Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }",
      "Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }",
      "Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }",
      "Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }",
      "Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }"
    ],
    "lineNumber": 540,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "string[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "['milliseconds']",
        "defaultRaw": "['milliseconds']",
        "name": "unit",
        "description": "the unit or units (such as 'hours' or 'days') to include in the duration."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "options that affect the creation of the Duration"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'casual'",
        "defaultRaw": "'casual'",
        "name": "opts.conversionAccuracy",
        "description": "the conversion system to use"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 311,
    "kind": "method",
    "name": "mapEndpoints",
    "memberof": "src/interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/interval.js~Interval#mapEndpoints",
    "access": "public",
    "description": "Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes",
    "examples": [
      "Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())",
      "Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))"
    ],
    "lineNumber": 554,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "mapFn",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 312,
    "kind": "file",
    "name": "src/settings.js",
    "content": "import LocalZone from \"./zones/localZone.js\";\r\nimport IANAZone from \"./zones/IANAZone.js\";\r\nimport Locale from \"./impl/locale.js\";\r\n\r\nimport { normalizeZone } from \"./impl/zoneUtil.js\";\r\n\r\nlet now = () => Date.now(),\r\n  defaultZone = null, // not setting this directly to LocalZone.instance bc loading order issues\r\n  defaultLocale = null,\r\n  defaultNumberingSystem = null,\r\n  defaultOutputCalendar = null,\r\n  throwOnInvalid = false;\r\n\r\n/**\r\n * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.\r\n */\r\nexport default class Settings {\r\n  /**\r\n   * Get the callback for returning the current timestamp.\r\n   * @type {function}\r\n   */\r\n  static get now() {\r\n    return now;\r\n  }\r\n\r\n  /**\r\n   * Set the callback for returning the current timestamp.\r\n   * The function should return a number, which will be interpreted as an Epoch millisecond count\r\n   * @type {function}\r\n   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future\r\n   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time\r\n   */\r\n  static set now(n) {\r\n    now = n;\r\n  }\r\n\r\n  /**\r\n   * Get the default time zone to create DateTimes in.\r\n   * @type {string}\r\n   */\r\n  static get defaultZoneName() {\r\n    return Settings.defaultZone.name;\r\n  }\r\n\r\n  /**\r\n   * Set the default time zone to create DateTimes in. Does not affect existing instances.\r\n   * @type {string}\r\n   */\r\n  static set defaultZoneName(z) {\r\n    if (!z) {\r\n      defaultZone = null;\r\n    } else {\r\n      defaultZone = normalizeZone(z);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the default time zone object to create DateTimes in. Does not affect existing instances.\r\n   * @type {Zone}\r\n   */\r\n  static get defaultZone() {\r\n    return defaultZone || LocalZone.instance;\r\n  }\r\n\r\n  /**\r\n   * Get the default locale to create DateTimes with. Does not affect existing instances.\r\n   * @type {string}\r\n   */\r\n  static get defaultLocale() {\r\n    return defaultLocale;\r\n  }\r\n\r\n  /**\r\n   * Set the default locale to create DateTimes with. Does not affect existing instances.\r\n   * @type {string}\r\n   */\r\n  static set defaultLocale(locale) {\r\n    defaultLocale = locale;\r\n  }\r\n\r\n  /**\r\n   * Get the default numbering system to create DateTimes with. Does not affect existing instances.\r\n   * @type {string}\r\n   */\r\n  static get defaultNumberingSystem() {\r\n    return defaultNumberingSystem;\r\n  }\r\n\r\n  /**\r\n   * Set the default numbering system to create DateTimes with. Does not affect existing instances.\r\n   * @type {string}\r\n   */\r\n  static set defaultNumberingSystem(numberingSystem) {\r\n    defaultNumberingSystem = numberingSystem;\r\n  }\r\n\r\n  /**\r\n   * Get the default output calendar to create DateTimes with. Does not affect existing instances.\r\n   * @type {string}\r\n   */\r\n  static get defaultOutputCalendar() {\r\n    return defaultOutputCalendar;\r\n  }\r\n\r\n  /**\r\n   * Set the default output calendar to create DateTimes with. Does not affect existing instances.\r\n   * @type {string}\r\n   */\r\n  static set defaultOutputCalendar(outputCalendar) {\r\n    defaultOutputCalendar = outputCalendar;\r\n  }\r\n\r\n  /**\r\n   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\r\n   * @type {boolean}\r\n   */\r\n  static get throwOnInvalid() {\r\n    return throwOnInvalid;\r\n  }\r\n\r\n  /**\r\n   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\r\n   * @type {boolean}\r\n   */\r\n  static set throwOnInvalid(t) {\r\n    throwOnInvalid = t;\r\n  }\r\n\r\n  /**\r\n   * Reset Luxon's global caches. Should only be necessary in testing scenarios.\r\n   * @return {void}\r\n   */\r\n  static resetCaches() {\r\n    Locale.resetCache();\r\n    IANAZone.resetCache();\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "/Users/isaac/code/luxon/src/settings.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 313,
    "kind": "function",
    "name": "now",
    "memberof": "src/settings.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~now",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/settings.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 314,
    "kind": "class",
    "name": "Settings",
    "memberof": "src/settings.js",
    "static": true,
    "longname": "src/settings.js~Settings",
    "access": "public",
    "export": true,
    "importPath": "luxon/src/settings.js",
    "importStyle": "Settings",
    "description": "Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.",
    "lineNumber": 17,
    "interface": false
  },
  {
    "__docId__": 315,
    "kind": "get",
    "name": "now",
    "memberof": "src/settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~Settings.now",
    "access": "public",
    "description": "Get the callback for returning the current timestamp.",
    "lineNumber": 22,
    "type": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 316,
    "kind": "set",
    "name": "now",
    "memberof": "src/settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~Settings.now",
    "access": "public",
    "description": "Set the callback for returning the current timestamp.\nThe function should return a number, which will be interpreted as an Epoch millisecond count",
    "examples": [
      "Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future",
      "Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time"
    ],
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 317,
    "kind": "get",
    "name": "defaultZoneName",
    "memberof": "src/settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~Settings.defaultZoneName",
    "access": "public",
    "description": "Get the default time zone to create DateTimes in.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 318,
    "kind": "set",
    "name": "defaultZoneName",
    "memberof": "src/settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~Settings.defaultZoneName",
    "access": "public",
    "description": "Set the default time zone to create DateTimes in. Does not affect existing instances.",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 319,
    "kind": "get",
    "name": "defaultZone",
    "memberof": "src/settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~Settings.defaultZone",
    "access": "public",
    "description": "Get the default time zone object to create DateTimes in. Does not affect existing instances.",
    "lineNumber": 61,
    "type": {
      "nullable": null,
      "types": [
        "Zone"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 320,
    "kind": "get",
    "name": "defaultLocale",
    "memberof": "src/settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~Settings.defaultLocale",
    "access": "public",
    "description": "Get the default locale to create DateTimes with. Does not affect existing instances.",
    "lineNumber": 69,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 321,
    "kind": "set",
    "name": "defaultLocale",
    "memberof": "src/settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~Settings.defaultLocale",
    "access": "public",
    "description": "Set the default locale to create DateTimes with. Does not affect existing instances.",
    "lineNumber": 77,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 322,
    "kind": "get",
    "name": "defaultNumberingSystem",
    "memberof": "src/settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~Settings.defaultNumberingSystem",
    "access": "public",
    "description": "Get the default numbering system to create DateTimes with. Does not affect existing instances.",
    "lineNumber": 85,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 323,
    "kind": "set",
    "name": "defaultNumberingSystem",
    "memberof": "src/settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~Settings.defaultNumberingSystem",
    "access": "public",
    "description": "Set the default numbering system to create DateTimes with. Does not affect existing instances.",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 324,
    "kind": "get",
    "name": "defaultOutputCalendar",
    "memberof": "src/settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~Settings.defaultOutputCalendar",
    "access": "public",
    "description": "Get the default output calendar to create DateTimes with. Does not affect existing instances.",
    "lineNumber": 101,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 325,
    "kind": "set",
    "name": "defaultOutputCalendar",
    "memberof": "src/settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~Settings.defaultOutputCalendar",
    "access": "public",
    "description": "Set the default output calendar to create DateTimes with. Does not affect existing instances.",
    "lineNumber": 109,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 326,
    "kind": "get",
    "name": "throwOnInvalid",
    "memberof": "src/settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~Settings.throwOnInvalid",
    "access": "public",
    "description": "Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals",
    "lineNumber": 117,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 327,
    "kind": "set",
    "name": "throwOnInvalid",
    "memberof": "src/settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~Settings.throwOnInvalid",
    "access": "public",
    "description": "Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals",
    "lineNumber": 125,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 328,
    "kind": "method",
    "name": "resetCaches",
    "memberof": "src/settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/settings.js~Settings.resetCaches",
    "access": "public",
    "description": "Reset Luxon's global caches. Should only be necessary in testing scenarios.",
    "lineNumber": 133,
    "return": {
      "nullable": null,
      "types": [
        "void"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 329,
    "kind": "file",
    "name": "src/zone.js",
    "content": "/* eslint no-unused-vars: \"off\" */\r\nimport { ZoneIsAbstractError } from \"./errors.js\";\r\n\r\n/**\r\n * @interface\r\n */\r\nexport default class Zone {\r\n  /**\r\n   * The type of zone\r\n   * @abstract\r\n   * @type {string}\r\n   */\r\n  get type() {\r\n    throw new ZoneIsAbstractError();\r\n  }\r\n\r\n  /**\r\n   * The name of this zone.\r\n   * @abstract\r\n   * @type {string}\r\n   */\r\n  get name() {\r\n    throw new ZoneIsAbstractError();\r\n  }\r\n\r\n  /**\r\n   * Returns whether the offset is known to be fixed for the whole year.\r\n   * @abstract\r\n   * @type {boolean}\r\n   */\r\n  get universal() {\r\n    throw new ZoneIsAbstractError();\r\n  }\r\n\r\n  /**\r\n   * Returns the offset's common name (such as EST) at the specified timestamp\r\n   * @abstract\r\n   * @param {number} ts - Epoch milliseconds for which to get the name\r\n   * @param {Object} opts - Options to affect the format\r\n   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.\r\n   * @param {string} opts.locale - What locale to return the offset name in.\r\n   * @return {string}\r\n   */\r\n  offsetName(ts, opts) {\r\n    throw new ZoneIsAbstractError();\r\n  }\r\n\r\n  /**\r\n   * Return the offset in minutes for this zone at the specified timestamp.\r\n   * @abstract\r\n   * @param {number} ts - Epoch milliseconds for which to compute the offset\r\n   * @return {number}\r\n   */\r\n  offset(ts) {\r\n    throw new ZoneIsAbstractError();\r\n  }\r\n\r\n  /**\r\n   * Return whether this Zone is equal to another zone\r\n   * @abstract\r\n   * @param {Zone} otherZone - the zone to compare\r\n   * @return {boolean}\r\n   */\r\n  equals(otherZone) {\r\n    throw new ZoneIsAbstractError();\r\n  }\r\n\r\n  /**\r\n   * Return whether this Zone is valid.\r\n   * @abstract\r\n   * @type {boolean}\r\n   */\r\n  get isValid() {\r\n    throw new ZoneIsAbstractError();\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "/Users/isaac/code/luxon/src/zone.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 330,
    "kind": "class",
    "name": "Zone",
    "memberof": "src/zone.js",
    "static": true,
    "longname": "src/zone.js~Zone",
    "access": "public",
    "export": true,
    "importPath": "luxon/src/zone.js",
    "importStyle": "Zone",
    "description": "",
    "lineNumber": 7,
    "interface": true
  },
  {
    "__docId__": 331,
    "kind": "get",
    "name": "type",
    "memberof": "src/zone.js~Zone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zone.js~Zone#type",
    "access": "public",
    "description": "The type of zone",
    "lineNumber": 13,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "abstract": true
  },
  {
    "__docId__": 332,
    "kind": "get",
    "name": "name",
    "memberof": "src/zone.js~Zone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zone.js~Zone#name",
    "access": "public",
    "description": "The name of this zone.",
    "lineNumber": 22,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "abstract": true
  },
  {
    "__docId__": 333,
    "kind": "get",
    "name": "universal",
    "memberof": "src/zone.js~Zone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zone.js~Zone#universal",
    "access": "public",
    "description": "Returns whether the offset is known to be fixed for the whole year.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    },
    "abstract": true
  },
  {
    "__docId__": 334,
    "kind": "method",
    "name": "offsetName",
    "memberof": "src/zone.js~Zone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zone.js~Zone#offsetName",
    "access": "public",
    "description": "Returns the offset's common name (such as EST) at the specified timestamp",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ts",
        "description": "Epoch milliseconds for which to get the name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "Options to affect the format"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.format",
        "description": "What style of offset to return. Accepts 'long' or 'short'."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.locale",
        "description": "What locale to return the offset name in."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "abstract": true
  },
  {
    "__docId__": 335,
    "kind": "method",
    "name": "offset",
    "memberof": "src/zone.js~Zone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zone.js~Zone#offset",
    "access": "public",
    "description": "Return the offset in minutes for this zone at the specified timestamp.",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ts",
        "description": "Epoch milliseconds for which to compute the offset"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "abstract": true
  },
  {
    "__docId__": 336,
    "kind": "method",
    "name": "equals",
    "memberof": "src/zone.js~Zone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zone.js~Zone#equals",
    "access": "public",
    "description": "Return whether this Zone is equal to another zone",
    "lineNumber": 64,
    "params": [
      {
        "nullable": null,
        "types": [
          "Zone"
        ],
        "spread": false,
        "optional": false,
        "name": "otherZone",
        "description": "the zone to compare"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "abstract": true
  },
  {
    "__docId__": 337,
    "kind": "get",
    "name": "isValid",
    "memberof": "src/zone.js~Zone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zone.js~Zone#isValid",
    "access": "public",
    "description": "Return whether this Zone is valid.",
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    },
    "abstract": true
  },
  {
    "__docId__": 338,
    "kind": "file",
    "name": "src/zones/IANAZone.js",
    "content": "import { parseZoneInfo, isUndefined, ianaRegex, objToLocalTS } from \"../impl/util.js\";\r\nimport Zone from \"../zone.js\";\r\n\r\nconst matchingRegex = RegExp(`^${ianaRegex.source}$`);\r\n\r\nlet dtfCache = {};\r\nfunction makeDTF(zone) {\r\n  if (!dtfCache[zone]) {\r\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\r\n      hour12: false,\r\n      timeZone: zone,\r\n      year: \"numeric\",\r\n      month: \"2-digit\",\r\n      day: \"2-digit\",\r\n      hour: \"2-digit\",\r\n      minute: \"2-digit\",\r\n      second: \"2-digit\"\r\n    });\r\n  }\r\n  return dtfCache[zone];\r\n}\r\n\r\nconst typeToPos = {\r\n  year: 0,\r\n  month: 1,\r\n  day: 2,\r\n  hour: 3,\r\n  minute: 4,\r\n  second: 5\r\n};\r\n\r\nfunction hackyOffset(dtf, date) {\r\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\r\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\r\n    [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed;\r\n  return [fYear, fMonth, fDay, fHour, fMinute, fSecond];\r\n}\r\n\r\nfunction partsOffset(dtf, date) {\r\n  const formatted = dtf.formatToParts(date),\r\n    filled = [];\r\n  for (let i = 0; i < formatted.length; i++) {\r\n    const { type, value } = formatted[i],\r\n      pos = typeToPos[type];\r\n\r\n    if (!isUndefined(pos)) {\r\n      filled[pos] = parseInt(value, 10);\r\n    }\r\n  }\r\n  return filled;\r\n}\r\n\r\nlet ianaZoneCache = {};\r\n/**\r\n * A zone identified by an IANA identifier, like America/New_York\r\n * @implements {Zone}\r\n */\r\nexport default class IANAZone extends Zone {\r\n  /**\r\n   * @param {string} name - Zone name\r\n   * @return {IANAZone}\r\n   */\r\n  static create(name) {\r\n    if (!ianaZoneCache[name]) {\r\n      ianaZoneCache[name] = new IANAZone(name);\r\n    }\r\n    return ianaZoneCache[name];\r\n  }\r\n  /**\r\n   * Reset local caches. Should only be necessary in testing scenarios.\r\n   * @return {void}\r\n   */\r\n  static resetCache() {\r\n    ianaZoneCache = {};\r\n    dtfCache = {};\r\n  }\r\n  /**\r\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\r\n   * @param {string} s - The string to check validity on\r\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\r\n   * @example IANAZone.isValidSpecifier(\"Fantasia/Castle\") //=> true\r\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\r\n   * @return {boolean}\r\n   */\r\n  static isValidSpecifier(s) {\r\n    return s && s.match(matchingRegex);\r\n  }\r\n\r\n  /**\r\n   * Returns whether the provided string identifies a real zone\r\n   * @param {string} zone - The string to check\r\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\r\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\r\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\r\n   * @return {boolean}\r\n   */\r\n  static isValidZone(zone) {\r\n    try {\r\n      new Intl.DateTimeFormat(\"en-US\", { timeZone: zone }).format();\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Etc/GMT+8 -> -480\r\n  /** @ignore */\r\n  static parseGMTOffset(specifier) {\r\n    if (specifier) {\r\n      const match = specifier.match(/^Etc\\/GMT([+-]\\d{1,2})$/i);\r\n      if (match) {\r\n        return -60 * parseInt(match[1]);\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  constructor(name) {\r\n    super();\r\n    /** @private **/\r\n    this.zoneName = name;\r\n    /** @private **/\r\n    this.valid = IANAZone.isValidZone(name);\r\n  }\r\n\r\n  /** @override **/\r\n  get type() {\r\n    return \"iana\";\r\n  }\r\n\r\n  /** @override **/\r\n  get name() {\r\n    return this.zoneName;\r\n  }\r\n\r\n  /** @override **/\r\n  get universal() {\r\n    return false;\r\n  }\r\n\r\n  /** @override **/\r\n  offsetName(ts, { format, locale }) {\r\n    return parseZoneInfo(ts, format, locale, this.name);\r\n  }\r\n\r\n  /** @override **/\r\n  offset(ts) {\r\n    const date = new Date(ts),\r\n      dtf = makeDTF(this.name),\r\n      [year, month, day, hour, minute, second] = dtf.formatToParts\r\n        ? partsOffset(dtf, date)\r\n        : hackyOffset(dtf, date);\r\n    const asUTC = objToLocalTS({ year, month, day, hour, minute, second, millisecond: 0 });\r\n    let asTS = date.valueOf();\r\n    asTS -= asTS % 1000;\r\n    return (asUTC - asTS) / (60 * 1000);\r\n  }\r\n\r\n  /** @override **/\r\n  equals(otherZone) {\r\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\r\n  }\r\n\r\n  /** @override **/\r\n  get isValid() {\r\n    return this.valid;\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "/Users/isaac/code/luxon/src/zones/IANAZone.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 339,
    "kind": "variable",
    "name": "matchingRegex",
    "memberof": "src/zones/IANAZone.js",
    "static": true,
    "longname": "src/zones/IANAZone.js~matchingRegex",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/zones/IANAZone.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 340,
    "kind": "variable",
    "name": "dtfCache",
    "memberof": "src/zones/IANAZone.js",
    "static": true,
    "longname": "src/zones/IANAZone.js~dtfCache",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/zones/IANAZone.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 341,
    "kind": "function",
    "name": "makeDTF",
    "memberof": "src/zones/IANAZone.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/zones/IANAZone.js~makeDTF",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/zones/IANAZone.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "zone",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 342,
    "kind": "variable",
    "name": "typeToPos",
    "memberof": "src/zones/IANAZone.js",
    "static": true,
    "longname": "src/zones/IANAZone.js~typeToPos",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/zones/IANAZone.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "{\"year\": *, \"month\": number, \"day\": number, \"hour\": number, \"minute\": number, \"second\": number}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 343,
    "kind": "function",
    "name": "hackyOffset",
    "memberof": "src/zones/IANAZone.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/zones/IANAZone.js~hackyOffset",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/zones/IANAZone.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [
      {
        "name": "dtf",
        "types": [
          "*"
        ]
      },
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 344,
    "kind": "function",
    "name": "partsOffset",
    "memberof": "src/zones/IANAZone.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/zones/IANAZone.js~partsOffset",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/zones/IANAZone.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "params": [
      {
        "name": "dtf",
        "types": [
          "*"
        ]
      },
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 345,
    "kind": "variable",
    "name": "ianaZoneCache",
    "memberof": "src/zones/IANAZone.js",
    "static": true,
    "longname": "src/zones/IANAZone.js~ianaZoneCache",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/zones/IANAZone.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 346,
    "kind": "class",
    "name": "IANAZone",
    "memberof": "src/zones/IANAZone.js",
    "static": true,
    "longname": "src/zones/IANAZone.js~IANAZone",
    "access": "public",
    "export": true,
    "importPath": "luxon/src/zones/IANAZone.js",
    "importStyle": "IANAZone",
    "description": "A zone identified by an IANA identifier, like America/New_York",
    "lineNumber": 58,
    "interface": false,
    "extends": [
      "src/zone.js~Zone"
    ],
    "implements": [
      "Zone"
    ]
  },
  {
    "__docId__": 347,
    "kind": "method",
    "name": "create",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/zones/IANAZone.js~IANAZone.create",
    "access": "public",
    "description": "",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Zone name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IANAZone"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 348,
    "kind": "method",
    "name": "resetCache",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/zones/IANAZone.js~IANAZone.resetCache",
    "access": "public",
    "description": "Reset local caches. Should only be necessary in testing scenarios.",
    "lineNumber": 73,
    "return": {
      "nullable": null,
      "types": [
        "void"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 349,
    "kind": "method",
    "name": "isValidSpecifier",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/zones/IANAZone.js~IANAZone.isValidSpecifier",
    "access": "public",
    "description": "Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.",
    "examples": [
      "IANAZone.isValidSpecifier(\"America/New_York\") //=> true",
      "IANAZone.isValidSpecifier(\"Fantasia/Castle\") //=> true",
      "IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false"
    ],
    "lineNumber": 85,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "s",
        "description": "The string to check validity on"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 350,
    "kind": "method",
    "name": "isValidZone",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/zones/IANAZone.js~IANAZone.isValidZone",
    "access": "public",
    "description": "Returns whether the provided string identifies a real zone",
    "examples": [
      "IANAZone.isValidZone(\"America/New_York\") //=> true",
      "IANAZone.isValidZone(\"Fantasia/Castle\") //=> false",
      "IANAZone.isValidZone(\"Sport~~blorp\") //=> false"
    ],
    "lineNumber": 97,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "The string to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 351,
    "kind": "method",
    "name": "parseGMTOffset",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/zones/IANAZone.js~IANAZone.parseGMTOffset",
    "access": "public",
    "description": null,
    "lineNumber": 108,
    "ignore": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 352,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/IANAZone.js~IANAZone#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 118,
    "undocument": true
  },
  {
    "__docId__": 353,
    "kind": "member",
    "name": "zoneName",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "static": false,
    "longname": "src/zones/IANAZone.js~IANAZone#zoneName",
    "access": "private",
    "description": null,
    "lineNumber": 121,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 354,
    "kind": "member",
    "name": "valid",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "static": false,
    "longname": "src/zones/IANAZone.js~IANAZone#valid",
    "access": "private",
    "description": null,
    "lineNumber": 123,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 355,
    "kind": "get",
    "name": "type",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/IANAZone.js~IANAZone#type",
    "access": "public",
    "description": null,
    "lineNumber": 127,
    "override": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 356,
    "kind": "get",
    "name": "name",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/IANAZone.js~IANAZone#name",
    "access": "public",
    "description": null,
    "lineNumber": 132,
    "override": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 357,
    "kind": "get",
    "name": "universal",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/IANAZone.js~IANAZone#universal",
    "access": "public",
    "description": null,
    "lineNumber": 137,
    "override": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 358,
    "kind": "method",
    "name": "offsetName",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/IANAZone.js~IANAZone#offsetName",
    "access": "public",
    "description": null,
    "lineNumber": 142,
    "override": true,
    "params": [
      {
        "name": "ts",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern1",
        "types": [
          "{\"format\": *, \"locale\": *}"
        ],
        "defaultRaw": {
          "format": null,
          "locale": null
        },
        "defaultValue": "{\"format\":null,\"locale\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 359,
    "kind": "method",
    "name": "offset",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/IANAZone.js~IANAZone#offset",
    "access": "public",
    "description": null,
    "lineNumber": 147,
    "override": true,
    "params": [
      {
        "name": "ts",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 360,
    "kind": "method",
    "name": "equals",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/IANAZone.js~IANAZone#equals",
    "access": "public",
    "description": null,
    "lineNumber": 160,
    "override": true,
    "params": [
      {
        "name": "otherZone",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 361,
    "kind": "get",
    "name": "isValid",
    "memberof": "src/zones/IANAZone.js~IANAZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/IANAZone.js~IANAZone#isValid",
    "access": "public",
    "description": null,
    "lineNumber": 165,
    "override": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 362,
    "kind": "file",
    "name": "src/zones/fixedOffsetZone.js",
    "content": "import { padStart, signedOffset } from \"../impl/util.js\";\r\nimport Zone from \"../zone.js\";\r\n\r\nlet singleton = null;\r\n\r\nfunction hoursMinutesOffset(z) {\r\n  const hours = Math.trunc(z.fixed / 60),\r\n    minutes = Math.abs(z.fixed % 60),\r\n    sign = hours > 0 ? \"+\" : \"-\",\r\n    base = sign + Math.abs(hours);\r\n  return minutes > 0 ? `${base}:${padStart(minutes, 2)}` : base;\r\n}\r\n\r\n/**\r\n * A zone with a fixed offset (i.e. no DST)\r\n * @implements {Zone}\r\n */\r\nexport default class FixedOffsetZone extends Zone {\r\n  /**\r\n   * Get a singleton instance of UTC\r\n   * @return {FixedOffsetZone}\r\n   */\r\n  static get utcInstance() {\r\n    if (singleton === null) {\r\n      singleton = new FixedOffsetZone(0);\r\n    }\r\n    return singleton;\r\n  }\r\n\r\n  /**\r\n   * Get an instance with a specified offset\r\n   * @param {number} offset - The offset in minutes\r\n   * @return {FixedOffsetZone}\r\n   */\r\n  static instance(offset) {\r\n    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);\r\n  }\r\n\r\n  /**\r\n   * Get an instance of FixedOffsetZone from a UTC offset string, like \"UTC+6\"\r\n   * @param {string} s - The offset string to parse\r\n   * @example FixedOffsetZone.parseSpecifier(\"UTC+6\")\r\n   * @example FixedOffsetZone.parseSpecifier(\"UTC+06\")\r\n   * @example FixedOffsetZone.parseSpecifier(\"UTC-6:00\")\r\n   * @return {FixedOffsetZone}\r\n   */\r\n  static parseSpecifier(s) {\r\n    if (s) {\r\n      const r = s.match(/^utc(?:([+-]\\d{1,2})(?::(\\d{2}))?)?$/i);\r\n      if (r) {\r\n        return new FixedOffsetZone(signedOffset(r[1], r[2]));\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  constructor(offset) {\r\n    super();\r\n    /** @private **/\r\n    this.fixed = offset;\r\n  }\r\n\r\n  /** @override **/\r\n  get type() {\r\n    return \"fixed\";\r\n  }\r\n\r\n  /** @override **/\r\n  get name() {\r\n    return this.fixed === 0 ? \"UTC\" : `UTC${hoursMinutesOffset(this)}`;\r\n  }\r\n\r\n  /** @override **/\r\n  offsetName() {\r\n    return this.name;\r\n  }\r\n\r\n  /** @override **/\r\n  get universal() {\r\n    return true;\r\n  }\r\n\r\n  /** @override **/\r\n  offset() {\r\n    return this.fixed;\r\n  }\r\n\r\n  /** @override **/\r\n  equals(otherZone) {\r\n    return otherZone.type === \"fixed\" && otherZone.fixed === this.fixed;\r\n  }\r\n\r\n  /** @override **/\r\n  get isValid() {\r\n    return true;\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "/Users/isaac/code/luxon/src/zones/fixedOffsetZone.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 363,
    "kind": "variable",
    "name": "singleton",
    "memberof": "src/zones/fixedOffsetZone.js",
    "static": true,
    "longname": "src/zones/fixedOffsetZone.js~singleton",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/zones/fixedOffsetZone.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 364,
    "kind": "function",
    "name": "hoursMinutesOffset",
    "memberof": "src/zones/fixedOffsetZone.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/zones/fixedOffsetZone.js~hoursMinutesOffset",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/zones/fixedOffsetZone.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [
      {
        "name": "z",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 365,
    "kind": "class",
    "name": "FixedOffsetZone",
    "memberof": "src/zones/fixedOffsetZone.js",
    "static": true,
    "longname": "src/zones/fixedOffsetZone.js~FixedOffsetZone",
    "access": "public",
    "export": true,
    "importPath": "luxon/src/zones/fixedOffsetZone.js",
    "importStyle": "FixedOffsetZone",
    "description": "A zone with a fixed offset (i.e. no DST)",
    "lineNumber": 18,
    "interface": false,
    "extends": [
      "src/zone.js~Zone"
    ],
    "implements": [
      "Zone"
    ]
  },
  {
    "__docId__": 366,
    "kind": "get",
    "name": "utcInstance",
    "memberof": "src/zones/fixedOffsetZone.js~FixedOffsetZone",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/zones/fixedOffsetZone.js~FixedOffsetZone.utcInstance",
    "access": "public",
    "description": "Get a singleton instance of UTC",
    "lineNumber": 23,
    "return": {
      "nullable": null,
      "types": [
        "FixedOffsetZone"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 367,
    "kind": "method",
    "name": "instance",
    "memberof": "src/zones/fixedOffsetZone.js~FixedOffsetZone",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/zones/fixedOffsetZone.js~FixedOffsetZone.instance",
    "access": "public",
    "description": "Get an instance with a specified offset",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "The offset in minutes"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "FixedOffsetZone"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 368,
    "kind": "method",
    "name": "parseSpecifier",
    "memberof": "src/zones/fixedOffsetZone.js~FixedOffsetZone",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/zones/fixedOffsetZone.js~FixedOffsetZone.parseSpecifier",
    "access": "public",
    "description": "Get an instance of FixedOffsetZone from a UTC offset string, like \"UTC+6\"",
    "examples": [
      "FixedOffsetZone.parseSpecifier(\"UTC+6\")",
      "FixedOffsetZone.parseSpecifier(\"UTC+06\")",
      "FixedOffsetZone.parseSpecifier(\"UTC-6:00\")"
    ],
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "s",
        "description": "The offset string to parse"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "FixedOffsetZone"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 369,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/zones/fixedOffsetZone.js~FixedOffsetZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/fixedOffsetZone.js~FixedOffsetZone#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true
  },
  {
    "__docId__": 370,
    "kind": "member",
    "name": "fixed",
    "memberof": "src/zones/fixedOffsetZone.js~FixedOffsetZone",
    "static": false,
    "longname": "src/zones/fixedOffsetZone.js~FixedOffsetZone#fixed",
    "access": "private",
    "description": null,
    "lineNumber": 60,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 371,
    "kind": "get",
    "name": "type",
    "memberof": "src/zones/fixedOffsetZone.js~FixedOffsetZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/fixedOffsetZone.js~FixedOffsetZone#type",
    "access": "public",
    "description": null,
    "lineNumber": 64,
    "override": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 372,
    "kind": "get",
    "name": "name",
    "memberof": "src/zones/fixedOffsetZone.js~FixedOffsetZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/fixedOffsetZone.js~FixedOffsetZone#name",
    "access": "public",
    "description": null,
    "lineNumber": 69,
    "override": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 373,
    "kind": "method",
    "name": "offsetName",
    "memberof": "src/zones/fixedOffsetZone.js~FixedOffsetZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/fixedOffsetZone.js~FixedOffsetZone#offsetName",
    "access": "public",
    "description": null,
    "lineNumber": 74,
    "override": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 374,
    "kind": "get",
    "name": "universal",
    "memberof": "src/zones/fixedOffsetZone.js~FixedOffsetZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/fixedOffsetZone.js~FixedOffsetZone#universal",
    "access": "public",
    "description": null,
    "lineNumber": 79,
    "override": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 375,
    "kind": "method",
    "name": "offset",
    "memberof": "src/zones/fixedOffsetZone.js~FixedOffsetZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/fixedOffsetZone.js~FixedOffsetZone#offset",
    "access": "public",
    "description": null,
    "lineNumber": 84,
    "override": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 376,
    "kind": "method",
    "name": "equals",
    "memberof": "src/zones/fixedOffsetZone.js~FixedOffsetZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/fixedOffsetZone.js~FixedOffsetZone#equals",
    "access": "public",
    "description": null,
    "lineNumber": 89,
    "override": true,
    "params": [
      {
        "name": "otherZone",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 377,
    "kind": "get",
    "name": "isValid",
    "memberof": "src/zones/fixedOffsetZone.js~FixedOffsetZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/fixedOffsetZone.js~FixedOffsetZone#isValid",
    "access": "public",
    "description": null,
    "lineNumber": 94,
    "override": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 378,
    "kind": "file",
    "name": "src/zones/invalidZone.js",
    "content": "import Zone from \"../zone.js\";\r\n\r\n/**\r\n * A zone that failed to parse. You should never need to instantiate this.\r\n * @implements {Zone}\r\n */\r\nexport default class InvalidZone extends Zone {\r\n  constructor(zoneName) {\r\n    super();\r\n    /**  @private */\r\n    this.zoneName = zoneName;\r\n  }\r\n\r\n  /** @override **/\r\n  get type() {\r\n    return \"invalid\";\r\n  }\r\n\r\n  /** @override **/\r\n  get name() {\r\n    return this.zoneName;\r\n  }\r\n\r\n  /** @override **/\r\n  get universal() {\r\n    return false;\r\n  }\r\n\r\n  /** @override **/\r\n  offsetName() {\r\n    return null;\r\n  }\r\n\r\n  /** @override **/\r\n  offset() {\r\n    return NaN;\r\n  }\r\n\r\n  /** @override **/\r\n  equals() {\r\n    return false;\r\n  }\r\n\r\n  /** @override **/\r\n  get isValid() {\r\n    return false;\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "/Users/isaac/code/luxon/src/zones/invalidZone.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 379,
    "kind": "class",
    "name": "InvalidZone",
    "memberof": "src/zones/invalidZone.js",
    "static": true,
    "longname": "src/zones/invalidZone.js~InvalidZone",
    "access": "public",
    "export": true,
    "importPath": "luxon/src/zones/invalidZone.js",
    "importStyle": "InvalidZone",
    "description": "A zone that failed to parse. You should never need to instantiate this.",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "src/zone.js~Zone"
    ],
    "implements": [
      "Zone"
    ]
  },
  {
    "__docId__": 380,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/zones/invalidZone.js~InvalidZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/invalidZone.js~InvalidZone#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true
  },
  {
    "__docId__": 381,
    "kind": "member",
    "name": "zoneName",
    "memberof": "src/zones/invalidZone.js~InvalidZone",
    "static": false,
    "longname": "src/zones/invalidZone.js~InvalidZone#zoneName",
    "access": "public",
    "description": " @private",
    "lineNumber": 11,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 382,
    "kind": "get",
    "name": "type",
    "memberof": "src/zones/invalidZone.js~InvalidZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/invalidZone.js~InvalidZone#type",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "override": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 383,
    "kind": "get",
    "name": "name",
    "memberof": "src/zones/invalidZone.js~InvalidZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/invalidZone.js~InvalidZone#name",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "override": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 384,
    "kind": "get",
    "name": "universal",
    "memberof": "src/zones/invalidZone.js~InvalidZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/invalidZone.js~InvalidZone#universal",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "override": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 385,
    "kind": "method",
    "name": "offsetName",
    "memberof": "src/zones/invalidZone.js~InvalidZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/invalidZone.js~InvalidZone#offsetName",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "override": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 386,
    "kind": "method",
    "name": "offset",
    "memberof": "src/zones/invalidZone.js~InvalidZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/invalidZone.js~InvalidZone#offset",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "override": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 387,
    "kind": "method",
    "name": "equals",
    "memberof": "src/zones/invalidZone.js~InvalidZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/invalidZone.js~InvalidZone#equals",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "override": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 388,
    "kind": "get",
    "name": "isValid",
    "memberof": "src/zones/invalidZone.js~InvalidZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/invalidZone.js~InvalidZone#isValid",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "override": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 389,
    "kind": "file",
    "name": "src/zones/localZone.js",
    "content": "import { parseZoneInfo, hasIntl } from \"../impl/util.js\";\r\nimport Zone from \"../zone.js\";\r\n\r\nlet singleton = null;\r\n\r\n/**\r\n * Represents the local zone for this Javascript environment.\r\n * @implements {Zone}\r\n */\r\nexport default class LocalZone extends Zone {\r\n  /**\r\n   * Get a singleton instance of the local zone\r\n   * @return {LocalZone}\r\n   */\r\n  static get instance() {\r\n    if (singleton === null) {\r\n      singleton = new LocalZone();\r\n    }\r\n    return singleton;\r\n  }\r\n\r\n  /** @override **/\r\n  get type() {\r\n    return \"local\";\r\n  }\r\n\r\n  /** @override **/\r\n  get name() {\r\n    if (hasIntl()) {\r\n      return new Intl.DateTimeFormat().resolvedOptions().timeZone;\r\n    } else return \"local\";\r\n  }\r\n\r\n  /** @override **/\r\n  get universal() {\r\n    return false;\r\n  }\r\n\r\n  /** @override **/\r\n  offsetName(ts, { format, locale }) {\r\n    return parseZoneInfo(ts, format, locale);\r\n  }\r\n\r\n  /** @override **/\r\n  offset(ts) {\r\n    return -new Date(ts).getTimezoneOffset();\r\n  }\r\n\r\n  /** @override **/\r\n  equals(otherZone) {\r\n    return otherZone.type === \"local\";\r\n  }\r\n\r\n  /** @override **/\r\n  get isValid() {\r\n    return true;\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "/Users/isaac/code/luxon/src/zones/localZone.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 390,
    "kind": "variable",
    "name": "singleton",
    "memberof": "src/zones/localZone.js",
    "static": true,
    "longname": "src/zones/localZone.js~singleton",
    "access": "public",
    "export": false,
    "importPath": "luxon/src/zones/localZone.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 391,
    "kind": "class",
    "name": "LocalZone",
    "memberof": "src/zones/localZone.js",
    "static": true,
    "longname": "src/zones/localZone.js~LocalZone",
    "access": "public",
    "export": true,
    "importPath": "luxon/src/zones/localZone.js",
    "importStyle": "LocalZone",
    "description": "Represents the local zone for this Javascript environment.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "src/zone.js~Zone"
    ],
    "implements": [
      "Zone"
    ]
  },
  {
    "__docId__": 392,
    "kind": "get",
    "name": "instance",
    "memberof": "src/zones/localZone.js~LocalZone",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/zones/localZone.js~LocalZone.instance",
    "access": "public",
    "description": "Get a singleton instance of the local zone",
    "lineNumber": 15,
    "return": {
      "nullable": null,
      "types": [
        "LocalZone"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 393,
    "kind": "get",
    "name": "type",
    "memberof": "src/zones/localZone.js~LocalZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/localZone.js~LocalZone#type",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "override": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 394,
    "kind": "get",
    "name": "name",
    "memberof": "src/zones/localZone.js~LocalZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/localZone.js~LocalZone#name",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "override": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 395,
    "kind": "get",
    "name": "universal",
    "memberof": "src/zones/localZone.js~LocalZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/localZone.js~LocalZone#universal",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "override": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 396,
    "kind": "method",
    "name": "offsetName",
    "memberof": "src/zones/localZone.js~LocalZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/localZone.js~LocalZone#offsetName",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "override": true,
    "params": [
      {
        "name": "ts",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern1",
        "types": [
          "{\"format\": *, \"locale\": *}"
        ],
        "defaultRaw": {
          "format": null,
          "locale": null
        },
        "defaultValue": "{\"format\":null,\"locale\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 397,
    "kind": "method",
    "name": "offset",
    "memberof": "src/zones/localZone.js~LocalZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/localZone.js~LocalZone#offset",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "override": true,
    "params": [
      {
        "name": "ts",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 398,
    "kind": "method",
    "name": "equals",
    "memberof": "src/zones/localZone.js~LocalZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/localZone.js~LocalZone#equals",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "override": true,
    "params": [
      {
        "name": "otherZone",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 399,
    "kind": "get",
    "name": "isValid",
    "memberof": "src/zones/localZone.js~LocalZone",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/zones/localZone.js~LocalZone#isValid",
    "access": "public",
    "description": null,
    "lineNumber": 55,
    "override": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "kind": "index",
    "content": "# Luxon\n\n[![MIT License][license-image]][license] [![Build Status][travis-image]][travis-url] [![NPM version][npm-version-image]][npm-url] [![Coverage Status][test-coverage-image]][test-coverage-url] [![Doc coverage][doc-coverage-image]][doc-url] [![PRs welcome][contributing-image]][contributing-url]\n\nLuxon is a library for working with dates and times in Javascript.\n\n```js\nDateTime.local().setZone('America/New_York').minus({ weeks: 1 }).endOf('day').toISO();\n```\n\n## Features\n * DateTime, Duration, and Interval types.\n * Immutable, chainable, unambiguous API.\n * Parsing and formatting for common and custom formats.\n * Native time zone and Intl support (no locale or tz files).\n\n## Download/install\n\n[Download/install instructions](https://moment.github.io/luxon/docs/manual/install.html)\n\n## Documentation\n\n* [General documentation][doc-url]\n* [API docs](https://moment.github.io/luxon/docs/identifiers.html)\n* [Quick tour](https://moment.github.io/luxon/docs/manual/tour.html)\n* [For Moment users](https://moment.github.io/luxon/docs/manual/moment.html)\n* [Why does Luxon exist?](https://moment.github.io/luxon/docs/manual/why.html)\n* [A quick demo](https://moment.github.io/luxon/demo/global.html)\n\n## Development\n\nSee [contributing](contributing.md).\n\n![Phasers to stun][phasers-image]\n\n[license-image]: http://img.shields.io/badge/license-MIT-blue.svg\n[license]: license.txt\n\n[travis-url]: http://travis-ci.org/moment/luxon\n[travis-image]: https://api.travis-ci.org/moment/luxon.svg?branch=master\n\n[npm-url]: https://npmjs.org/package/luxon\n[npm-version-image]: https://badge.fury.io/js/luxon.svg\n\n[doc-url]: https://moment.github.io/luxon/docs/\n[doc-coverage-image]: https://moment.github.io/luxon/docs/badge.svg\n\n[test-coverage-url]: https://codecov.io/gh/moment/luxon\n[test-coverage-image]: https://codecov.io/gh/moment/luxon/branch/master/graph/badge.svg\n\n[contributing-url]: https://moment.github.io/luxon/docs/manual/contributing.html\n[contributing-image]: https://img.shields.io/badge/PRs-welcome-brightgreen.svg\n\n[phasers-image]: https://img.shields.io/badge/phasers-stun-brightgreen.svg\n",
    "longname": "/Users/isaac/code/luxon/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\r\n  \"name\": \"luxon\",\r\n  \"version\": \"1.13.2\",\r\n  \"description\": \"Immutable date wrapper\",\r\n  \"author\": \"Isaac Cambron\",\r\n  \"keywords\": [\r\n    \"date\",\r\n    \"immutable\"\r\n  ],\r\n  \"repository\": \"https://github.com/moment/luxon\",\r\n  \"scripts\": {\r\n    \"build\": \"babel-node tasks/buildAll.js\",\r\n    \"build-node\": \"babel-node tasks/buildNode.js\",\r\n    \"build-global\": \"babel-node tasks/buildGlobal.js\",\r\n    \"jest\": \"jest\",\r\n    \"test\": \"jest --coverage\",\r\n    \"docs\": \"esdoc -c docs/index.js\",\r\n    \"site\": \"cp -r site/** build/\",\r\n    \"lint\": \"eslint --quiet src test benchmarks\",\r\n    \"lint!\": \"npm run format && npm run lint\",\r\n    \"format\": \"prettier --write 'src/**/*.js' 'test/**/*.js' 'benchmarks/*.js'\",\r\n    \"benchmark\": \"babel-node benchmarks/datetime.js\",\r\n    \"codecov\": \"codecov\",\r\n    \"check-doc-coverage\": \"babel-node tasks/docCoverage\"\r\n  },\r\n  \"husky\": {\r\n    \"hooks\": {\r\n      \"pre-commit\": \"lint-staged\"\r\n    }\r\n  },\r\n  \"lint-staged\": {\r\n    \"*.{js,json}\": [\r\n      \"prettier --write\",\r\n      \"git add\"\r\n    ]\r\n  },\r\n  \"devDependencies\": {\r\n    \"@babel/core\": \"^7.1.2\",\r\n    \"@babel/node\": \"^7.2.2\",\r\n    \"@babel/plugin-external-helpers\": \"^7.1.2\",\r\n    \"@babel/preset-env\": \"^7.1.2\",\r\n    \"babel-core\": \"^7.0.0-bridge.0\",\r\n    \"babel-eslint\": \"latest\",\r\n    \"babel-jest\": \"latest\",\r\n    \"benchmark\": \"latest\",\r\n    \"codecov\": \"^3.1.0\",\r\n    \"core-js\": \"^2.5.7\",\r\n    \"esdoc\": \"^1.1.0\",\r\n    \"esdoc-standard-plugin\": \"latest\",\r\n    \"eslint\": \"^5.8.0\",\r\n    \"eslint-config-defaults\": \"latest\",\r\n    \"eslint-config-prettier\": \"3.1.0\",\r\n    \"eslint-config-standard\": \"latest\",\r\n    \"eslint-plugin-babel\": \"latest\",\r\n    \"eslint-plugin-import\": \"latest\",\r\n    \"eslint-plugin-node\": \"^8.0.0\",\r\n    \"eslint-plugin-prettier\": \"3.0.0\",\r\n    \"eslint-plugin-promise\": \"latest\",\r\n    \"eslint-plugin-react\": \"latest\",\r\n    \"eslint-plugin-standard\": \"latest\",\r\n    \"fs-extra\": \"^6.0.1\",\r\n    \"full-icu\": \"latest\",\r\n    \"husky\": \"latest\",\r\n    \"jest\": \"^24.7.1\",\r\n    \"lint-staged\": \"latest\",\r\n    \"prettier\": \"1.14.3\",\r\n    \"rollup\": \"latest\",\r\n    \"rollup-plugin-babel\": \"latest\",\r\n    \"rollup-plugin-babel-minify\": \"^6.1.1\",\r\n    \"rollup-plugin-commonjs\": \"^9.2.0\",\r\n    \"rollup-plugin-node-resolve\": \"latest\",\r\n    \"uglify-js\": \"latest\"\r\n  },\r\n  \"main\": \"build/node/luxon.js\",\r\n  \"module\": \"src/luxon.js\",\r\n  \"browser\": \"build/cjs-browser/luxon.js\",\r\n  \"jsdelivr\": \"build/global/luxon.min.js\",\r\n  \"unpkg\": \"build/global/luxon.min.js\",\r\n  \"engines\": {\r\n    \"node\": \"*\"\r\n  },\r\n  \"files\": [\r\n    \"build/node/luxon.js\",\r\n    \"build/node/luxon.js.map\",\r\n    \"build/cjs-browser/luxon.js\",\r\n    \"build/cjs-browser/luxon.js.map\",\r\n    \"build/amd/luxon.js\",\r\n    \"build/amd/luxon.js.map\",\r\n    \"build/global/luxon.js\",\r\n    \"build/global/luxon.js.map\",\r\n    \"build/global/luxon.min.js\",\r\n    \"build/global/luxon.min.js.map\",\r\n    \"src\"\r\n  ],\r\n  \"license\": \"MIT\"\r\n}\r\n",
    "longname": "/Users/isaac/code/luxon/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": true,
    "content": "# Luxon Documentation\n\nThis is the manual for Luxon. You'll find guides below and an API doc reference [here](identifiers.html).\n",
    "longname": "/Users/isaac/code/luxon/docs/index.md",
    "name": "./docs/index.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/isaac/code/luxon/docs/install.md",
    "name": "./docs/install.md",
    "content": "# Install guide\n\nLuxon provides different builds for different JS environments. See below for a link to the right one and instructions on how to use it. Luxon supports all modern platforms, but see [the support matrix](matrix.html) for additional details.\n\n## Basic browser setup\n\n- [Download full](../../global/luxon.js)\n- [Download minified](../../global/luxon.min.js)\n\nYou can also load the files from a [CDN](https://www.jsdelivr.com/package/npm/luxon).\n\nJust include Luxon in a script tag. You can access its various classes through the `luxon` global.\n\n```html\n<script src=\"luxon.js\"></script>\n```\n\nYou may wish to alias the classes you use:\n\n```js\nvar DateTime = luxon.DateTime;\n```\n\n### Internet Explorer\n\nIf you're supporting IE 10 or 11, you need some polyfills to get Luxon to work. Use polyfill.io:\n\n```html\n<script src=\"https://cdn.polyfill.io/v2/polyfill.js?features=default,String.prototype.repeat,Array.prototype.find,Array.prototype.findIndex,Math.trunc,Math.sign\"></script>\n```\n\nSee the [support matrix](matrix.html) for more information on what works and what doesn't in IE.\n\n## Node\n\nSupports Node 6+. Install via NPM:\n\n```\nnpm install --save luxon\n```\n\n```js\nconst { DateTime } = require(\"luxon\");\n```\n\nIf you want to work with locales, you'll need to have `full-icu` support installed in Node. You can [build Node with it](https://github.com/nodejs/node/wiki/Intl), use an [NPM module](https://www.npmjs.com/package/full-icu) to provide it, or find it prepackaged for your platform, like `brew install node --with-full-icu`. If you skip this step, Luxon still works but methods like `setLocale()` will do nothing.\n\nThe instructions for using full-icu as a package are a little confusing. Node can't automatically discover that you've installed the it, so you need to tell it where to find the data, like this:\n\n```\nnpm install full-icu\nnode --icu-data-dir=./node_modules/full-icu\n```\n\nYou can also point to the data with an environment var, like this:\n\n```\nNODE_ICU_DATA=\"$(pwd)/node_modules/full-icu\" node\n```\n\n## AMD (System.js, RequireJS, etc)\n\n- [Download full](../../amd/luxon.js)\n- [Download minified](../../amd/luxon.min.js)\n\n```js\nrequirejs([\"luxon\"], function(luxon) {\n  //...\n});\n```\n\n## ES6\n\n- [Download full](../../es6/luxon.js)\n- [Download minified](../../es6/luxon.min.js)\n\n```js\nimport { DateTime } from \"luxon\";\n```\n\n## Webpack\n\n```\nnpm install --save luxon\n```\n\n```js\nimport { DateTime } from \"luxon\";\n```\n\n## Types\n\nThere are third-party typing files for Flow (via [flow-typed](https://github.com/flowtype/flow-typed)) and TypeScript (via [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)).\n\nFor Flow, use:\n\n```\nflow-typed install luxon\n```\n\nFor TypeScript, use:\n\n```\nnpm install --save-dev @types/luxon\n```\n\n## React Native\n\nReact Native works just fine, but React Native for Android doesn't ship with Intl support, which you need for [a lot of Luxon's functionality](matrix.html). Use [jsc-android-buildscripts](https://github.com/SoftwareMansion/jsc-android-buildscripts) to fix it.\n\n## Meteor\n\n[Help wanted.]\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/isaac/code/luxon/docs/tour.md",
    "name": "./docs/tour.md",
    "content": "# A quick tour\r\n\r\nLuxon is a library that makes it easier to work with dates and times in Javascript. If you want, add and subtract them, format and parse them, ask them hard questions, and so on, Luxon provides a much easier and comprehensive interface than the native types it wraps. We're going to talk about the most immediately useful subset of that interface.\r\n\r\nThis is going to be a bit brisk, but keep in mind that the API docs are comprehensive, so if you want to know more, feel free to [dive into them](../identifiers.html).\r\n\r\n## Your first DateTime\r\n\r\nThe most important class in Luxon is [DateTime](../class/src/datetime.js~DateTime.html). A DateTime represents a specific millisecond in time, along with a time zone and a locale. Here's one that represents May 15, 2017 at 8:30 in the morning:\r\n\r\n```js\r\nvar dt = DateTime.local(2017, 5, 15, 8, 30);\r\n```\r\n\r\nTo get the current time, just do this:\r\n\r\n```js\r\nvar now = DateTime.local();\r\n```\r\n\r\n[DateTime.local](../class/src/datetime.js~DateTime.html#static-method-local) takes any number of arguments, all the way out to milliseconds. Underneath, this is just a Javascript Date object. But we've decorated it with lots of useful methods.\r\n\r\n## Creating a DateTime\r\n\r\nThere are lots of ways to create a DateTime by parsing strings or constructing them out of parts. You've already seen one, `DateTime.local()`, but let's talk about two more.\r\n\r\n### Create from an object\r\n\r\nThe most powerful way to create a DateTime instance is to provide an object containing all the information:\r\n\r\n```js\r\ndt = DateTime.fromObject({day: 22, hour: 12, zone: 'America/Los_Angeles', numberingSystem: 'beng'})\r\n```\r\n\r\nDon't worry too much about the properties you don't understand yet; the point is that you can set every attribute of a DateTime when you create it. One thing to notice from the example is that we just set the day and hour; the year and month get defaulted to the current one and the minutes, seconds, and milliseconds get defaulted to 0. So [DateTime.fromObject](../class/src/datetime.js~DateTime.html#static-method-fromObject) is sort of the power user interface.\r\n\r\n### Parse from ISO 8601\r\n\r\nLuxon has lots of parsing capabilities, but the most important one is parsing [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) strings, because they're more-or-less the standard wire format for dates and times. Use [DateTime.fromISO](../class/src/datetime.js~DateTime.html#static-method-fromISO).\r\n\r\n\r\n```js\r\nDateTime.fromISO(\"2017-05-15\")          //=> May 15, 2017 at midnight\r\nDateTime.fromISO(\"2017-05-15T08:30:00\") //=> May 15, 2017 at 8:30\r\n```\r\n\r\nYou can parse a bunch of other formats, including [your own custom ones](parsing.html).\r\n\r\n## Getting to know your DateTime instance\r\n\r\nNow that we've made some DateTimes, let's see what we can ask of it.\r\n\r\n### toString\r\n\r\nThe first thing we want to see is the DateTime as a string. Luxon returns ISO 8601 strings:\r\n\r\n```js\r\nDateTime.local().toString() //=> '2017-09-14T03:20:34.091-04:00'\r\n```\r\n\r\n### Getting at components\r\n\r\nWe can get at the components of the time individually through getters. For example:\r\n\r\n```js\r\ndt = DateTime.local()\r\ndt.year     //=> 2017\r\ndt.month    //=> 9\r\ndt.day      //=> 14\r\ndt.second   //=> 47\r\ndt.weekday  //=> 4\r\n```\r\n\r\n### Other fun accessors\r\n\r\n```js\r\ndt.zoneName     //=> 'America/New_York'\r\ndt.offset       //=> -240\r\ndt.daysInMonth  //=> 30\r\n```\r\n\r\nThere are lots more!\r\n\r\n## Formatting your DateTime\r\n\r\nYou may want to output your DateTime to a string for a machine or a human to read. Luxon has lots of tools for this, but two of them are most important. If you want to format a human-readable string, use `toLocaleString`:\r\n\r\n```js\r\ndt.toLocaleString()      //=> '9/14/2017'\r\ndt.toLocaleString(DateTime.DATETIME_MED) //=> 'September 14, 3:21 AM'\r\n```\r\n\r\nThis works well across different locales (languages) by letting the browser figure out what order the different parts go in and how to punctuate them.\r\n\r\nIf you want the string read by another program, you almost certainly want to use `toISO`:\r\n\r\n```js\r\ndt.toISO() //=> '2017-09-14T03:21:47.070-04:00'\r\n```\r\n\r\nCustom formats are also supported. See [formatting](formatting).\r\n\r\n## Transforming your DateTime\r\n\r\n### Immutability\r\n\r\nLuxon objects are immutable. That means that you can't alter them in place, just create altered copies. Throughout the documentation, we use terms like \"alter\", \"change\", and \"set\" loosely, but rest assured we mean \"create a new instance with different properties\".\r\n\r\n### Math\r\n\r\nThis is easier to show than to tell. All of these calls return new DateTime instances:\r\n\r\n```js\r\nvar dt = DateTime.local();\r\ndt.plus({hours: 3, minutes: 2});\r\ndt.minus({days: 7});\r\ndt.startOf('day');\r\ndt.endOf('hour');\r\n```\r\n\r\n### Set\r\n\r\nYou can create new instances by overriding specific properties:\r\n\r\n```js\r\nvar dt = DateTime.local();\r\ndt.set({hour: 3}).hour   //=> 3\r\n```\r\n\r\n## Intl\r\n\r\nLuxon provides several different Intl capabilities, but the most important one is in formatting:\r\n\r\n```js\r\nvar dt = DateTime.local();\r\nvar f = {month: 'long', day: 'numeric'};\r\ndt.setLocale('fr').toLocaleString(f)      //=> '14 septembre'\r\ndt.setLocale('en-GB').toLocaleString(f)   //=> '14 September'\r\ndt.setLocale('en-US').toLocaleString(f)  //=> 'September 14'\r\n ```\r\n\r\nLuxon's Info class can also list months or weekdays for different locales:\r\n\r\n```js\r\nInfo.months('long', {locale: 'fr'}) //=> [ 'janvier', 'fvrier', 'mars', 'avril', ... ]\r\n```\r\n\r\n## Time zones\r\n\r\nLuxon supports time zones. There's a whole [big section](zones) about it. But briefly, you can create DateTimes in specific zones and change their zones:\r\n\r\n```js\r\nDateTime.fromObject({zone: 'America/Los_Angeles'}) // now, but expressed in LA's local time\r\nDateTime.local().setZone('America/Los_Angeles') // same\r\n```\r\n\r\nLuxon also supports UTC directly:\r\n\r\n```js\r\nDateTime.utc(2017, 5, 15);\r\nDateTime.utc();\r\nDateTime.local().toUTC();\r\nDateTime.utc().toLocal();\r\n```\r\n\r\n## Durations\r\n\r\nThe Duration class represents a quantity of time such as \"2 hours and 7 minutes\". You create them like this:\r\n\r\n```js\r\nvar dur = Duration.fromObject({hours: 2, minutes: 7});\r\n```\r\n\r\nThey can be add or subtracted from DateTimes like this:\r\n\r\n```js\r\ndt.plus(dur);\r\n```\r\n\r\nThey have getters just like DateTime:\r\n\r\n```js\r\ndur.hours   //=> 2\r\ndur.minutes //=> 7\r\ndur.seconds //=> 0\r\n```\r\n\r\nAnd some other useful stuff:\r\n\r\n```js\r\ndur.as('seconds') //=> 7620\r\ndur.toObject()    //=> { hours: 2, minutes: 7 }\r\ndur.toISO()       //=> 'PT2H7M'\r\n```\r\n\r\nYou can also format, negate, and normalize them. See it all in the [Duration API docs](../class/src/duration.js~Duration.html).\r\n\r\n## Intervals\r\n\r\nIntervals are a specific period of time, such as \"between now and midnight\". They're really a wrapper for two DateTimes that form its endpoints. Here's what you can do with them:\r\n\r\n\r\n```js\r\nnow = DateTime.local();\r\nlater = DateTime.local(2020, 10, 12);\r\ni = Interval.fromDateTimes(now, later);\r\n\r\ni.length()                             //=> 97098768468\r\ni.length('years', true)                //=> 3.0762420239726027\r\ni.contains(DateTime.local(2019))       //=> true\r\n\r\ni.toISO()       //=> '2017-09-14T04:07:11.532-04:00/2020-10-12T00:00:00.000-04:00'\r\ni.toString()    //=> '[2017-09-14T04:07:11.532-04:00  2020-10-12T00:00:00.000-04:00)\r\n```\r\n\r\nIntervals can be split up into smaller intervals, perform set-like operations with other intervals, and few other handy features. See the [Interval API docs](../class/src/interval.js~Interval.html).\r\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/isaac/code/luxon/docs/intl.md",
    "name": "./docs/intl.md",
    "content": "# Intl\r\n\r\nLuxon uses the native Intl API to provide easy-to-use internationalization. A quick example:\r\n\r\n```js\r\nDateTime.local()\r\n  .setLocale(\"el\")\r\n  .toLocaleString(DateTime.DATE_FULL); //=>  '24  2017'\r\n```\r\n\r\n## Making sure you have access to other locales\r\n\r\nPlease see the [install guide](install.html) for instructions on making sure your platform has access to the Intl APIs and the ICU data to power it. This especially important for Node, which doesn't ship with ICU data by default.\r\n\r\n## How locales work\r\n\r\nLuxon DateTimes can be configured using [BCP 47](https://tools.ietf.org/html/rfc5646) locale strings specifying the language to use generating or interpreting strings. The native Intl API provides the actual internationalized strings; Luxon just wraps it with a nice layer of convenience and integrates the localization functionality into the rest of Luxon. The Mozilla MDN Intl docs have a [good description](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation) of how the `locale` argument works. In Luxon, the methods are different but the semantics are the same, except in that Luxon allows you to specify a numbering system and output calendar independently of the locale string.\r\n\r\nThe rest of this document will concentrate on what Luxon does when provided with locale information.\r\n\r\n## Setting the locale\r\n\r\n`locale` is a property of Luxon object. Thus, locale is a sort of setting on the DateTime object, as opposed to an argument you provide the different methods that need internationalized.\r\n\r\nYou can generally set it at construction time:\r\n\r\n```js\r\nvar dt = DateTime.fromISO(\"2017-09-24\", { locale: \"fr\" });\r\ndt.locale; //=> 'fr'\r\n```\r\n\r\nIn this case, the specified locale didn't change the how the parsing worked (there's nothing localized about it), but it did set the locale property in the resulting instance. For other factory methods, such as `fromFormat`, the locale argument _does_ affect how the string is parsed. See further down for more.\r\n\r\nYou can change the locale of a DateTime instance (meaning, create a clone DateTime with a different locale) using `setLocale`:\r\n\r\n```js\r\nDateTime.local().setLocale(\"fr\").locale; //=> 'fr'\r\n```\r\n\r\n`setLocale` is just a convenience for `reconfigure`:\r\n\r\n```js\r\nDateTime.local().reconfigure({ locale: \"fr\" }).locale; //=> 'fr'\r\n```\r\n\r\n## Default locale\r\n\r\n### Out-of-the-box behavior\r\n\r\nBy default the `locale` property of a new DateTime or Duration is the system locale. On a browser, that means whatever the user has their browser or OS language set to. On Node, that usually means en-US.\r\n\r\nAs a result, `DateTime#toLocaleString`, `DateTime#toLocaleParts`, and other human-readable-string methods like `Info.months` will by default generate strings in the user's locale.\r\n\r\nHowever, note that `DateTime.fromFormat` and `DateTime#toFormat` fall back on en-US. That's because these methods are often used to parse or format strings for consumption by APIs that don't care about the user's locale. So we need to pick a locale and stick with it, or the code will break depending on whose browser it runs in.\r\n\r\nThere's an exception, though: `DateTime#toFormat` can take \"macro\" formats like \"D\" that produces localized strings as part of a larger string. These _do_ default to the system locale because their entire purpose is to be localized.\r\n\r\n### Setting the default\r\n\r\nYou can set a default locale so that news instances will always be created with the specified locale:\r\n\r\n```js\r\nSettings.defaultLocale = \"fr\";\r\nDateTime.local().locale; //=> 'fr'\r\n```\r\n\r\nNote that this also alters the behavior of `DateTime#toFormat` and `DateTime#fromFormat`.\r\n\r\n### Using the system locale in string parsing\r\n\r\nYou generally don't want `DateTime#fromFormat` and `DateTime#toFormat` to use the system's locale, since your format won't be sensitive to the locale's string ordering. That's why Luxon doesn't behave that way by default. But if you really want that behavior, you can always do this:\r\n\r\n```js\r\nSettings.defaultLocale = DateTime.local().resolvedLocaleOpts().locale;\r\n```\r\n\r\n## Checking what you got\r\n\r\nThe local environment may not support the exact locale you asked for. The native Intl API will try to find the best match. If you want to know what that match was, use `resolvedLocaleOpts`:\r\n\r\n```js\r\nDateTime.fromObject({ locale: \"fr-co\" }).resolvedLocaleOpts(); //=> { locale: 'fr',\r\n//     numberingSystem: 'latn',\r\n//     outputCalendar: 'gregory' }\r\n```\r\n\r\n## Methods affected by the locale\r\n\r\n### Formatting\r\n\r\nThe most important method affected by the locale setting is `toLocaleString`, which allows you to produce internationalized, human-readable strings.\r\n\r\n```js\r\ndt.setLocale(\"fr\").toLocaleString(DateTime.DATE_FULL); //=> '25 septembre 2017'\r\n```\r\n\r\nThat's the normal way to do it: set the locale as property of the DateTime itself and let the `toLocaleString` inherit it. But you can specify the locale directly to `toLocaleString` too:\r\n\r\n```js\r\ndt.toLocaleString(Object.assign({ locale: \"es\" }, DateTime.DATE_FULL)); //=> '25 de septiembre de 2017'\r\n```\r\n\r\nAd-hoc formatting also respects the locale:\r\n\r\n```js\r\ndt.setLocale(\"fr\").toFormat(\"MMMM dd, yyyy GG\"); //=> 'septembre 25, 2017 aprs Jsus-Christ'\r\n```\r\n\r\n### Parsing\r\n\r\nYou can [parse](parsing.html) localized strings:\r\n\r\n```js\r\nDateTime.fromFormat(\"septembre 25, 2017 aprs Jsus-Christ\", \"MMMM dd, yyyy GG\", { locale: \"fr\" });\r\n```\r\n\r\n### Listing\r\n\r\nSome of the methods in the [Info](../class/src/info.js~Info.html) class let you list strings like months, weekdays, and eras, and they can be localized:\r\n\r\n```js\r\nInfo.months(\"long\", { locale: \"fr\" }); //=> [ 'janvier', 'fvrier', ...\r\nInfo.weekdays(\"long\", { locale: \"fr\" }); //=> [ 'lundi', 'mardi', ...\r\nInfo.eras(\"long\", { locale: \"fr\" }); //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]\r\n```\r\n\r\n## numberingSystem\r\n\r\nDateTimes also have a `numberingSystem` setting that lets you control what system of numerals is used in formatting. In general, you shouldn't override the numbering system provided by the locale. For example, no extra work is needed to get Arabic numbers to show up in Arabic-speaking locales:\r\n\r\n```js\r\nvar dt = DateTime.local().setLocale(\"ar\");\r\n\r\ndt.resolvedLocaleOpts(); //=> { locale: 'ar',\r\n//     numberingSystem: 'arab',\r\n//     outputCalendar: 'gregory' }\r\n\r\ndt.toLocaleString(); //=> '//'\r\n```\r\n\r\nFor this reason, Luxon defaults its own `numberingSystem` property to null, by which it means \"let the Intl API decide\". However, you can override it if you want. This example is admittedly ridiculous:\r\n\r\n```js\r\nvar dt = DateTime.local().reconfigure({ locale: \"it\", numberingSystem: \"beng\" });\r\ndt.toLocaleString(DateTime.DATE_FULL); //=> ' settembre '\r\n```\r\n\r\nSimilar to `locale`, you can set the default numbering system for new instances:\r\n\r\n```js\r\nSettings.defaultNumberingSystem = \"beng\";\r\n```\r\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/isaac/code/luxon/docs/zones.md",
    "name": "./docs/zones.md",
    "content": "# Time zones and offsets\r\n\r\nLuxon has support for time zones. This page explains how to use them.\r\n\r\n## Don't worry!\r\n\r\nYou _usually_ don't need to worry about time zones. Your code runs on a computer with a particular time zone and everything will work consistently in that zone without you doing anything. It's when you want to do complicated stuff _across_ zones that you have to think about it. Even then, here are some pointers to help you avoid situations where you have to think carefully about time zones:\r\n\r\n1.  Don't make servers think about _local_ times. Configure them to use UTC and write your server's code to work in UTC. Times can often be thought of as a simple count of epoch milliseconds; what you would call that time (e.g. 9:30) in what zone doesn't (again, often) matter.\r\n2.  Communicate times between systems in ISO 8601, like \"2017-05-15T13:30:34Z\" where possible (it doesn't matter if you use Z or some local offset; the point is that it precisely identifies the millisecond on the global timeline).\r\n3.  Where possible, only think of time zones as a formatting concern; your application ideally never knows that the time it's working with is called \"9:00\" until it's being rendered to the user.\r\n4.  Barring 3, do as much manipulation of the time (say, adding an hour to the current time) in the client code that's already running in the time zone where the results will matter.\r\n\r\nAll those things will make it less likely you ever need to work explicitly with time zones and may also save you plenty of other headaches. But those aren't possible for some applications; you might need to work with times in zones other than the one the program is running in, for any number of reasons. And that's where Luxon's time zone support comes in.\r\n\r\n## Terminology\r\n\r\nBear with me here. Time zones are pain in the ass. Luxon has lots of tools to deal with them, but there's no getting around the fact that they're complicated. The terminology for time zones and offsets isn't well-established. But let's try to impose some order:\r\n\r\n1.  An **offset** is a difference between the local time and the UTC time, such as +5 (hours) or -12:30. They may be expressed directly in minutes, or in hours, or in a combination of minutes and hours. Here we'll use hours.\r\n1.  A **time zone** is a set of rules, associated with a geographical location, that determines the local offset from UTC at any given time. The best way to identify a zone is by its IANA string, such as \"America/New_York\". That zone says something to the effect of \"The offset is -4, except between March and November, when it's -5\".\r\n1.  A **fixed-offset time zone** is any time zone that never changes offsets, such as UTC. Luxon supports fixed-offset zones directly; they're specified like UTC+7, which you can interpret as \"always with an offset of +7\".\r\n1.  A **named offset** is a time zone-specific name for an offset, such as Eastern Daylight Time. It expresses both the zone (America's EST roughly implies America/New_York) and the current offset (EST means -4). They are also confusing in that they overspecify the offset (e.g. for any given time it is unnecessary to specify EST vs EDT; it's always whichever one is right). They are also ambiguous (BST is both British Summer Time and Bangladesh Standard Time), unstandardized, and internationalized (what would a Frenchman call the US's EST?). For all these reasons, you should avoid them when specifying times programmatically. Luxon only supports their use in formatting.\r\n\r\nSome subtleties:\r\n\r\n1.  Multiple zones can have the same offset (think about the US's zones and their Canadian equivalents), though they might not have the same offset all the time, depending on when their DSTs are. Thus zones and offsets have a many-to-many relationship.\r\n1.  Just because a time zone doesn't have a DST now doesn't mean it's fixed. Perhaps it had one in the past. Regardless, Luxon does not have first-class access to the list of rules, so it assumes any IANA-specified zone is not fixed and checks for its current offset programmatically.\r\n\r\nIf all this seems too terse, check out these articles. The terminology in them is subtly different but the concepts are the same:\r\n\r\n- [Time Zones Arent Offsets  Offsets Arent Time Zones](https://spin.atomicobject.com/2016/07/06/time-zones-offsets/)\r\n- [Stack Overflow's timezone wiki page](https://stackoverflow.com/tags/timezone/info)\r\n\r\n## Luxon works with time zones\r\n\r\nLuxon's DateTime class supports zones directly. By default, a date created in Luxon is \"in\" the local time zone of the machine it's running on. By \"in\" we mean that the DateTime has, as one of its properties, an associated zone.\r\n\r\nIt's important to remember that a DateTime represents a specific instant in time and that instant has an unambiguous meaning independent of what time zone you're in; the zone is really piece of social metadata that affects how humans interact with the time, rather than a fact about the passing of time itself. Of course, Luxon is a library for humans, so that social metadata affects Luxon's behavior too. It just doesn't change _what time it is_.\r\n\r\nSpecifically, a DateTime's zone affects its behavior in these ways:\r\n\r\n1.  Times will be formatted as they would be in that zone.\r\n1.  Transformations to the DateTime (such as `plus` or `startOf`) will obey any DSTs in that zone that affect the calculation (see \"Math across DSTs\" below)\r\n\r\nGenerally speaking, Luxon does not support changing a DateTime's offset, just its zone. That allows it to enforce the behaviors in the list above. The offset for that DateTime is just whatever the zone says it is. If you are unconcerned with the effects above, then you can always give your DateTime a fixed-offset zone.\r\n\r\n## Specifying a zone\r\n\r\nLuxon's API methods that take a zone as an argument all let you specify the zone in a few ways.\r\n\r\n| Type         | Example            | Description                                                       |\r\n| ------------ | ------------------ | ----------------------------------------------------------------- |\r\n| IANA         | 'America/New_York' | that zone                                                         |\r\n| local        | 'local'            | the system's local zone                                           |\r\n| UTC          | 'utc'              | Universal Coordinated Time                                        |\r\n| fixed offset | 'UTC+7'            | a fixed offset zone                                               |\r\n| Zone         | new YourZone()     | A custom implementation of Luxon's Zone interface (advanced only) |\r\n\r\n### IANA support\r\n\r\nIANA-specified zones are string identifiers like \"America/New_York\" or \"Asia/Tokyo\". Luxon gains direct support for them by abusing built-in Intl APIs. However, your environment may not support them, in which case, you can't fiddle with the zones directly. You can always use the local zone your system is in, UTC, and any fixed-offset zone like UTC+7. You can check if your runtime environment supports IANA zones with our handy utility:\r\n\r\n```js\r\nInfo.features().zones; //=> true\r\n```\r\n\r\nIf you're unsure if all your target environments (browser versions and Node versions) support this, check out the [Support Matrix](matrix.html). You can generally count on modern browsers to have this feature, except IE (it is supported in Edge). You may also [polyfill](matrix.html#zones) your environment.\r\n\r\nIf you specify a zone and your environment doesn't support that zone, you'll get an [invalid](validity.html) DateTime. That could be because the environment doesn't support zones at all, because for whatever reason it doesn't support that _particular_ zone, or because the zone is just bogus. Like this:\r\n\r\n```js\r\nbogus = DateTime.local().setZone(\"America/Bogus\");\r\n\r\nbogus.isValid; //=> false\r\nbogus.invalidReason; //=> 'unsupported zone'\r\n```\r\n\r\n## Creating DateTimes\r\n\r\n### Local by default\r\n\r\nBy default, DateTime instances are created in the system's local zone and parsed strings are interpreted as specifying times in the system's local zone. For example, my computer is configured to use `America/New_York`, which has an offset of -4 in May:\r\n\r\n```js\r\nvar local = DateTime.local(2017, 05, 15, 09, 10, 23);\r\n\r\nlocal.zoneName; //=> 'America/New_York'\r\nlocal.toString(); //=> '2017-05-15T09:10:23.000-04:00'\r\n\r\nvar iso = DateTime.fromISO(\"2017-05-15T09:10:23\");\r\n\r\niso.zoneName; //=> 'America/New_York'\r\niso.toString(); //=> '2017-05-15T09:10:23.000-04:00'\r\n```\r\n\r\n### Creating DateTimes in a zone\r\n\r\nMany of Luxon's factory methods allow you to tell it specifically what zone to create the DateTime in:\r\n\r\n```js\r\nvar overrideZone = DateTime.fromISO(\"2017-05-15T09:10:23\", { zone: \"Europe/Paris\" });\r\n\r\noverrideZone.zoneName; //=> 'Europe/Paris'\r\noverrideZone.toString(); //=> '2017-05-15T09:10:23.000+02:00'\r\n```\r\n\r\nNote two things:\r\n\r\n1.  The date and time specified in the string was interpreted as a Parisian local time (i.e. it's the time that corresponds to what would be called 9:10 _there_).\r\n2.  The resulting DateTime object is in Europe/Paris.\r\n\r\nThose are conceptually independent (i.e. Luxon could have converted the time to the local zone), but it practice it's more convenient for the same option to govern both.\r\n\r\nIn addition, one static method, `utc()`, specifically interprets the input as being specified in UTC. It also returns a DateTime in UTC:\r\n\r\n```js\r\nvar utc = DateTime.utc(2017, 05, 15, 09, 10, 23);\r\n\r\nutc.zoneName; //=> 'UTC'\r\nutc.toString(); //=> '2017-05-15T09:10:23.000Z'\r\n```\r\n\r\n### Strings that specify an offset\r\n\r\nSome input strings may specify an offset as part of the string itself. In these case, Luxon interprets the time as being specified with that offset, but converts the resulting DateTime into the system's local zone:\r\n\r\n```js\r\nvar specifyOffset = DateTime.fromISO(\"2017-05-15T09:10:23-09:00\");\r\n\r\nspecifyOffset.zoneName; //=> 'America/New_York'\r\nspecifyOffset.toString(); //=> '2017-05-15T14:10:23.000-04:00'\r\n\r\nvar specifyZone = DateTime.fromFormat(\r\n  \"2017-05-15T09:10:23 Europe/Paris\",\r\n  \"yyyy-MM-dd'T'HH:mm:ss z\"\r\n);\r\n\r\nspecifyZone.zoneName; //=> 'America/New_York'\r\nspecifyZone.toString(); //=> '2017-05-15T03:10:23.000-04:00'\r\n```\r\n\r\n...unless a zone is specified as an option (see previous section), in which case the DateTime gets converted to _that_ zone:\r\n\r\n```js\r\nvar specifyOffsetAndOverrideZone = DateTime.fromISO(\"2017-05-15T09:10:23-09:00\", {\r\n  zone: \"Europe/Paris\"\r\n});\r\n\r\nspecifyOffsetAndOverrideZone.zoneName; //=> 'Europe/Paris'\r\nspecifyOffsetAndOverrideZone.toString(); //=> '2017-05-15T20:10:23.000+02:00'\r\n```\r\n\r\n### setZone\r\n\r\nFinally, some parsing functions allow you to \"keep\" the zone in the string as the DateTime's zone. Note that if only an offset is provided by the string, the zone will be a fixed-offset one, since Luxon doesn't know which zone is meant, even if you do.\r\n\r\n```js\r\nvar keepOffset = DateTime.fromISO(\"2017-05-15T09:10:23-09:00\", { setZone: true });\r\n\r\nkeepOffset.zoneName; //=> 'UTC-9'\r\nkeepOffset.toString(); //=> '2017-05-15T09:10:23.000-09:00'\r\n\r\nvar keepZone = DateTime.fromFormat(\"2017-05-15T09:10:23 Europe/Paris\", \"yyyy-MM-dd'T'HH:mm:ss z\", {\r\n  setZone: true\r\n});\r\n\r\nkeepZone.zoneName; //=> 'Europe/Paris'\r\nkeepZone.toString(); //=> '2017-05-15T09:10:23.000+02:00'\r\n```\r\n\r\n## Changing zones\r\n\r\n### setZone\r\n\r\nLuxon objects are immutable, so when we say \"changing zones\" we really mean \"creating a new instance with a different zone\". Changing zone generally means \"change the zone in which this DateTime is expressed (and according to which rules it is manipulated), but don't change the underlying timestamp.\" For example:\r\n\r\n```js\r\nvar local = DateTime.local();\r\nvar rezoned = local.setZone(\"America/Los_Angeles\");\r\n\r\n// different local times with different offsets\r\nlocal.toString(); //=> '2017-09-13T18:30:51.141-04:00'\r\nrezoned.toString(); //=> '2017-09-13T15:30:51.141-07:00'\r\n\r\n// but actually the same time\r\nlocal.valueOf() === rezoned.valueOf(); //=> true\r\n```\r\n\r\n### keepLocalTime\r\n\r\nGenerally, it's best to think of the zone as a sort of metadata that you slide around independent of the underlying count of milliseconds. However, sometimes that's not what you want. Sometimes you want to change zones while keeping the local time fixed and instead altering the timestamp. Luxon supports this:\r\n\r\n```js\r\nvar local = DateTime.local();\r\nvar rezoned = local.setZone(\"America/Los_Angeles\", { keepLocalTime: true });\r\n\r\nlocal.toString(); //=> '2017-09-13T18:36:23.187-04:00'\r\nrezoned.toString(); //=> '2017-09-13T18:36:23.187-07:00'\r\n\r\nlocal.valueOf() === rezoned.valueOf(); //=> false\r\n```\r\n\r\nIf you find that confusing, I recommend just not using it. On the other hand, if you find yourself using this all the time, you are probably doing something wrong.\r\n\r\n## Accessors\r\n\r\nLuxon DateTimes have a few different accessors that let you find out about the zone and offset:\r\n\r\n```js\r\nvar dt = DateTime.local();\r\n\r\ndt.zoneName; //=> 'America/New_York'\r\ndt.offset; //=> -240\r\ndt.offsetNameShort; //=> 'EDT'\r\ndt.offsetNameLong; //=> 'Eastern Daylight Time'\r\ndt.isOffsetFixed; //=> false\r\ndt.isInDST; //=> true\r\n```\r\n\r\nThose are all documented in the [DateTime API docs](../class/src/datetime.js~DateTime.html).\r\n\r\n## DST weirdness\r\n\r\nBecause our ancestors were morons, they opted for a system wherein many governments shift around the local time twice a year for no good reason. And it's not like they do it in a neat, coordinated fashion. No, they do it whimsically, varying the shifts' timing from country to country (or region to region!) and from year to year. And of course, they do it the opposite way south of the Equator. This is all a tremendous waste of everyone's energy and, er, time, but it is how the world works and a date and a time library has to deal with it.\r\n\r\nMost of the time, DST shifts will happen without you having to do anything about it and everything will just work. Luxon goes to some pains to make DSTs as unweird as possible. But there are exceptions. This section covers them.\r\n\r\n### Invalid times\r\n\r\nSome local times simply don't exist. The Spring Forward DST shift involves shifting the local time forward by (usually) one hour. In my zone, `America/New_York`, on March 12, 2017 the millisecond after 1:59:59.999 is 3:00:00.000. Thus the times between 2:00:00.000 and 2:59:59.000, inclusive, don't exist in that zone. But of course, nothing stops a user from constructing a DateTime out of that local time.\r\n\r\nIf you create such a DateTime from scratch, the missing time will be advanced by an hour:\r\n\r\n```js\r\nDateTime.local(2017, 3, 12, 2, 30).toString(); //=> '2017-03-12T03:30:00.000-04:00'\r\n```\r\n\r\nYou can also do date math that lands you in the middle of the shift. These also push forward:\r\n\r\n```js\r\nDateTime.local(2017, 3, 11, 2, 30)\r\n  .plus({ days: 1 })\r\n  .toString(); //=> '2017-03-12T03:30:00.000-04:00'\r\nDateTime.local(2017, 3, 13, 2, 30)\r\n  .minus({ days: 1 })\r\n  .toString(); //=> '2017-03-12T03:30:00.000-04:00'\r\n```\r\n\r\n### Ambiguous times\r\n\r\nHarder to handle are ambiguous times. During Fall Back, some local times happen twice. In my zone, `America/New_York`, on November 5, 2017 the millisecond after 1:59:59.000 became 1:00:00.000. But of course there was already a 1:00 that day, one hour before before this one. So if you create a DateTime with a local time of 1:30, which time do you mean? It's an important question, because they correspond to different moments in time.\r\n\r\nHowever, Luxon's behavior here is undefined. It makes no promises about which of the two possible timestamps the instance will represent. Currently, its specific behavior is like this:\r\n\r\n```js\r\nDateTime.local(2017, 11, 5, 1, 30).offset / 60; //=> -4\r\nDateTime.local(2017, 11, 4, 1, 30).plus({ days: 1 }).offset / 60; //=> -4\r\nDateTime.local(2017, 11, 6, 1, 30).minus({ days: 1 }).offset / 60; //=> -5\r\n```\r\n\r\nIn other words, sometimes it picks one and sometimes the other. Luxon doesn't guarantee the specific behavior above. That's just what it happens to do.\r\n\r\nIf you're curious, this lack of definition is because Luxon doesn't actually know that any particular DateTime is an ambiguous time. It doesn't know the time zones rules at all. It just knows the local time does not contradict the offset and leaves it at that. To find out the time is ambiguous and define exact rules for how to resolve it, Luxon would have to test nearby times to see if it can find duplicate local time, and it would have to do that on every creation of a DateTime, regardless of whether it was anywhere near a real DST shift. Because that's onerous, Luxon doesn't bother.\r\n\r\n### Math across DSTs\r\n\r\nThere's a whole [section](math.html) about date and time math, but it's worth highlighting one thing here: when Luxon does math across DSTs, it adjusts for them when working with higher-order, variable-length units like days, weeks, months, and years. When working with lower-order, exact units like hours, minutes, and seconds, it does not. For example, DSTs mean that days are not always the same length: one day a year is (usually) 23 hours long and another is 25 hours long. Luxon makes sure that adding days takes that into account. On the other hand, an hour is always 3,600,000 milliseconds.\r\n\r\nAn easy way to think of it is that if you add a day to a DateTime, you should always get the same time the next day, regardless of any intervening DSTs. On the other hand, adding 24 hours will result in DateTime that is 24 hours later, which may or may not be the same time the next day. In this example, my zone is `America/New_York`, which had a Spring Forward DST in the early hours of March 12.\r\n\r\n```js\r\nvar start = DateTime.local(2017, 3, 11, 10);\r\nstart.hour; //=> 10, just for comparison\r\nstart.plus({ days: 1 }).hour; //=> 10, stayed the same\r\nstart.plus({ hours: 24 }).hour; //=> 11, DST pushed forward an hour\r\n```\r\n\r\n## Changing the default zone\r\n\r\nBy default, Luxon creates DateTimes in the system's local zone. However, you can override this behavior globally:\r\n\r\n```js\r\nSettings.defaultZoneName = \"Asia/Tokyo\";\r\nDateTime.local().zoneName; //=> 'Asia/Tokyo'\r\n\r\nSettings.defaultZoneName = \"utc\";\r\nDateTime.local().zoneName; //=> 'UTC'\r\n\r\n// you can reset by setting to 'local'\r\n\r\nSettings.defaultZoneName = \"local\";\r\nDateTime.local().zoneName; //=> 'America/New_York'\r\n```\r\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/isaac/code/luxon/docs/calendars.md",
    "name": "./docs/calendars.md",
    "content": "# Calendars\r\n\r\nThis covers Luxon's support for various calendar systems. If you don't need to use non-standard calendars, you don't need to read any of this.\r\n\r\n## Fully supported calendars\r\n\r\nLuxon has full support for Gregorian and ISO Week calendars. What I mean by that is that Luxon can parse dates specified in those calendars, format dates into strings using those calendars, and transform dates using the units of those calendars. For example, here is Luxon working directly with an ISO calendar:\r\n\r\n```js\r\nDateTime.fromISO('2017-W23-3').plus({ weeks: 1, days: 2 }).toISOWeekDate(); //=>  '2017-W24-5'\r\n```\r\n\r\nThe main reason I bring all this is up is to contrast it with the capabilities for other calendars described below.\r\n\r\n## Output calendars\r\n\r\nLuxon has limited support for other calendaring systems. Which calendars are supported at all is a platform-dependent, but can generally be expected to be these: Buddhist, Chinese, Coptic, Ethioaa, Ethiopic, Hebrew, Indian, Islamic, Islamicc, Japanese, Persian, and ROC. **Support is limited to formatting strings with them**, hence the qualified name \"output calendar\".\r\n\r\nIn practice this is pretty useful; you can show users the date in their preferred calendaring system while the software works with dates using Gregorian units or Epoch milliseconds. But the limitations are real enough; Luxon doesn't know how to do things like \"add one Islamic month\".\r\n\r\nThe output calendar is a property of the DateTime itself. For example:\r\n\r\n```js\r\nvar dtHebrew = DateTime.local().reconfigure({ outputCalendar: 'hebrew' })\r\ndtHebrew.outputCalendar; //=> 'hebrew'\r\ndtHebrew.toLocaleString() //=> '4 Tishri 5778'\r\n```\r\n\r\nYou can modulate the structure of that string with arguments to `toLocaleString` (see [the docs on that](formatting.html#tolocalestring-strings-for-humans-)), but the point here is just that you got the alternative calendar.\r\n\r\n### Generally supported calendars\r\n\r\nHere's a table of the different calendars with examples generated formatting the same date generated like this:\r\n\r\n```js\r\nDateTime.fromObject({ outputCalendar: c }).toLocaleString(DateTime.DATE_FULL);\r\n```\r\n\r\n| Calendar | Example                  |\r\n| ---      | ---                      |\r\n| buddhist | September 24, 2560 BE    |\r\n| chinese  | Eighth Month 5, 2017     |\r\n| coptic   | Tout 14, 1734 ERA1       |\r\n| ethioaa  | Meskerem 14, 7510 ERA0   |\r\n| ethiopic | Meskerem 14, 2010 ERA1   |\r\n| hebrew   | 4 Tishri 5778            |\r\n| indian   | Asvina 2, 1939 Saka      |\r\n| islamic  | Muharram 4, 1439 AH      |\r\n| islamicc | Muharram 3, 1439 AH      |\r\n| japanese | September 24, 29 Heisei  |\r\n| persian  | Mehr 2, 1396 AP          |\r\n| roc      | September 24, 106 Minguo |\r\n\r\n\r\n### Default output calendar\r\n\r\nYou can set the default output calendar for new DateTime instances like this:\r\n\r\n```js\r\nSettings.defaultOuputCalendar = 'persian';\r\n```\r\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/isaac/code/luxon/docs/formatting.md",
    "name": "./docs/formatting.md",
    "content": "# Formatting\r\n\r\nThis section covers creating strings to represent a DateTime. There are three types of formatting capabilities:\r\n\r\n1.  Technical formats like ISO 8601 and RFC 2822\r\n2.  Internationalizable human-readable formats\r\n3.  Token-based formatting\r\n\r\n## Technical formats (strings for computers)\r\n\r\n### ISO 8601\r\n\r\n[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) is the most widely used set of string formats for dates and times. Luxon can _parse_ a wide range of them, but provides direct support for formatting only a few of them:\r\n\r\n```js\r\ndt.toISO(); //=> '2017-04-20T11:32:00.000-04:00'\r\ndt.toISODate(); //=> '2017-04-20'\r\ndt.toISOWeekDate(); //=> '2017-W17-7'\r\ndt.toISOTime(); //=> '11:32:00.000-04:00'\r\n```\r\n\r\nGenerally, you'll want the first one. Use it by default when building or interacting with APIs, communicating times over a wire, etc.\r\n\r\n### HTTP and RFC 2822\r\n\r\nThere are a number of legacy standard date and time formats out there, and Luxon supports some of them. You shouldn't use them unless you have a specific reason to.\r\n\r\n```js\r\ndt.toRFC2822(); //=> 'Thu, 20 Apr 2017 11:32:00 -0400'\r\ndt.toHTTP(); //=> 'Thu, 20 Apr 2017 03:32:00 GMT'\r\n```\r\n\r\n### Unix timestamps\r\n\r\nDateTime objects can also be converted to numerical [Unix timestamps](https://en.wikipedia.org/wiki/Unix_time):\r\n\r\n```js\r\ndt.toMillis(); //=> 1492702320000\r\ndt.toSeconds(); //=> 1492702320\r\ndt.valueOf(); //=> 1492702320000, same as .toMillis()\r\n```\r\n\r\n## toLocaleString (strings for humans)\r\n\r\n### The basics\r\n\r\nModern browsers (and other JS environments) provide support for human-readable, internationalized strings. Luxon provides convenient support for them, and you should use them anytime you want to display a time to a user. Use [toLocaleString](../class/src/datetime.js~DateTime.html#instance-method-toLocaleString) to do it:\r\n\r\n```js\r\ndt.toLocaleString(); //=> '4/20/2017'\r\ndt.toLocaleString(DateTime.DATETIME_FULL); //=> 'April 20, 2017, 11:32 AM EDT'\r\ndt.setLocale('fr').toLocaleString(DateTime.DATETIME_FULL); //=> '20 avril 2017  11:32 UTC4'\r\n```\r\n\r\n### Intl.DateTimeFormat\r\n\r\nIn the example above, `DateTime.DATETIME_FULL` is one of several convenience formats provided by Luxon. But the arguments are really any object of options that can be provided to [Intl.DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat). For example:\r\n\r\n```js\r\ndt.toLocaleString({ month: 'long', day: 'numeric' }); //=> 'April 20'\r\n```\r\n\r\nAnd that's all the preset is:\r\n\r\n```\r\nDateTime.DATETIME_FULL;  //=> {\r\n                         //     year: 'numeric',\r\n                         //     month: 'long',\r\n                         //     day: 'numeric',\r\n                         //     hour: 'numeric',\r\n                         //     minute: '2-digit',\r\n                         //     timeZoneName: 'short'\r\n                         //   }\r\n```\r\n\r\nThis also means you can modify the presets as you choose:\r\n\r\n```js\r\ndt.toLocaleString(DateTime.DATE_SHORT); //=>  '4/20/2017'\r\nvar newFormat = Object.assign({ weekday: 'long' }, DateTime.DATE_SHORT);\r\ndt.toLocaleString(newFormat); //=>  'Thursday, 4/20/2017'\r\n```\r\n\r\n### Presets\r\n\r\nHere's the full set of provided presets using the October 14, 1983 at 13:30:23 as an example.\r\n\r\n| Name                        | Description                                                        | Example in en_US                                           | Example in fr                                            |\r\n| --------------------------- | ------------------------------------------------------------------ | ---------------------------------------------------------- | -------------------------------------------------------- |\r\n| DATE_SHORT                  | short date                                                         | 10/14/1983                                                 | 14/10/1983                                               |\r\n| DATE_MED                    | abbreviated date                                                   | Oct 14, 1983                                               | 14 oct. 1983                                             |\r\n| DATE_FULL                   | full date                                                          | October 14, 1983                                           | 14 octobre 1983                                          |\r\n| DATE_HUGE                   | full date with weekday                                             | Tuesday, October 14, 1983                                  | vendredi 14 octobre 1983                                 |\r\n| TIME_SIMPLE                 | time                                                               | 1:30 PM                                                    | 13:30                                                    |\r\n| TIME_WITH_SECONDS           | time with seconds                                                  | 1:30:23 PM                                                 | 13:30:23                                                 |\r\n| TIME_WITH_SHORT_OFFSET      | time with seconds and abbreviated named offset                     | 1:30:23 PM EDT                                             | 13:30:23 UTC4                                           |\r\n| TIME_WITH_LONG_OFFSET       | time with seconds and full named offset                            | 1:30:23 PM Eastern Daylight Time                           | 13:30:23 heure dt de lEst                            |\r\n| TIME_24_SIMPLE              | 24-hour time                                                       | 13:30                                                      | 13:30                                                    |\r\n| TIME_24_WITH_SECONDS        | 24-hour time with seconds                                          | 13:30:23                                                   | 13:30:23                                                 |\r\n| TIME_24_WITH_SHORT_OFFSET   | 24-hour time with seconds and abbreviated named offset             | 13:30:23 EDT                                               | 13:30:23 UTC4                                           |\r\n| TIME_24_WITH_LONG_OFFSET    | 24-hour time with seconds and full named offset                    | 13:30:23 Eastern Daylight Time                             | 13:30:23 heure dt de lEst                            |\r\n| DATETIME_SHORT              | short date & time                                                  | 10/14/1983, 1:30 PM                                        | 14/10/1983  13:30                                       |\r\n| DATETIME_MED                | abbreviated date & time                                            | Oct 14, 1983, 1:30 PM                                      | 14 oct. 1983  13:30                                     |\r\n| DATETIME_FULL               | full date and time with abbreviated named offset                   | October 14, 1983, 1:30 PM EDT                              | 14 octobre 1983  13:30 UTC4                            |\r\n| DATETIME_HUGE               | full date and time with weekday and full named offset              | Friday, October 14, 1983, 1:30 PM Eastern Daylight Time    | vendredi 14 octobre 1983  13:30 heure dt de lEst    |\r\n| DATETIME_SHORT_WITH_SECONDS | short date & time with seconds                                     | 10/14/1983, 1:30:23 PM                                     | 14/10/1983  13:30:23                                    |\r\n| DATETIME_MED_WITH_SECONDS   | abbreviated date & time with seconds                               | Oct 14, 1983, 1:30:23 PM                                   | 14 oct. 1983  13:30:23                                  |\r\n| DATETIME_FULL_WITH_SECONDS  | full date and time with abbreviated named offset with seconds      | October 14, 1983, 1:30:23 PM EDT                           | 14 octobre 1983  13:30:23 UTC4                         |\r\n| DATETIME_HUGE_WITH_SECONDS  | full date and time with weekday and full named offset with seconds | Friday, October 14, 1983, 1:30:23 PM Eastern Daylight Time | vendredi 14 octobre 1983  13:30:23 heure dt de lEst |\r\n\r\n### Intl\r\n\r\n`toLocaleString`'s behavior is affected by the DateTime's `locale`, `numberingSystem`, and `outputCalendar` properties. See the [Intl](intl.html) section for more.\r\n\r\n## Formatting with tokens (strings for Cthulhu)\r\n\r\nThis section covers generating strings from DateTimes with programmer-specified formats.\r\n\r\n### Consider alternatives\r\n\r\nYou shouldn't create ad-hoc string formats if you can avoid it. If you intend for a computer to read the string, prefer ISO 8601. If a human will read it, prefer `toLocaleString`. Both are covered above. However, if you have some esoteric need where you need some specific format (e.g. because some other software expects it), then `toFormat` is how you do it.\r\n\r\n### toFormat\r\n\r\nSee [DateTime#toFormat](../class/src/datetime.js~DateTime.html#instance-method-toFormat) for the API signature. As a brief motivating example:\r\n\r\n```js\r\nDateTime.fromISO('2014-08-06T13:07:04.054').toFormat('yyyy LLL dd'); //=> '2014 Aug 06'\r\n```\r\n\r\nThe supported tokens are described in the table below.\r\n\r\n### Intl\r\n\r\nAll of the strings (e.g. month names and weekday names) are internationalized by introspecting strings generated by the Intl API. Thus they exact strings you get are implementation-specific.\r\n\r\n```js\r\nDateTime.fromISO('2014-08-06T13:07:04.054')\r\n  .setLocale('fr')\r\n  .toFormat('yyyy LLL dd'); //=> '2014 aot 06'\r\n```\r\n\r\n### Escaping\r\n\r\nYou may escape strings using single quotes:\r\n\r\n```js\r\nDateTime.local().toFormat(\"HH 'hours and' mm 'minutes'\"); //=> '20 hours and 55 minutes'\r\n```\r\n\r\n### Standalone vs format tokens\r\n\r\nSome tokens have a \"standalone\" and \"format\" version. Some languages require different forms of a word based on whether it is part of a longer phrase or just by itself (e.g. \"Monday the 22nd\" vs \"Monday\"). Use them accordingly.\r\n\r\n```js\r\nvar d = DateTime.fromISO('2014-08-06T13:07:04.054').setLocale('ru');\r\nd.toFormat('LLLL'); //=> '' (standalone)\r\nd.toFormat('MMMM'); //=> '' (format)\r\n```\r\n\r\n### Macro tokens\r\n\r\nSome of the formats are \"macros\", meaning they correspond to multiple components. These use the native Intl API and will order their constituent parts in a locale-friendly way.\r\n\r\n```js\r\nDateTime.fromISO('2014-08-06T13:07:04.054').toFormat('ff'); //=> 'Aug 6, 2014, 1:07 PM'\r\n```\r\n\r\nThe macro options available correspond one-to-one with the preset formats defined for `toLocaleString`.\r\n\r\n### Table of tokens\r\n\r\n(Examples below given for 2014-08-06T13:07:04.054 considered as a local time in America/New_York).\r\n\r\n| Standalone token | Format token | Description                                                    | Example                                                     |\r\n| ---------------- | ------------ | -------------------------------------------------------------- | ----------------------------------------------------------- |\r\n| S                |              | millisecond, no padding                                        | 54                                                          |\r\n| SSS              |              | millisecond, padded to 3                                       | 054                                                         |\r\n| u                |              | fractional seconds, functionally identical to SSS              | 054                                                         |\r\n| s                |              | second, no padding                                             | 4                                                           |\r\n| ss               |              | second, padded to 2 padding                                    | 04                                                          |\r\n| m                |              | minute, no padding                                             | 7                                                           |\r\n| mm               |              | minute, padded to 2                                            | 07                                                          |\r\n| h                |              | hour in 12-hour time, no padding                               | 1                                                           |\r\n| hh               |              | hour in 12-hour time, padded to 2                              | 01                                                          |\r\n| H                |              | hour in 24-hour time, no padding                               | 9                                                           |\r\n| HH               |              | hour in 24-hour time, padded to 2                              | 13                                                          |\r\n| Z                |              | narrow offset                                                  | +5                                                          |\r\n| ZZ               |              | short offset                                                   | +05:00                                                      |\r\n| ZZZ              |              | techie offset                                                  | +0500                                                       |\r\n| ZZZZ             |              | abbreviated named offset                                       | EST                                                         |\r\n| ZZZZZ            |              | unabbreviated named offset                                     | Eastern Standard Time                                       |\r\n| z                |              | IANA zone                                                      | America/New_York                                            |\r\n| a                |              | meridiem                                                       | AM                                                          |\r\n| d                |              | day of the month, no padding                                   | 6                                                           |\r\n| dd               |              | day of the month, padded to 2                                  | 06                                                          |\r\n| c                | E            | day of the week, as number from 1-7 (Monday is 1, Sunday is 7) | 3                                                           |\r\n| ccc              | EEE          | day of the week, as an abbreviate localized string             | Wed                                                         |\r\n| cccc             | EEEE         | day of the week, as an unabbreviated localized string          | Wednesday                                                   |\r\n| ccccc            | EEEEE        | day of the week, as a single localized letter                  | W                                                           |\r\n| L                | M            | month as an unpadded number                                    | 8                                                           |\r\n| LL               | MM           | month as an padded number                                      | 08                                                          |\r\n| LLL              | MMM          | month as an abbreviated localized string                       | Aug                                                         |\r\n| LLLL             | MMMM         | month as an unabbreviated localized string                     | August                                                      |\r\n| LLLLL            | MMMMM        | month as a single localized letter                             | A                                                           |\r\n| y                |              | year, unpadded                                                 | 2014                                                        |\r\n| yy               |              | two-digit year                                                 | 14                                                          |\r\n| yyyy             |              | four- to six- digit year, pads to 4                            | 2014                                                        |\r\n| G                |              | abbreviated localized era                                      | AD                                                          |\r\n| GG               |              | unabbreviated localized era                                    | Anno Domini                                                 |\r\n| GGGGG            |              | one-letter localized era                                       | A                                                           |\r\n| kk               |              | ISO week year, unpadded                                        | 17                                                          |\r\n| kkkk             |              | ISO week year, padded to 4                                     | 2014                                                        |\r\n| W                |              | ISO week number, unpadded                                      | 32                                                          |\r\n| WW               |              | ISO week number, padded to 2                                   | 32                                                          |\r\n| o                |              | ordinal (day of year), unpadded                                | 218                                                         |\r\n| ooo              |              | ordinal (day of year), padded to 3                             | 218                                                         |\r\n| q                |              | quarter, no padding                                            | 3                                                           |\r\n| qq               |              | quarter, padded to 2                                           | 03                                                          |\r\n| D                |              | localized numeric date                                         | 9/4/2017                                                    |\r\n| DD               |              | localized date with abbreviated month                          | Aug 6, 2014                                                 |\r\n| DDD              |              | localized date with full month                                 | August 6, 2014                                              |\r\n| DDDD             |              | localized date with full month and weekday                     | Wednesday, August 6, 2014                                   |\r\n| t                |              | localized time                                                 | 9:07 AM                                                     |\r\n| tt               |              | localized time with seconds                                    | 1:07:04 PM                                                  |\r\n| ttt              |              | localized time with seconds and abbreviated offset             | 1:07:04 PM EDT                                              |\r\n| tttt             |              | localized time with seconds and full offset                    | 1:07:04 PM Eastern Daylight Time                            |\r\n| T                |              | localized 24-hour time                                         | 13:07                                                       |\r\n| TT               |              | localized 24-hour time with seconds                            | 13:07:04                                                    |\r\n| TTT              |              | localized 24-hour time with seconds and abbreviated offset     | 13:07:04 EDT                                                |\r\n| TTTT             |              | localized 24-hour time with seconds and full offset            | 13:07:04 Eastern Daylight Time                              |\r\n| f                |              | short localized date and time                                  | 8/6/2014, 1:07 PM                                           |\r\n| ff               |              | less short localized date and time                             | Aug 6, 2014, 1:07 PM                                        |\r\n| fff              |              | verbose localized date and time                                | August 6, 2014, 1:07 PM EDT                                 |\r\n| ffff             |              | extra verbose localized date and time                          | Wednesday, August 6, 2014, 1:07 PM Eastern Daylight Time    |\r\n| F                |              | short localized date and time with seconds                     | 8/6/2014, 1:07:04 PM                                        |\r\n| FF               |              | less short localized date and time with seconds                | Aug 6, 2014, 1:07:04 PM                                     |\r\n| FFF              |              | verbose localized date and time with seconds                   | August 6, 2014, 1:07:04 PM EDT                              |\r\n| FFFF             |              | extra verbose localized date and time with seconds             | Wednesday, August 6, 2014, 1:07:04 PM Eastern Daylight Time |\r\n| X                |              | unix timestamp in seconds                                      | 1407287224                                                  |\r\n| x                |              | unix timestamp in milliseconds                                 | 1407287224054                                              |\r\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/isaac/code/luxon/docs/parsing.md",
    "name": "./docs/parsing.md",
    "content": "# Parsing\r\n\r\nLuxon is not an NLP tool and isn't suitable for all date parsing jobs. But it can do some parsing:\r\n\r\n1.  Direct support for several well-known formats, including most valid ISO 8601 formats\r\n2.  An ad-hoc parser for parsing specific formats\r\n\r\n## Parsing technical formats\r\n\r\n### ISO 8601\r\n\r\nLuxon supports a wide range of valid ISO 8601 formats through the [fromISO](../class/src/datetime.js~DateTime.html#static-method-fromISO) method.\r\n\r\n```js\r\nDateTime.fromISO('2016-05-25');\r\n```\r\n\r\nAll of these are parsable by `fromISO`:\r\n\r\n```\r\n2016\r\n2016-05\r\n201605\r\n2016-05-25\r\n20160525\r\n2016-05-25T09\r\n2016-05-25T09:24\r\n2016-05-25T09:24:15\r\n2016-05-25T09:24:15.123\r\n2016-05-25T0924\r\n2016-05-25T092415\r\n2016-05-25T092415.123\r\n2016-05-25T09:24:15,123\r\n2016-W21-3\r\n2016W213\r\n2016-W21-3T09:24:15.123\r\n2016W213T09:24:15.123\r\n2016-200\r\n2016200\r\n2016-200T09:24:15.123\r\n09:24\r\n09:24:15\r\n09:24:15.123\r\n09:24:15,123\r\n```\r\n\r\n- In addition, all the times support offset arguments like \"Z\" and \"+06:00\".\r\n- Missing lower-order values are always set to the minimum possible value; i.e. it always parses to a full DateTime. For example, \"2016-05-25\" parses to midnight of that day. \"2016-05\" parses to the first of the month, etc.\r\n- The time is parsed as a local time if no offset is specified, but see the method docs to see your options, and also check out [time zone docs](zones.html) for more details.\r\n\r\n### HTTP and RFC2822\r\n\r\nLuxon also provides parsing for strings formatted according to RFC 2822 and the HTTP header specs (RFC 850 and 1123):\r\n\r\n```js\r\nDateTime.fromRFC2822('Tue, 01 Nov 2016 13:23:12 +0630');\r\nDateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT');\r\nDateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT');\r\n```\r\n\r\n### SQL\r\n\r\nLuxon accepts SQL dates, times, and datetimes, via [fromSQL](../class/src/datetime.js~DateTime.html#static-method-fromSQL):\r\n\r\n```js\r\nDateTime.fromSQL('2017-05-15');\r\nDateTime.fromSQL('2017-05-15 09:24:15');\r\nDateTime.fromSQL('09:24:15');\r\n```\r\n\r\nIt works similarly to `fromISO`, so see above for additional notes.\r\n\r\n### Unix timestamps\r\n\r\nLuxon can parse numerical [Unix timestamps](https://en.wikipedia.org/wiki/Unix_time):\r\n\r\n```js\r\nDateTime.fromMillis(1542674993410);\r\nDateTime.fromSeconds(1542674993);\r\n```\r\n\r\nBoth methods accept the same options, which allow you to specify a timezone, calendar, and/or numbering system.\r\n\r\n\r\n## Ad-hoc parsing\r\n\r\n### Consider alternatives\r\n\r\nYou generally shouldn't use Luxon to parse arbitrarily formatted date strings:\r\n\r\n1.  If the string was generated by a computer for programmatic access, use a standard format like ISO 8601. Then you can parse it using [DateTime.fromISO](../class/src/datetime.js~DateTime.html#static-method-fromISO).\r\n2.  If the string is typed out by a human, it may not conform to the format you specify when asking Luxon to parse it. Luxon is quite strict about the format matching the string exactly.\r\n\r\nSometimes, though, you get a string from some legacy system in some terrible ad-hoc format and you need to parse it.\r\n\r\n### fromFormat\r\n\r\nSee [DateTime.fromFormat](../class/src/datetime.js~DateTime.html#static-method-fromFormat) for the method signature. A brief example:\r\n\r\n```js\r\nDateTime.fromFormat('May 25 1982', 'LLLL dd yyyy');\r\n```\r\n\r\n### Intl\r\n\r\nLuxon supports parsing internationalized strings:\r\n\r\n```js\r\nDateTime.fromFormat('mai 25 1982', 'LLLL dd yyyy', { locale: 'fr' });\r\n```\r\n\r\nNote, however, that Luxon derives the list of strings that can match, say, \"LLLL\" (and their meaning) by introspecting the environment's Intl implementation. Thus the exact strings may in some cases be environment-specific. You also need the Intl API available on the target platform (see the [support matrix](matrix.html)).\r\n\r\n### Limitations\r\n\r\nNot every token supported by `DateTime#toFormat` is supported in the parser. For example, there's no `ZZZZ` or `ZZZZZ` tokens. This is for a few reasons:\r\n\r\n- Luxon relies on natively-available functionality that only provides the mapping in one direction. We can ask what the named offset is and get \"Eastern Standard Time\" but not ask what \"Eastern Standard Time\" is most likely to mean.\r\n- Some things are ambiguous. There are several Eastern Standard Times in different countries and Luxon has no way to know which one you mean without additional information (such as that the zone is America/New_York) that would make EST superfluous anyway. Similarly, the single-letter month and weekday formats (EEEEE) that are useful in displaying calendars graphically can't be parsed because of their ambiguity.\r\n- Luxon doesn't yet support parsing the macro tokens it provides for formatting. This may eventually be addressed.\r\n\r\n### Debugging\r\n\r\nThere are two kinds of things that can go wrong when parsing a string: a) you make a mistake with the tokens or b) the information parsed from the string does not correspond to a valid date. To help you sort that out, Luxon provides a method called [fromFormatExplain](../class/src/datetime.js~DateTime.html#static-method-fromFormatExplain). It takes the same arguments as `fromFormat` but returns a map of information about the parse that can be useful in debugging.\r\n\r\nFor example, here the code is using \"MMMM\" where \"MMM\" was needed. You can see the regex Luxon uses and see that it didn't match anything:\r\n\r\n```js\r\n> DateTime.fromFormatExplain(\"Aug 6 1982\", \"MMMM d yyyy\")\r\n\r\n{ input: 'Aug 6 1982',\r\n  tokens:\r\n   [ { literal: false, val: 'MMMM' },\r\n     { literal: false, val: ' ' },\r\n     { literal: false, val: 'd' },\r\n     { literal: false, val: ' ' },\r\n     { literal: false, val: 'yyyy' } ],\r\n  regex: '(January|February|March|April|May|June|July|August|September|October|November|December)( )(\\\\d\\\\d?)( )(\\\\d{4})',\r\n  matches: {},\r\n  result: {},\r\n  zone: null }\r\n```\r\n\r\nIf you parse something and get an invalid date, the debugging steps are slightly different. Here, we're attempting to parse August 32nd, which doesn't exist:\r\n\r\n```js\r\nvar d = DateTime.fromFormat('August 32 1982', 'MMMM d yyyy');\r\nd.isValid; //=> false\r\nd.invalidReason; //=> 'day out of range'\r\n```\r\n\r\nFor more on validity and how to debug it, see [validity](validity.html). You may find more comprehensive tips there. But as it applies specifically to `fromFormat`, again try `fromFormatExplain`:\r\n\r\n```js\r\n> DateTime.fromFormatExplain(\"August 32 1982\", \"MMMM d yyyy\")\r\n\r\n{ input: 'August 32 1982',\r\n  tokens:\r\n   [ { literal: false, val: 'MMMM' },\r\n     { literal: false, val: ' ' },\r\n     { literal: false, val: 'd' },\r\n     { literal: false, val: ' ' },\r\n     { literal: false, val: 'yyyy' } ],\r\n  regex: '(January|February|March|April|May|June|July|August|September|October|November|December)( )(\\\\d\\\\d?)( )(\\\\d{4})',\r\n  matches: { M: 8, d: 32, y: 1982 },\r\n  result: { month: 8, day: 32, year: 1982 },\r\n  zone: null }\r\n```\r\n\r\nBecause Luxon was able to parse the string without difficulty, the output is a lot richer. And you can see that the \"day\" field is set to 32. Combined with the \"out of range\" explanation above, that should clear up the situation.\r\n\r\n### Table of tokens\r\n\r\n(Examples below given for 2014-08-06T13:07:04.054 considered as a local time in America/New_York). Note that many tokens supported by the [formatter](formatting.md) are **not** supported by the parser. That includes all the \"macro\" formats like \"D\" for \"localized numeric date\".\r\n\r\n| Standalone token | Format token | Description                                                    | Example          |\r\n| ---------------- | ------------ | -------------------------------------------------------------- | ---------------- |\r\n| S                |              | millisecond, no padding                                        | 54               |\r\n| SSS              |              | millisecond, padded to 3                                       | 054              |\r\n| u                |              | fractional seconds, (5 is a half second, 54 is slightly more)  | 54               |\r\n| s                |              | second, no padding                                             | 4                |\r\n| ss               |              | second, padded to 2 padding                                    | 04               |\r\n| m                |              | minute, no padding                                             | 7                |\r\n| mm               |              | minute, padded to 2                                            | 07               |\r\n| h                |              | hour in 12-hour time, no padding                               | 1                |\r\n| hh               |              | hour in 12-hour time, padded to 2                              | 01               |\r\n| H                |              | hour in 24-hour time, no padding                               | 9                |\r\n| HH               |              | hour in 24-hour time, padded to 2                              | 13               |\r\n| Z                |              | narrow offset                                                  | +5               |\r\n| ZZ               |              | short offset                                                   | +05:00           |\r\n| ZZZ              |              | techie offset                                                  | +0500            |\r\n| z                |              | IANA zone                                                      | America/New_York |\r\n| a                |              | meridiem                                                       | AM               |\r\n| d                |              | day of the month, no padding                                   | 6                |\r\n| dd               |              | day of the month, padded to 2                                  | 06               |\r\n| E                | c            | day of the week, as number from 1-7 (Monday is 1, Sunday is 7) | 3                |\r\n| EEE              | ccc          | day of the week, as an abbreviate localized string             | Wed              |\r\n| EEEE             | cccc         | day of the week, as an unabbreviated localized string          | Wednesday        |\r\n| M                | L            | month as an unpadded number                                    | 8                |\r\n| MM               | LL           | month as an padded number                                      | 08               |\r\n| MMM              | LLL          | month as an abbreviated localized string                       | Aug              |\r\n| MMMM             | LLLL         | month as an unabbreviated localized string                     | August           |\r\n| y                |              | year, 1-6 digits, very literally                               | 2014             |\r\n| yy               |              | two-digit year, interpreted as > 1960 (also accepts 4)         | 14               |\r\n| yyyy             |              | four-digit year                                                | 2014             |\r\n| yyyyy            |              | four- to six-digit years                                       | 10340            |\r\n| yyyyyy           |              | six-digit years                                                | 010340           |\r\n| G                |              | abbreviated localized era                                      | AD               |\r\n| GG               |              | unabbreviated localized era                                    | Anno Domini      |\r\n| GGGGG            |              | one-letter localized era                                       | A                |\r\n| kk               |              | ISO week year, unpadded                                        | 17               |\r\n| kkkk             |              | ISO week year, padded to 4                                     | 2014             |\r\n| W                |              | ISO week number, unpadded                                      | 32               |\r\n| WW               |              | ISO week number, padded to 2                                   | 32               |\r\n| o                |              | ordinal (day of year), unpadded                                | 218              |\r\n| ooo              |              | ordinal (day of year), padded to 3                             | 218              |\r\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/isaac/code/luxon/docs/math.md",
    "name": "./docs/math.md",
    "content": "# Math\r\n\r\nThis page covers some oddball topics related to date and time math, which has some quirky corner cases.\r\n\r\n## Calendar math vs time math\r\n\r\n### The basics\r\n\r\nMath with dates and times can be unintuitive to programmers. If it's Feb 13, 2017 and I say \"in exactly one month\", you know I mean March 13. Exactly one month after that is April 13. But because February is a shorter month than March, that means we added a different amount of time in each case. On the other hand, if I said \"30 days from February 13\", you'd try to figure out what day that landed on in March. Here it is in Luxon:\r\n\r\n```js\r\nDateTime.local(2017, 2, 13).plus({ months: 1 }).toISODate() //=> '2017-03-13'\r\n\r\nDateTime.local(2017, 2, 13).plus({ days: 30 }).toISODate() //=> '2017-03-15'\r\n```\r\n\r\nMore generally we can differentiate two modes of math:\r\n\r\n * Calendar math works with higher-order, variable-length units like years and months\r\n * Time math works with lower-order, constant-length units such as hours, minutes, and seconds.\r\n\r\n### Which units use which math?\r\n\r\nThese units use calendar math:\r\n\r\n * **Years** vary because of leap years.\r\n * **Months** vary because they're just different lengths.\r\n * **Days** vary because DST transitions mean some days are 23 or 25 hours long.\r\n * **Quarters** are always three months, but months vary in length so quarters do too.\r\n * **Weeks** are always the same number of days, but days vary so weeks do too.\r\n \r\nThese units use time math:\r\n\r\n * **Hours** are always 60 minutes\r\n * **Minutes** are always 60 seconds\r\n * **Seconds** are always 1000 milliseconds\r\n\r\nDon't worry about leap seconds. Javascript and most other programming environments don't account for them; they just happen as abrupt, invisible changes to the underlying system's time.\r\n\r\n### How to think about calendar math\r\n\r\nIt's best not to think of calendar math as requiring arcane checks on the lengths of intervening periods. Instead, think of them as **adjusting that unit directly and keeping lower order date components constant**. Let's go back to the Feb 13 + 1 month example. If you didn't have Luxon, you would do something like this to accomplish that:\r\n\r\n```js\r\nvar d = new Date('2017-02-13')\r\nd.setMonth(d.getMonth() + 1)\r\nd.toLocaleString() //=> '3/13/2017, 12:00:00 AM'\r\n```\r\n\r\nAnd under the covers, that's more or less what Luxon does too. It doesn't boil the operation down to a milliseconds delta because that's not what's being asked. Instead, it fiddles with what it thinks the date should be and then uses the built-in Gregorian calendar to compute the new timestamp.\r\n\r\n### DSTs\r\n\r\nThere's a whole section about this in the [time zones documentation](zones.html#math-across-dsts). But here's a quick example (Spring Forward is early on March 12 in my time zone):\r\n\r\n```\r\nvar start = DateTime.local(2017, 3, 11, 10);\r\nstart.hour                          //=> 10, just for comparison\r\nstart.plus({days: 1}).hour          //=> 10, stayed the same\r\nstart.plus({hours: 24}).hour        //=> 11, DST pushed forward an hour\r\n```\r\n\r\nSo in adding a day, we kept the hour at 10, even though that's only 23 hours later.\r\n\r\n### Time math\r\n\r\nTime math is different. In time math, we're just adjusting the clock, adding or subtracting from the epoch timestamp. Adding 63 hours is really the same as adding 63 hours' worth of milliseconds. Under the covers, Luxon does this exactly the opposite of how it does calendar math; it boils the operation down to milliseconds, computes the new timestamp, and then computes the date out of that.\r\n\r\n## Math with multiple units\r\n\r\nIt's possible to do math with multiple units:\r\n\r\n```js\r\nDateTime.fromISO('2017-05-15').plus({months: 2, days: 6}).toISODate(); //=> '2017-07-21'\r\n```\r\n\r\nThis isn't as simple as it looks. For example, what should you expect this to do?\r\n\r\n```js\r\nDateTime.fromISO('2017-04-30').plus({months: 1, days: 1}).toISODate();\r\n```\r\n\r\nIf the day is added first, we'll get an intermediate value of May 1. Adding a month to that gives us June 1. But if the month is added first, we'll an intermediate value of May 30 and day after that is May 31. (See \"Calendar math vs time math above if this is confusing.) So the order matters.\r\n\r\nLuxon has a simple rule for this: **math is done from highest order to lowest order**. So the result of the example above is May 31. This rule isn't logically necessary, but it does seem reflect what people mean. Of course, Luxon can't enforce this rule if you do the math in separate operations:\r\n\r\n```js\r\nDateTime.fromISO('2017-04-30').plus({days: 1}).plus({months: 1}).toISODate() //=> '2017-06-01'\r\n```\r\n\r\nIt's not a coincidence that Luxon's interface makes it awkward to do this wrong.\r\n\r\n## Comparing DateTimes\r\n\r\nDateTime implements `#valueOf` to return the epoch timestamp, so you can compare DateTimes with `<`, `>`, `<=`, and `>=`. That lets you find out if one DateTime is after or before another DateTime.\r\n\r\n```js\r\nd1 < d2 // is d1 before d2?\r\n```\r\n\r\nHowever, `===` compares object identity (not a useful concept in a library with immutable types) and `#equals` compares both the time and additional metadata, such as the locale and time zone. If you're only interested in checking the equality of the timestamps, you need to coerce them:\r\n\r\n```js\r\n+d1 === +d2 // are d1 and d2 the same instant in time?\r\n```\r\n\r\nYou may also use `#hasSame` to make more subtle comparisons:\r\n\r\n```js\r\nd1.hasSame(d2, 'millisecond'); // equivalent to `+d1 === +d2`\r\nd1.hasSame(d2, 'minute');       // both DateTimes are in the same minute (and hour, day, month, etc)\r\nd1.hasSame(d2, 'year');         // etc\r\n```\r\n\r\nNote that these are checking against the calendar. For example, if `d1` is in 2017, calling `hasSame` with \"year\" asks if d2 is also in 2017, not whether the DateTimes within a year of each other. For that, you'd need `diff` (see below).\r\n\r\nIf you'd like to compare using a specific unit, you can achieve this by combining `#startOf` and the `#valueOf` comparisions above.\r\n\r\n```js\r\nvar d1 = DateTime.fromISO('2017-04-30');\r\nvar d2 = DateTime.fromISO('2017-04-01');\r\n\r\nd2 < d2                                   //=> true\r\nd2.startOf('year') < d1.startOf('year')   //=> false\r\nd2.startOf('month') < d1.startOf('month') //=> false\r\nd2.startOf('day') < d1.startOf('day')     //=> true\r\n```\r\n\r\n## Duration math\r\n\r\n### Basics\r\n\r\n[Durations](../class/src/duration.js~Duration.html) are quantities of time, like \"3 days and 6 hours\". Luxon has no idea *which* 3 days and 6 hours they represent; it's just how Luxon represents those quantities in abstract, unmoored from the timeline. This is both tremendously useful and occasionally confusing. I'm not going to give a detailed tour of their capabilities here (see the API docs for that), but I do want to clear up some of those confusions.\r\n\r\nHere's some very basic stuff to get us going:\r\n\r\n```js\r\nvar dur = Duration.fromObject({ days: 3, hours: 6})\r\n\r\n// examine it\r\ndur.toObject()          //=> { days: 3, hours: 6 }\r\n\r\n// express in minutes\r\ndur.as('minutes')       //=> 4680\r\n\r\n// convert to minutes\r\ndur.shiftTo('minutes').toObject() //=> { minutes: 4680 }\r\n\r\n// add to a DateTime\r\nDateTime.fromISO(\"2017-05-15\").plus(dur).toISO() //=> '2017-05-18T06:00:00.000-04:00'\r\n```\r\n\r\n### Diffs\r\n\r\nYou can subtract one time from another to find out how much time there is between them. Luxon's [diff](../class/src/datetime.js~DateTime.html#instance-method-diff) method does this and it returns a Duration. For example:\r\n\r\n```js\r\nvar end = DateTime.fromISO('2017-03-13');\r\nvar start = DateTime.fromISO('2017-02-13');\r\n\r\nvar diffInMonths = end.diff(start, 'months');\r\ndiffInMonths.toObject(); //=> { months: 1 }\r\n```\r\n\r\nNotice we had to pick the unit to keep track of the diff in. The default is milliseconds:\r\n\r\n```js\r\nvar diff = end.diff(start);\r\ndiff.toObject() //=> { milliseconds: 2415600000 }\r\n```\r\n\r\nFinally, you can diff using multiple units:\r\n\r\n```js\r\nvar end = DateTime.fromISO('2017-03-13');\r\nvar start = DateTime.fromISO('2017-02-15');\r\nend.diff(start, ['months', 'days']) //=> { months: 1, days: 2 }\r\n```\r\n\r\n### Casual vs longterm conversion accuracy\r\n\r\nDurations represent bundles of time with specific units, but Luxon allows you to convert between them:\r\n\r\n * `shiftTo` returns a new Duration denominated in the specified units.\r\n * `as` converts the duration to just that unit and returns its value\r\n\r\n```js\r\nvar dur = Duration.fromObject({ months: 4, weeks: 2, days: 6 })\r\n\r\ndur.as('days')                            //=> 140\r\ndur.shiftTo('days').toObject()            //=> { days: 140 }\r\ndur.shiftTo('weeks', 'hours').toObject()  //=> { weeks: 18, hours: 144 }\r\n```\r\n\r\nBut how do those conversions actually work? First, uncontroversially:\r\n\r\n * 1 week = 7 days\r\n * 1 day = 24 hours\r\n * 1 hour = 60 minutes\r\n * 1 minute = 60 seconds\r\n * 1 second = 1000 milliseconds\r\n \r\nThese are always true and you can roll them up and down with consistency (e.g. `1 hour = 60 * 60 * 1000 milliseconds`). However, this isn't really true for the higher order units, which vary in length, even putting DSTs aside. A year is sometimes 365 days long and sometimes 366. Months are 28, 29, 30, or 31 days. By default Luxon converts between these units using what you might call \"casual\" conversions:\r\n\r\n|         | Month | Week | Day |\r\n| ---     | ---   |  --- | --- |\r\n| Year    | 12    |   52 | 365 |\r\n| Quarter | 3     |   13 |  91 |\r\n| Month   |       |    4 |  30 |\r\n\r\nThese should match your intuition and for most purposes they work well. But they're not just wrong; they're not even self-consistent:\r\n\r\n```js\r\ndur.shiftTo('months').shiftTo('days').as('years') //=> 0.9863013698630136\r\n```\r\n\r\nThis is because 12 * 30 != 365. These errors can be annoying, but they can also cause significant issues if the errors accumulate:\r\n\r\n```js\r\nvar dur = Duration.fromObject({ years: 50000 });\r\nDateTime.local().plus(dur.shiftTo('milliseconds')).year //=> 51984\r\nDateTime.local().plus(dur).year                         //=> 52017\r\n```\r\n\r\nThose are 33 years apart! So Luxon offers an alternative conversion scheme called \"longterm\", based on the 400-year calendar cycle:\r\n\r\n|         | Month |     Week |       Day |\r\n|----     | ---   |      --- |       --- |\r\n| Year    | 12    |  52.1775 |  365.2425 |\r\n| Quarter |  3    | 13.04435 | 91.310625 |\r\n| Month   |       | 4.348125 | 30.436875 |\r\n\r\nYou can see why these are irritating to work with, which is why they're not the default.\r\n\r\nLuxon methods that create Durations de novo accept an option called `conversionAccuracy`. You can set it to \"casual\" or \"longterm\". It's a property of the Duration itself, so any conversions you do use the rule you've picked, and any new Durations you derive from it will retain that property.\r\n\r\n```js\r\nDuration.fromObject({ years: 23, conversionAccuracy: 'longterm' });\r\nDuration.fromISO('PY23', { conversionAccuracy: 'longterm' });\r\n\r\nend.diff(start, 'days', { conversionAccuracy: 'longterm' })\r\n```\r\n\r\nYou can also create an accurate Duration out of an existing one:\r\n\r\n```js\r\nvar pedanticDuration = casualDuration.reconfigure({ conversionAccuracy: 'longterm' });\r\n```\r\n\r\nThese Durations will do their conversions differently.\r\n\r\n\r\n### Losing information\r\n\r\nBe careful of converting between units. It's easy to lose information. Let's say we converted a diff into days:\r\n\r\n\r\n```js\r\nvar end = DateTime.fromISO('2017-03-13');\r\nvar start = DateTime.fromISO('2017-02-13');\r\ndiffInMonths.as('days'); //=> 30\r\n```\r\n\r\nThat's our conversion between months and days (you could also do a longterm-accurate conversion; it wouldn't fix the issue ahead). But this isn't the number of days between February 15 and March 15!\r\n\r\n```js\r\nvar diffInDays = end.diff(start, 'days');\r\ndiffInDays.toObject(); //=> { days: 28 }\r\n```\r\n\r\nIt's important to remember that diffs are Duration objects, and a Duration is just a dumb pile of time units our computation spat out. Unlike an Interval, a Duration doesn't \"remember\" what the inputs to the diff were. So we lost some information converting between units. This mistake is really common when rolling up:\r\n\r\n\r\n```js\r\nvar diff = end.diff(start) // default unit is milliseconds\r\n\r\n// wtf, that's not a month!\r\ndiff.as('months'); //=> 0.9319444 \r\n\r\n// it's not even the right number of days! (hint: my time zone has a DST)\r\ndiff.shiftTo('hours').as('days'); //=> 27.958333333333332\r\n```\r\n\r\nNormally you won't run into this problem if you think clearly about what you want to do with a diff. But sometimes you really do want an object that represents the subtraction itself, not the result. [Intervals](../class/src/interval.js~Interval.html) can help. Intervals are mostly used to keep track of ranges of time, but they make for \"anchored\" diffs too. For example:\r\n\r\n```js\r\nvar end = DateTime.fromISO('2017-03-13');\r\nvar start = DateTime.fromISO('2017-02-13');\r\nvar i = Interval.fromDateTimes(start, end);\r\n\r\ni.length('days');       //=> 28\r\ni.length('months')      //=> 1\r\n```\r\n\r\nBecause the Interval stores its endpoints and computes `length` on the fly, it retakes the diff each time you query it. Of course, precisely because an Interval *isn't* an abstract bundle of time, it can't be used in places where Durations can. For example, you can't add them to DateTime via `plus()` because Luxon wouldn't know what units to do the math in (see \"Calendar vs time math\" above). But you can convert the interval into a Duration by picking the units:\r\n\r\n```js\r\ni.toDuration('months').toObject(); //=> { months: 1 }\r\ni.toDuration('days').toObject(); //=> { days: 28 }\r\n```\r\n\r\nYou can even pick multiple units:\r\n\r\n```js\r\nend = DateTime.fromISO('2018-05-25');\r\ni = start.until(end);\r\ni.toDuration(['years', 'months', 'days']).toObject(); //=> { years: 1, months: 3, days: 12 }\r\n```\r\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/isaac/code/luxon/docs/validity.md",
    "name": "./docs/validity.md",
    "content": "# Validity\r\n\r\n## Invalid DateTimes\r\n\r\nOne of the most irritating aspects of programming with time is that it's possible to end up with invalid dates. This is a bit subtle: barring integer overflows, there's no count of milliseconds that don't correspond to a valid DateTime, but when working with calendar units, it's pretty easy to say something like \"June 400th\". Luxon considers that invalid and will mark it accordingly.\r\n\r\nUnless you've asked Luxon to throw an exception when it creates an invalid DateTime (see more on that below), it will fail silently, creating an instance that doesn't know how to do anything. You can check validity with `isValid`:\r\n\r\n```js\r\n> var dt = DateTime.fromObject({ month: 6, day: 400 });\r\ndt.isValid //=> false\r\n```\r\n\r\nAll of the methods or getters that return primitives return degenerate ones:\r\n\r\n```js\r\ndt.year; //=>  NaN\r\ndt.toString(); //=> 'Invalid DateTime'\r\ndt.toObject(); //=> {}\r\n```\r\n\r\nMethods that return other Luxon objects will return invalid ones:\r\n\r\n```js\r\ndt.plus({ days: 4 }).isValid; //=> false\r\n```\r\n\r\n## Reasons a DateTimes can be invalid\r\n\r\nThe most common way to do that is to over- or underflow some unit:\r\n\r\n- February 40th\r\n- 28:00\r\n- -4 pm\r\n- etc\r\n\r\nBut there are other ways to do it:\r\n\r\n```js\r\n// specify a time zone that doesn't exist\r\nDateTime.local().setZone(\"America/Blorp\").isValid; //=> false\r\n\r\n// provide contradictory information (here, this date is not a Wedensday)\r\nDateTime.fromObject({ year: 2017, month: 5, day: 25, weekday: 3 }).isValid; //=> false\r\n```\r\n\r\nNote that some other kinds of mistakes throw, based on our judgment that they are more likely programmer errors than data issues:\r\n\r\n```js\r\nDateTime.local().set({ blorp: 7 }); //=> kerplosion\r\n```\r\n\r\n## Debugging invalid DateTimes\r\n\r\nBecause DateTimes fail silently, they can be a pain to debug. Luxon has some features that can help.\r\n\r\n### invalidReason and invalidExplanation\r\n\r\nInvalid DateTime objects are happy to tell you why they're invalid. `invalidReason` will give you a consistent error code you can use, whereas `invalidExplanation` will spell it out\r\n\r\n```js\r\nvar dt = DateTime.local().setZone(\"America/Blorp\");\r\ndt.invalidReason; //=>  'unsupported zone'\r\ndt.invalidExplantion; //=> 'the zone \"America/Blorp\" is not supported'\r\n```\r\n\r\n### throwOnInvalid\r\n\r\nYou can make Luxon throw whenever it creates an invalid DateTime. The message will combine `invalidReason` and `invalidExplanation`:\r\n\r\n```js\r\nSettings.throwOnInvalid = true;\r\nDateTime.local().setZone(\"America/Blorp\"); //=> Error: Invalid DateTime: unsupported zone: the zone \"America/Blorp\" is not supported\r\n```\r\n\r\nYou can of course leave this on in production too, but be sure to try/catch it appropriately.\r\n\r\n## Invalid Durations\r\n\r\nDurations can be invalid too. The easiest way to get one is to diff an invalid DateTime.\r\n\r\n```js\r\nDateTime.local(2017, 28).diffNow().isValid; //=> false\r\n```\r\n\r\n## Invalid Intervals\r\n\r\nIntervals can be invalid. This can happen a few different ways:\r\n\r\n- The end time is before the start time\r\n- It was created from invalid DateTime or Duration\r\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/isaac/code/luxon/docs/matrix.md",
    "name": "./docs/matrix.md",
    "content": "# Support matrix\r\n\r\nThis page covers what platforms are supported by Luxon and what caveats apply to them.\r\n\r\n## Official support\r\n\r\nLuxon officially supports the last two versions of the major browsers, with some caveats. The table below shows which of the not-universally-supported features are available in what environments.\r\n\r\n| Browser                          | Versions | Zones | Intl basics | Intl tokens | Intl relative time formatting |\r\n| -------------------------------- | -------- | ----- | ----------- | ----------- | ----------------------------- |\r\n| Chrome                           | >= 71    |      |            |            |                              |\r\n|                                  | >= 54    |      |            |            |                              |\r\n| Firefox                          | >= 65    |      |            |            |                              |\r\n| Edge                             | 18       |      |            |            |                              |\r\n|                                  | 16       |      |            |            |                              |\r\n| IE                               | 11       |      |            |            |                              |\r\n|                                  | 10       |      |            |            |                              |\r\n| Safari                           | 11       |      |            |            |                              |\r\n|                                  | 10       |      |            |            |                              |\r\n| iOS Safari (iOS version numbers) | >= 11    |      |            |            |                              |\r\n|                                  | 10       |      |            |            |                              |\r\n|                                  | 9        |      |            |            |                              |\r\n| Node w/ICU                       | >= 8     |      |            |            |                              |\r\n|                                  | 6        |      |            |            |                              |\r\n| Node w/o ICU                     | >= 8     |      |            |            |                              |\r\n|                                  | 6        |      |            |            |                              |\r\n\r\n- Those capabilities are explained in the next sections, along with possible polyfill options\r\n- \"w/ICU\" refers to providing Node with ICU data. See the [install](install.html#node) for instructions\r\n\r\n## Internet Explorer and platform polyfills\r\n\r\nIf you're supporting IE 10 or 11, you need some polyfills just to make Luxon work at all.\r\n\r\nWith IE 11, you can just add a polyfill like this to get the JS features you need:\r\n\r\n```html\r\n<script src=\"https://cdn.polyfill.io/v2/polyfill.js?features=default,String.prototype.repeat,Array.prototype.find,Array.prototype.findIndex,Math.trunc,Math.sign\"></script>\r\n```\r\n\r\nThat hasn't checked off the other boxes in the chart above though, so keep reading for those.\r\n\r\nWith IE 10, you have the same problems as IE 11, except that you don't even get basic Intl support. You'll need to tack on the languages you wish to support. See the Basic Internationalization polyfill section below.\r\n\r\nAlternatively, you can use a polyfilled build of Luxon, which you can find here:\r\n\r\n- [Download full polyfilled build](../../global-filled/luxon.js)\r\n- [Download minified polyfilled build](../../global-filled/luxon.min.js)\r\n\r\nThese use global polyfills, though, which means newer browsers will be running the injected code too. And the same doesn't-include-intl-and-zone-support caveats apply to it too.\r\n\r\n## Effects of missing features\r\n\r\n**If the platforms you're targeting has all its boxes above check off, ignore this section**.\r\n\r\nIn the support table above, you can see that some environments are missing capabilities. They affect a subset of Luxon's features that depend on specific APIs that some older browsers don't support.\r\n\r\n1.  **Basic internationalization**. Luxon doesn't have internationalized strings in its code; instead it relies on the hosts implementation of the Intl API. This includes the very handy [toLocaleString](../class/src/datetime.js~DateTime.html#instance-method-toLocaleString). Most browsers and recent versions of Node support this.\r\n2.  **Internationalized tokens**. Listing the months or weekdays of a locale and outputting or parsing ad-hoc formats in non-English locales requires that Luxon be able to programmatically introspect the results of an Intl call. It does this using Intl's [formatToParts](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts) method, which is a relatively recent addition in most browsers. So you could have the Intl API without having that.\r\n3.  **Zones**. Luxon's support of IANA zones works by abusing the Intl API. That means you have to have that API and that the API must support a reasonable list of time zones. Zones are a recent addition to some platforms.\r\n4.  **Relative time formatting**. Luxon's support for relative time formatting (e.g. `DateTime#toRelative` and `DateTime#toRelativeCalendar`) depends on Intl.RelativeTimeFormat, which is currently only available in Chrome and Firefox. Luxon will fall back to using English if that capability is missing.\r\n\r\nIf the browser lacks these capabilities, Luxon tries its best:\r\n\r\n| Feature                                | Full support | No Intl at all                              | Intl but no formatToParts                          | No IANA zone support | No relative time format |\r\n| -------------------------------------- | ------------ | ------------------------------------------- | -------------------------------------------------- | -------------------- | ----------------------- |\r\n| Most things                            | OK           | OK                                          | OK                                                 | OK                   | OK                      |\r\n| Using explicit time zones              | OK           | Invalid DateTime                            | OK                                                 | Invalid DateTime     | OK                      |\r\n| `DateTime#toLocaleString`              | OK           | Uses English with caveats                  | OK                                                 | OK                   | OK                      |\r\n| `DateTime#toLocaleParts`               | OK           | Empty array                                 | Empty array                                        | OK                   | OK                      |\r\n| `DateTime#toFormat` in en-US           | OK           | OK                                          | OK                                                 | OK                   | OK                      |\r\n| `DateTime#toFormat` in other locales   | OK           | Uses English                                | Uses English if format contains localized strings | OK                   | OK                      |\r\n| `DateTime#fromFormat` in en-US         | OK           | OK                                          | OK                                                 | OK                   | OK                      |\r\n| `DateTime#toRelative` in en-US         | OK           | OK                                          | OK                                                 | OK                   | OK                      |\r\n| `DateTime#toRelative` in other locales | Uses English | OK                                          | OK                                                 | OK                   | Uses English            |\r\n| `DateTime#offsetNameShort`, etc        | OK           | Returns null                                | OK in most locales                                | OK                   | OK                      |\r\n| `fromFormat` in other locales          | OK           | Invalid DateTime if uses localized strings | Uses English if format contains localized strings | OK                   | OK                      |\r\n| `Info.months`, etc in en-US            | OK           | OK                                          | OK                                                 | OK                   | OK                      |\r\n| `Info.months`, etc in other locales    | OK           | Uses English                                | Uses English                                       | OK                   | OK                      |\r\n\r\n Specifically, the caveat here is that this English fallback only works as you might expect for Luxon-provided preset arguments, like `DateTime.DATETIME_MED`. If you provide your own, modify the presets, or even clone them, it will use `DateTime.DATETIME_HUGE`. If you don't provide any arguments at all, it defaults to `DateTime.DATE_SHORT`.\r\n\r\n This means that Luxon can't parse anything with a word in it like localized versions of \"January\" or \"Tuesday\". It's fine with numbers, as long as they're Western numbers.\r\n\r\n This fallback uses a hack that is not guaranteed to work in every locale in every browser. It's worked where I tested it, though. It will fall back to returning `null` if it fails.\r\n\r\n## Polyfills\r\n\r\n### Intl\r\n\r\nIf your platform doesn't have any kind of Intl support (such as IE 10), you need to load them individually through a polyfill. The easiest way to that is like this:\r\n\r\n```html\r\n<script src=\"https://cdn.polyfill.io/v2/polyfill.js?features=Intl.~locale.zh,Intl.~locale.fr\"></script>\r\n```\r\n\r\nIf you're on a platform that already needs other polyfills, just tack those features to the end of your polyfill list.\r\n\r\n### Intl tokens\r\n\r\nPolyfilling Intl token support is a bit painful. This limitation applies to Edge < 18 and all the IEs. Fortunately, you probably don't need Intl token support!\r\n\r\nFirst, if you don't have Intl at all (e.g. as in IE 10), you are in luck. The polyfills in the previous section will give you Intl token support too!\r\n\r\nBut more likely, you have basic Intl support but not `formatToParts` (e.g. IE 11 or Edge 16). The problem here is that the polyfill service will ignore the Intl polyfills, so you won't get the support you need. Instead, you need to override all of Intl with the [Intl polyfill](https://github.com/andyearnshaw/Intl.js/) directly. [help wanted: instructions on exactly how to do that]\r\n\r\n### Zones\r\n\r\nIf you have an Intl API (either natively or through the Intl polyfill above) but no zone support, you can add it via the very nice [DateTime format pollyfill](https://github.com/yahoo/date-time-format-timezone).\r\n\r\n## Older platforms\r\n\r\n- **Older versions of both Chrome and Firefox** will most likely work. It's just that I only officially support the last two versions. As you get to older versions of these browsers, the missing capabilities listed above begin to apply to them. (e.g. FF started supporting `formatToParts` in 51 and time zones in 52). I haven't broken that out because it's complicated, Luxon doesn't officially support them, and no one runs them anyway.\r\n- **Older versions of IE** probably won't work at all.\r\n- **Older versions of Node** probably won't work without recompiling Luxon with a different Node target. In which case they'll work with some features missing.\r\n\r\n## Other platforms\r\n\r\nIf the platform you're targeting isn't on the list and you're unsure what caveats apply, you can check which pieces are supported:\r\n\r\n```js\r\nInfo.features(); //=> { intl: true, intlTokens: true, zones: true, relative: false }\r\n```\r\n\r\nSpecific notes on other platforms:\r\n\r\n- **React Native on (specifically) Android** doesn't come with Intl support, so all the possible-to-be-missing capabilities above are unavailable. Use [jsc-android-buildscripts](https://github.com/SoftwareMansion/jsc-android-buildscripts) to fix it.\r\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/isaac/code/luxon/docs/moment.md",
    "name": "./docs/moment.md",
    "content": "# For Moment users\r\n\r\nLuxon borrows lots of ideas from [Moment.js](http://momentjs.com), but there are a lot of differences too. This document clarifies what they are.\r\n\r\n## Immutability\r\n\r\nLuxon's objects are immutable, whereas Moment's are mutable. For example, in Moment:\r\n\r\n```js\r\nvar m1 = moment();\r\nvar m2 = m1.add(1, 'hours');\r\nm1.valueOf() === m2.valueOf(); //=> true\r\n```\r\n\r\nThis happens because `m1` and `m2` are really the same object; `add()` *mutated* the object to be an hour later. Compare that to Luxon:\r\n\r\n```js\r\nvar d1 = DateTime.local();\r\nvar d2 = d1.plus({ hours: 1 });\r\nd1.valueOf() === d2.valueOf(); //=> false\r\n```\r\n\r\nThis happens because the `plus` method returns a new instance, leaving `d1` unmodified. It also means that Luxon doesn't require copy constructors or clone methods.\r\n\r\n## Major functional differences\r\n\r\n1. Months in Luxon are 1-indexed instead of 0-indexed like in Moment and the native Date type.\r\n1. Localizations and time zones are implemented by the native Intl API (or a polyfill of it), instead of by the library itself.\r\n1. Luxon has both a Duration type and an Interval type. The Interval type is like Twix.\r\n1. Luxon lacks the relative time features of Moment and won't support it until the required [facilities](https://github.com/tc39/proposal-intl-relative-time) are provided by the browser.\r\n\r\n## Other API style differences\r\n\r\n1. Luxon methods often take option objects as their last parameter\r\n1. Luxon has different static methods for object creation (e.g. `fromISO`), as opposed to Moment's one function that dispatches based on the input\r\n1. Luxon parsers are very strict, whereas Moment's are more lenient.\r\n1. Luxon uses getters instead of accessor methods, so `dateTime.year` instead of `dateTime.year()`\r\n1. Luxon centralizes its \"setters\", like `dateTime.set({year: 2016, month: 4})` instead of `dateTime.year(2016).month(4)` like in Moment.\r\n1. Luxon's Durations are a separate top-level class.\r\n1. Arguments to Luxon's methods are not automatically coerced into Luxon instances. E.g. `m.diff('2017-04-01')` would be `dt.diff(DateTime.fromISO('2017-04-01'))`.\r\n\r\n## DateTime method equivalence\r\n\r\nHere's a rough mapping of DateTime methods in Moment to ones in Luxon. I haven't comprehensively documented stuff that's in Luxon but not in Moment, just a few odds and ends that seemed obvious for inclusion; there are more. I've probably missed a few things too.\r\n\r\n### Creation\r\n\r\n| Operation               | Moment                   | Luxon                                 | Notes                                                                                                                                 |\r\n| ----------------------- | ------------------------ | ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |\r\n| Now                     | `moment()`               | `DateTime.local()`                    |                                                                                                                                       |\r\n| From ISO                | `moment(String)`         | `DateTime.fromISO(String)`            |                                                                                                                                       |\r\n| From RFC 2822           | `moment(String)`         | `DateTime.fromRFC2822(String)`        |                                                                                                                                       |\r\n| From custom format      | `moment(String, String)` | `DateTime.fromFormat(String, String)` | The format tokens differ between Moment and Luxon, such that the same format string cannot be used between the two.                   |\r\n| From object             | `moment(Object)`         | `DateTime.fromObject(Object)`         |                                                                                                                                       |\r\n| From timestamp          | `moment(Number)`         | `DateTime.fromMillis(Number)`         |                                                                                                                                       |\r\n| From JS Date            | `moment(Date)`           | `DateTime.fromJSDate(Date)`           |                                                                                                                                       |\r\n| From civil time         | `moment(Array)`          | `DateTime.local(Number...)`           | Like `DateTime.local(2016, 12, 25, 10, 30)`                                                                                           |\r\n| From UTC civil time     | `moment.utc(Array)`      | `DateTime.utc(Number...)`             | Moment also uses `moment.utc()` to take other arguments. In Luxon, use the appropriate method and pass in the `{ zone: 'utc'}` option |\r\n| Clone                   | `moment(Moment)`         | N/A                                   | Immutability makes this pointless; just reuse the object                                                                              |\r\n| Use the string's offset | `parseZone`              | See note                              | Methods taking strings that can specify offset or zone take a `setZone` argument                                                      |\r\n\r\n### Getters and setters\r\n\r\n#### Basic information getters\r\n\r\n| Property | Moment      | Luxon     | Notes                                            |\r\n| -------- | ----------- | --------- | ------------------------------------------------ |\r\n| Validity | `isValid()` | `isValid` | See also `invalidReason`                         |\r\n| Locale   | `locale()`  | `locale`  |                                                  |\r\n| Zone     | `tz()`      | `zone`    | Moment requires a plugin for this, but not Luxon |\r\n\r\n#### Unit getters\r\n\r\n| Property               | Moment                               | Luxon         | Notes                                  |\r\n| ---------------------- | ------------------------------------ | ------------- | -------------------------------------- |\r\n| Year                   | `year()`                             | `year`        |                                        |\r\n| Month                  | `month()`                            | `month`       |                                        |\r\n| Day of month           | `date()`                             | `day`         |                                        |\r\n| Day of week            | `day()`, `weekday()`, `isoWeekday()` | `weekday `    | 1-7, Monday is 1, Sunday is 7, per ISO |\r\n| Day of year            | `dayOfYear()`                        | `ordinal `    |                                        |\r\n| Hour of day            | `hour()`                             | `hour`        |                                        |\r\n| Minute of hour         | `minute()`                           | `minute`      |                                        |\r\n| Second of minute       | `second()`                           | `second`      |                                        |\r\n| Millisecond of seconds | `millisecond()`                      | `millisecond` |                                        |\r\n| Week of ISO week year  | `weekYear`, `isoWeekYear`            | `weekYear`    |                                        |\r\n| Quarter                | `quarter`                            | None          | Just divide the months by 4            |\r\n\r\n#### Programmatic get and set\r\n\r\nFor programmatic getting and setting, Luxon and Moment are very similar here:\r\n\r\n| Operation  | Moment                | Luxon         | Notes                                   |\r\n| ---------- | --------------------- | ------------- | --------------------------------------- |\r\n| get value  | `get(String)`         | `get(String)` |                                         |\r\n| set value  | `set(String, Number)` | None          |                                         |\r\n| set values | `set(Object)`         | `set(Object)` | Like `dt.set({ year: 2016, month: 3 })` |\r\n\r\n### Transformation\r\n\r\n| Operation          | Moment                     | Luxon               | Notes                                   |\r\n| ------------------ | -------------------------- | ------------------- | --------------------------------------- |\r\n| Addition           | `add(Number, String)`      | `plus(Object)`      | Like `dt.plus({ months: 3, days: 2 })`  |\r\n| Subtraction        | `subtract(Number, String)` | `minus(Object)`     | Like `dt.minus({ months: 3, days: 2 })` |\r\n| Start of unit      | `startOf(String)`          | `startOf(String)`   |                                         |\r\n| End of unit        | `endOf(String)`            | `endOf(String)`     |                                         |\r\n| Change unit values | `set(Object)`              | `set(Object)`       | Like `dt.set({ year: 2016, month: 3 })` |\r\n| Change time zone   | `tz(String)`               | `setZone(string)`   | Luxon doesn't require a plugin          |\r\n| Change zone to utc | `utc()`                    | `toUTC()`           |                                         |\r\n| Change local zone  | `local()`                  | `toLocal()`         |                                         |\r\n| Change offset      | `utcOffset(Number)`        | None                | Set the zone instead                    |\r\n| Change locale      | `locale(String)`           | `setLocale(String)` |                                         |\r\n\r\n### Query\r\n\r\n| Question                                   | Moment                  | Luxon                                            | Notes                                                                                           |\r\n| ------------------------------------------ | ----------------------- | ------------------------------------------------ | ----------------------------------------------------------------------------------------------- |\r\n| Is this time before that time?             | `m1.isBefore(m2)`       | `dt1 < dt2`                                      | The Moment versions of these take a unit. To do that in Luxon, use `startOf` on both instances. |\r\n| Is this time after that time?              | `m1.isAfter(m2)`        | `dt1 > dt2`                                      |                                                                                                 |\r\n| Is this time the same or before that time? | `m1.isSameOrBefore(m2)` | `dt1 <= dt2`                                     |                                                                                                 |\r\n| Is this time the same or after that time?  | `m1.isSameOrAfter(m2)`  | `dt1 >= dt2`                                     |                                                                                                 |\r\n| Do these two times have the same [unit]?   | `m1.isSame(m2, unit)`   | `dt1.hasSame(dt2, unit)`                         |                                                                                                 |\r\n| Is this time's [unit] before that time's?  | `m1.isBefore(m2, unit)` | `dt1.startOf(unit) < dt2.startOf(unit)`          |                                                                                                 |\r\n| Is this time's [unit] after that time's?   | `m1.isAfter(m2, unit)`  | `dt1.startOf(unit) > dt2.startOf(unit)`          |                                                                                                 |\r\n| Is this time between these two times?      | `m1.isBetween(m2, m3)`  | `Interval.fromDateTimes(dt2, dt3).contains(dt1)` |                                                                                                 |\r\n| Is this time inside a DST                  | `isDST()`               | `isInDST`                                        |                                                                                                 |\r\n| Is this time's year a leap year?           | `isInLeapYear()`        | `isInLeapYear`                                   |                                                                                                 |\r\n| How many days are in this time's month?    | `daysInMonth()`         | `daysInMonth`                                    |                                                                                                 |\r\n| How many days are in this time's year?     | None                    | `daysInYear`                                     |                                                                                                 |\r\n\r\n### Output\r\n\r\n#### Basics\r\n\r\nSee the [formatting guide](formatting.html) for more about the string-outputting methods.\r\n\r\n| Output           | Moment         | Luxon                       | Notes                                                                                                                                             |\r\n| ---------------- | -------------- | --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| simple string    | `toString()`   | `toString()`                | Luxon just uses ISO 8601 for this. See Luxon's `toLocaleString()`                                                                                 |\r\n| full ISO 8601    | `iso()`        | `toISO()`                   |                                                                                                                                                   |\r\n| ISO date only    | None           | `toISODate()`               |                                                                                                                                                   |\r\n| ISO time only    | None           | `toISOTime()`               |                                                                                                                                                   |\r\n| custom format    | `format(...)`  | `toFormat(...)`             | The format tokens differ between Moment and Luxon, such that the same format string cannot be used between the two.                               |\r\n| RFC 2822         |                | `toRFC2822()`               |                                                                                                                                                   |\r\n| HTTP date string |                | `toHTTP()`                  |                                                                                                                                                   |\r\n| JS Date          | `toDate()`     | `toJSDate()`                |                                                                                                                                                   |\r\n| Epoch time       | `valueOf()`    | `toMillis()` or `valueOf()` |                                                                                                                                                   |\r\n| Object           | `toObject()`   | `toObject()`                |                                                                                                                                                   |\r\n| Duration         | `diff(Moment)` | `diff(DateTime)`            | Moment's diff returns a count of milliseconds, but Luxon's returns a Duration. To replicate the Moment behavior, use `dt1.diff(d2).milliseconds`. |\r\n\r\n#### Humanization\r\n\r\nLuxon has `toRelative` and `toRelativeCalendar`. For internationalization, they use Intl.RelativeTimeFormat, which isn't currently supported by most browsers; in those cases, they fall back to English.\r\n\r\n| Operation            | Moment         | Luxon                                         |\r\n| -------------------- | -------------- | --------------------------------------------- |\r\n| Time from now        | `fromNow()`    | `toRelative()`                                |\r\n| Time from other time | `from(Moment)` | `toRelative({ base: DateTime })`              |\r\n| Time to now          | `toNow()`      | `DateTime.local().toRelative({ base: this })` |\r\n| Time to other time   | `to(Moment)`   | `otherTime.toRelative({ base: this })`        |\r\n| \"Calendar time\"      | `calendar()`   | `toRelativeCalendar()`                        |\r\n\r\n## Durations\r\n\r\nMoment Durations and Luxon Durations are broadly similar in purpose and capabilities. The main differences are:\r\n\r\n 1. Luxon durations have more sophisticated conversion capabilities. They can convert from one set of units to another using `shiftTo`. They can also be configured to use different unit conversions. See [Duration Math](math.html#duration-math) for more.\r\n 1. Luxon does not (yet) have an equivalent of Moment's Duration `humanize` method. Luxon will add that when [Intl.UnitFormat](https://github.com/tc39/proposal-intl-unit-format) is supported by browsers.\r\n 1. Like DateTimes, Luxon Durations have separate methods for creating objects from different sources.\r\n\r\nSee the [Duration API docs](../class/src/duration.js~Duration.html) for more.\r\n\r\n## Intervals\r\n\r\nMoment doesn't have direct support intervals, which must be provided by plugins like Twix or moment-range. Luxon's Intervals have similar capabilities to theirs, with the exception of the humanization features. See the [Interval API docs](../class/src/interval.js~Interval.html) for more.\r\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/isaac/code/luxon/docs/why.md",
    "name": "./docs/why.md",
    "content": "# Why does Luxon exist?\n\nWhat's the deal with this whole Luxon thing anyway? Why did I write it? How is it related to the Moment project? What's different about it? This page tries to hash all that out.\n\n## A disclaimer\n\nI should clarify here that I'm just one of Moment's maintainers; I'm not in charge and I'm not Moment's creator. The opinions here are solely mine. Finally, none of this is meant to bash Moment, a project I've spent a lot of time on and whose other developers I respect.\n\n## Origin\n\nLuxon started because I had a bunch of ideas on how to improve Moment but kept finding Moment wasn't a good codebase to explore them with. Namely:\n\n * I wanted to try out some ideas that I thought would provide a better, more explicit API but didn't want to break everything in Moment.\n * I had an idea on how to provide out-of-the-box, no-data-files-required support for time zones, but Moment's design made that difficult.\n * I wanted to completely rethink how internationalization worked by using the Intl API that comes packaged in browsers.\n * I wanted to use a modern JS toolchain, which would require a major retrofit to Moment.\n\nSo I decided to write something from scratch, a sort of modernized Moment. It's a combination of all the things I learned maintaining Moment and Twix, plus a bunch of fresh ideas. I worked on it in little slivers of spare time for about two years. But now it's ready to actually use, and the Moment team likes it enough that we pulled it under the organization's umbrella.\n\n## Ideas in Luxon\n\nLuxon is built around a few core ideas:\n\n 1. Keep the basic chainable date wrapper idea from Moment.\n 1. Make all the types immutable.\n 1. Make the API explicit; different methods do different things and have well-defined options.\n 1. Use the Intl API to provide internationalization, including token parsing. Fall back to English if the browser doesn't support those APIs.\n 1. Abuse the Intl API horribly to provide time zone support. Only possible for modern browsers.\n 1. Provide more comprehensive duration support.\n 1. Directly provide interval support.\n 1. Write inline docs for everything.\n\nThese ideas have some big advantages:\n\n 1. It's much easier to understand and debug code that uses Luxon.\n 1. Using native browser capabilities for internationalization leads to a much better behavior and is dramatically easier to maintain.\n 1. Luxon has the best time zone support of any JS date library.\n 1. Luxon's durations are both flexible and easy to use.\n 1. The documentation is very good.\n\nThey also have some disadvantages:\n\n 1. Using modern browser capabilities means that the fallback behavior introduces complexity for the programmer.\n 1. Never keeping internationalized strings in the code base means that some capabilities have to wait until the browsers provide it.\n 1. Some aspects of the Intl API are browser-dependent, which means Luxon's behavior is too.\n\n## Place in the Moment project\n\nLuxon lives in the Moment project because, basically, we all really like it, and it represents a huge improvement.\n\nBut Luxon doesn't quite fulfill Moment's mandate. First, it doesn't provide some of Moment's most commonly-used features, like relative date formatting. These features will [soon](https://github.com/tc39/proposal-intl-relative-time) be added to modern browsers and quickly folded into Luxon, but they aren't there yet. And even when they are, Luxon will only be able to provide that functionality to those newer environments. In fact, none of Luxon's Intl features work as expected on sufficiently outdated browsers, whereas Moment's all work everywhere. That represents a good tradeoff, IMO, but it's clearly a different one than Moment makes. Luxon makes a major break in API conventions. Part of Moment's charm is that you just call `moment()` on basically anything and you get date, whereas Luxon forces you to decide that you want to call `fromISO` or whatever. The upshot of all that is that Luxon feels like a different library; that's why it's not Moment 3.0.\n\nSo what is it then? We're not really sure. We're calling it a Moment labs project. Will its ideas get backported into Moment 3? Will it gradually siphon users away from Moment and become the focus of the Moment project? Will the march of modern browsers retire the arguments above and cause us to revisit branding Luxon as Moment? We don't know.\n\nThere, now you know as much as I do.\n\n## Future plans\n\nLuxon is fully usable and I plan to support it indefinitely. It's also largely complete. It will certainly add relative time formatting (and an English-only fallback) when that becomes possible. Luxon will also eventually strip out its fallbacks for missing platform features. But overall I expect the core functionality to stay basically as it is, adding mostly minor tweaks and bugfixes.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/isaac/code/luxon/changelog.md",
    "name": "./changelog.md",
    "content": "# Changelog\r\n\r\n## 1.13.2\r\n\r\n * Fixed ISO formatting for dates > 999\r\n\r\n## 1.13.1\r\n\r\n * Performance improvements for regex parsing\r\n\r\n## 1.13.0\r\n\r\n * Support numberSystem in fromFormat\r\n * Fix validity for bad initial zone specifiers\r\n\r\n## 1.12.1\r\n\r\n * Fix cross-month diffs in some scenarios\r\n * Fix time zone parsing when the time zone isn't at the end\r\n * Memoize IANA zone creation\r\n\r\n## 1.12.0\r\n\r\n * Add some explicit CDN support to the NPM package\r\n * Add week token to duration ISO support\r\n * Lots of cleanup and test coverage changes\r\n\r\n## 1.11.4\r\n\r\n * `setZone(\"local\")` now returns the defaultZone if it is set\r\n * Fixes for the polyfilled build\r\n\r\n## 1.11.3\r\n\r\n * Allow 24:00 in ISO (and other) strings\r\n * Fix some bugs with the typecheck functions like `DateTime.isDateTime()`\r\n\r\n## 1.11.2\r\n\r\n * Fixed handling of some characters in fromFormat literal sections\r\n * Hanlde string values in object arguments to DateTime methods\r\n * Fixed toRelativeCalendar's handling of zones in the base date\r\n\r\n## 1.11.1\r\n\r\n * Fix DateTime#plus() when spanning across AD 100\r\n\r\n## 1.11.0\r\n\r\n * Fix low-year handling for IANA zones\r\n * `DateTime#toLocal()` now uses the default locale\r\n * Fix zero duration formatting\r\n * Many documentation fixes\r\n\r\n## 1.10.0\r\n\r\n- Fix endOf(\"day\") during DSTs (#399)\r\n- Add `Interval#mapEndpoints (#400)\r\n- Add `DateTime#zone` and `Info.normalizeZone` (#404)\r\n\r\n## 1.9.0\r\n\r\n- Add `DateTime#toRelative` and `DateTime#toRelativeCalendar`\r\n\r\n## 1.8.3\r\n\r\n- Allow \"UTC\" in the zone position of `fromSQL`\r\n- Force `isDateTime` and `isDuration` to return booleans in all cases\r\n\r\n## 1.8.2\r\n\r\n- Trim leading \\u200e characters from offset names in Edge 16 and 17\r\n\r\n## 1.8.1\r\n\r\n- Add `DateTime.fromSeconds` and `DateTime#toSeconds`\r\n\r\n## 1.7.1\r\n\r\n- Floor the seconds instead of rounding them when outputting the 'X' format\r\n- Change the options to toLocale to override the configuration (the previous options were essentially ignored)\r\n\r\n## 1.6.2\r\n\r\n- Fixing merge error that resulted in bad error messages\r\n\r\n## 1.6.0\r\n\r\n- **midly breaking** Rework negative durations\r\n- Fix handling weekdays at the end of leap week years\r\n- Add isDuration, isDateTime, and isInterval\r\n- Fix handling of Luxon object arguments passed from other execution contexts\r\n\r\n## 1.5.0\r\n\r\n- Improved error message\r\n- Added DateTime#invalidExplanation, Duration#invalidExplanation, Interval#invalidExplanation to provide more details on invalid objects\r\n\r\n## 1.4.6\r\n\r\n- Cache Intl objects for an 85x speed up on basic operations using non-en locales\r\n\r\n## 1.4.5\r\n\r\n- Fix minified builds\r\n\r\n## 1.4.4\r\n\r\n- Fix hour formatting in RFC822 strings\r\n- Interval.fromISO accepts formats with durations\r\n\r\n## 1.4.3\r\n\r\nRemoval accidentally-introduced runtime dependency\r\n\r\n## 1.4.2\r\n\r\n- Handle locale strings with BCP 47 extensions. Especially helpful for environments with funky default locales\r\n- Support for [weekYear]-W[weekNumber] ISO 8601 strings\r\n\r\n## 1.4.1\r\n\r\n- Empty diffs now have all the asked-for units in them, set at 0\r\n- Duration operations perserve the superset of units\r\n\r\n## 1.4.0\r\n\r\n- Add x and X to toFormat for formatting Epoch seconds and Epoch milliseconds\r\n- Parser allows a wider range of IANA zone specifiers\r\n- BREAKING: Etc/GMT+10 is now interpreted as UTC-10, per spec\r\n\r\n## 1.3.3\r\n\r\nDocumentation fixes\r\n\r\n## 1.3.2\r\n\r\n- DateTime.fromMillis will throw if passed a non-number\r\n- Fixes for type checking across JS contexts\r\n\r\n## 1.3.1\r\n\r\n- Include milliseconds in Duration#toISO\r\n- Avoid deprecation warning from DateTime#inspect in Node 10\r\n\r\n## 1.3.0\r\n\r\n- **mildly breaking change** Duration.toFormat now floors its outputs instead of rounding them (see #224)\r\n- Added 'floor' option to Duration.toFormat and deprecated the 'round' option\r\n- Added `Dateime.toBSON`\r\n- Fixed infinite loop when passing invalid or zero-length durations to Interval#splitBy\r\n- Added better error handling to Duration.fromObject()\r\n\r\n## 1.2.1\r\n\r\n- 222x speed-up in DateTime creation for non-en locales\r\n- Added `DateTime#toMillis` alias for `DateTime#valueOf`\r\n- Fixed types on zone exports\r\n\r\n## 1.2.0\r\n\r\n- Export Zone classes\r\n- Fix `endOf` and `startOf` for quarters\r\n- Change `toFormat(\"Z\")` to return a number for UTC\r\n- Allow \"GTM\" as an argument to `setZone`\r\n\r\n## 1.1.0\r\n\r\n- Support for zone names with more than two components\r\n- Fixed long-term-accurate conversions for months\r\n- Added `weeksInWeekYear`\r\n\r\n## 1.0.0\r\n\r\n- The big one-oh. No changes from 0.5.8.\r\n\r\n## 0.5.8\r\n\r\n- Large perf improvements for `DateTime#toFormat()`, when using non-intl numbers\r\n\r\n## 0.5.7\r\n\r\n- Added AMD build to the NPM package\r\n- Large performance improvements to technical formatting (e.g. `DateTime#toISO`)\r\n\r\n## 0.5.6\r\n\r\n- Refactor internals\r\n- Added support for fractional seconds in `Duration.fromISO`\r\n- Added browser global to the NPM package\r\n\r\n## 0.5.5\r\n\r\n- Best-we-can-do fix for `DateTime#toLocaleString()` for fixed-offset zones when showing the zone name in the output\r\n- Fixed `Duration#shiftTo` for unormalized Durations that need a rollup cascade\r\n\r\n## 0.5.4\r\n\r\n- Fix default locales in Node\r\n- Fix prototype to help with React inspection\r\n- Improve REPL output for Durations in Node\r\n\r\n## 0.5.3\r\n\r\n- Remove errant ICU runtime dep (again)\r\n\r\n## 0.5.2\r\n\r\n- Remove comments from minified builds (introduced by 0.5.1)\r\n\r\n## 0.5.1\r\n\r\n- Fixed minified builds (oops)\r\n- Fix computation of fractional parts of diffs\r\n\r\n## 0.5.0\r\n\r\n- `isBefore()` returns true for the end of the interval, consistent with being half-open\r\n- `zoneName` now rturns `null` for invalid DateTimes\r\n- Added quarter support\r\n- Adding a month to Jan 31 gives Feb 28/29\r\n\r\n## 0.4.0\r\n\r\n- Always round down to the nearest millisecond when parsing\r\n\r\n## 0.3.1\r\n\r\n- Fixed `toLocaleString` for fixed-offset zones in the absence of Intl\r\n- Added `Info.isValidIANAZone`\r\n- Made malformed zone specifiers result in invalid DateTime instances\r\n\r\n## 0.3.0\r\n\r\n- Rename DateTime.fromString to DateTime.fromFormat (leaving deprecated DateTime.fromString)\r\n- Rename DateTime.fromStringExplain to DateTime.fromFormatExplain (leaving deprecated DateTime.fromStringExplain)\r\n- Support Etc/GMT IANA zones\r\n- Perf fixes for zones\r\n- Rework build infrastructure\r\n\r\n## 0.2.12\r\n\r\n- Fix DateTime.fromObject's handling of default zones\r\n- Change `keepCalendarTime` to `keepLocalTime`\r\n\r\n## 0.2.11\r\n\r\n- Handle no arguments in `DateTime.min` and `DateTime.max`\r\n- Documentation fixes\r\n\r\n## 0.2.10\r\n\r\n- Fix bug where Durations could sometimes mutate\r\n\r\n## 0.2.9\r\n\r\n- Fix `DateTime.fromMillis(0)` more thoroughly\r\n\r\n## 0.2.8\r\n\r\n- Fix sourcemaps\r\n\r\n## 0.2.7\r\n\r\n- Fix `DateTime.fromMillis(0)`\r\n\r\n## 0.2.6\r\n\r\n- Fix 'h' and 'hh' `toFormat` tokens for midnight\r\n\r\n## 0.2.5\r\n\r\n- Better `shiftTo` behavior for durations with floating point components\r\n\r\n## 0.2.4\r\n\r\n- Fix `toHTTP` to use 24-hour hours\r\n- Tighten up regular expressions\r\n- Various documentation fixes\r\n\r\n## 0.2.3\r\n\r\n- Fixes for `diff` with multiple units\r\n\r\n## 0.2.2\r\n\r\n- Fixes for `fromSQL`, `toSQL`, `toSQLTime`, and `toSQLDate`\r\n- Add `includeOffset` option to `toISO` and `toISOTime`\r\n\r\n## 0.2.1\r\n\r\n- Add `module` field to package.json\r\n\r\n## 0.2.0\r\n\r\n- Remove polyfills from main builds\r\n- Update compilation toolchain to target builds more exactly\r\n- Fix IE in polyfill build\r\n\r\n## 0.1.0\r\n\r\n- Add `.fromSQL`, `#toSQL`, `#toSQLTime`, `#toSQLDate`\r\n- Fix AM/PM parsing\r\n- Major perf improvements\r\n- Default to system locale when using macro formats in `#toFormat`\r\n- `.fromISO` accepts standalone times\r\n- See https://github.com/moment/luxon/issues/93 for important news concerning field accessibility\r\n\r\n## 0.0.22\r\n\r\n- Add 'u' formatting and parsing\r\n- Add 'y', 'yyyyy', and 'yyyyyy' parsing tokens\r\n- Add 'yyyyyy' formatting token\r\n- Better error messages for missing arguments to `DateTime.fromString`\r\n\r\n## 0.0.21\r\n\r\n- Fix zones for Edge\r\n\r\n## 0.0.20\r\n\r\n- Fix `fromISO` to accept various levels of subsecond precision\r\n\r\n## 0.0.19\r\n\r\n- Fixed parsing for ordinals\r\n- Made parsing stricter\r\n\r\n## 0.0.18\r\n\r\n- Fixed formatting for non-hour aligned fixed-offset zones\r\n- Fixed longterm conversion accuracy option in diffs\r\n- Fixed invalid handling in `Interval#set`\r\n\r\n## 0.0.17\r\n\r\n- Fixing formatting for fixed-offset zones\r\n\r\n## 0.0.16\r\n\r\n- Fixes for IE 9 & 10\r\n\r\n## 0.0.15\r\n\r\n- Fixing busted release 0.0.14\r\n\r\n## 0.0.13\r\n\r\n- toLocaleString() and others default to the system's locale\r\n- support for ISO week durations in `Duration.fromISO`\r\n\r\n## 0.0.12\r\n\r\n- Improve non-Intl fallbacks for toLocaleString\r\n- Fix `offsetNameShort` and `offsetNameLong` for non-Intl environments\r\n- Added `weekdayShort`, `weekdayLong`, `monthShort`, `monthLong` DateTime getters\r\n\r\n## 0.0.10\r\n\r\n- Only include build dir in NPM module\r\n\r\n## 0.0.9\r\n\r\n- Move to Moment Github org\r\n\r\n## 0.0.8\r\n\r\n- The local zone can now report its IANA name\r\n- Fixed parsing bug for `yy` and `kk`\r\n- Improved test coverage\r\n\r\n## 0.0.7\r\n\r\n- Added `toLocaleParts`\r\n- Slightly more friendly month/weekday parsing\r\n- Default locale setting\r\n\r\n## 0.0.6\r\n\r\n- Stricter `toJSDate`\r\n- `fromISO` now supports `year` and `year-month` formats\r\n- More graceful degradation in the absence of platform features\r\n\r\n## 0.0.5\r\n\r\nExperimental, but now broadly useful.\r\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/isaac/code/luxon/contributing.md",
    "name": "./contributing.md",
    "content": "# Contributing to Luxon\r\n\r\n## General guidelines\r\n\r\nPatches are welcome. Luxon is at this point just a baby and it could use lots of help. But before you dive in...Luxon is one of those tightly-scoped libraries where the default answer to \"should this library do X?\" is likely \"no\". **So ask first!** It might save you some time and energy.\r\n\r\nHere are some vague notes on Luxon's design philosophy:\r\n\r\n1.  We won't accept patches that can't be internationalized using the JS environment's (e.g. the browser's) native capabilities. This means that most convenient humanization features are out of scope.\r\n1.  We try hard to have a clear definition of what Luxon does and doesn't do. With few exceptions, this is not a \"do what I mean\" library.\r\n1.  Luxon shouldn't contain simple conveniences that bloat the library to save callers a couple lines of code. Write those lines in your own code.\r\n1.  Most of the complexity of JS module loading compatibility is left to the build. If you have a \"this can't be loaded in my bespoke JS module loader\" problems, this isn't something you should be solving with changes to the `src` directory. If it's a common use case and is possible to generate with Rollup, it can get its own build command.\r\n1.  We prefer documentation clarifications and gotchas to go in the docstrings, not in the guides on the docs page. Obviously, if the guides are wrong, they should be fixed, but we don't want them to turn into troubleshooting pages. On the other hand, making sure the method-level documentation has ample examples and notes is great.\r\n1.  You'll need to sign a CLA as part of your first pull request to Luxon.\r\n\r\n## Building and testing\r\n\r\nBuilding and testing is done through npm scripts. The tests run in Node and require Node 10+ with full-icu support. This is because some of the features available in Luxon (like internationalization and time zones) need that stuff and we test it all. On any platform, if you have Node 10 installed with full-icu, you're good to go; just run npm scripts like `npm run test`. But you probably don't have that, so read on.\r\n\r\n### OSX\r\n\r\nMac is easy:\r\nOpen the terminal.\r\n\r\n```\r\nbrew install node --with-full-icu\r\nnpm install\r\n./scripts/test\r\n```\r\n\r\nIf that's for whatever reason a pain, the Linux instructions should also work, as well as the Docker ones.\r\n\r\n### Linux\r\n\r\nThere are two ways to get full-icu support in Linux: build it with that support, or provide it as a module. We'll cover the latter. Assuming you've installed Node 10:\r\n\r\n```\r\nnpm install\r\nnpm install full-icu\r\n./scripts/test\r\n```\r\n\r\nWhere `scripts/test` is just `NODE_ICU_DATA=\"$(pwd)/node_modules/full-icu\" npm run test`, which is required for making Node load the full-icu module you just installed. You can run all the other npm scripts (e.g. `npm run docs`) directly; they don't require Intl support.\r\n\r\n### Windows\r\n\r\nIf you have [Bash](https://git-scm.com/downloads) or [WSL](https://docs.microsoft.com/en-us/windows/wsl/install-win10), the Linux instructions seem to work fine.\r\n\r\nI would love to add instructions for a non-WSL install of the dev env!\r\n\r\n### Docker\r\n\r\nIn case messing with your Node environment just to run Luxon's tests is too much to ask, we've provided a Docker container. You'll need a functioning Docker environment, but the rest is easy:\r\n\r\n```\r\n./docker/npm install\r\n./docker/npm run test\r\n```\r\n\r\n## Patch basics\r\n\r\nOnce you're sure your bugfix or feature makes sense for Luxon, make sure you take these steps:\r\n\r\n1.  Be sure to add tests and run them with `scripts/test`\r\n1.  Be sure you run `npm run lint!` before you commit. Note this will modify your source files to line up with the style guidelines.\r\n1.  Make sure you add or ESDoc annotations appropriately. You can run `npm run docs` to generate the HTML for them. They land in the `build/docs` directory. This also builds the markdown files in `/docs` into the guide on the Luxon website.\r\n1.  To test Luxon in your browser, run `npm run site` and then open `build/demo/global.html`. You can access Luxon classes in the console like `window.luxon.DateTime`.\r\n1.  To test in Node, run `npm run build` and then run something like `var DateTime = require('./build/cjs/luxon').DateTime`.\r\n\r\nLuxon uses [Husky](https://github.com/typicode/husky) to run the formatter on your code as a pre-commit hook. You should still run `npm run lint!` yourself to catch other issues, but this hook will help prevent you from failing the build with a trivial formatting error.\r\n\r\n## npm script reference\r\n\r\n| Command                      | Function                                |\r\n| ---------------------------- | --------------------------------------- |\r\n| `npm run build`              | Build all the distributable files       |\r\n| `npm run build-node`         | Build just for Node                     |\r\n| `npm run test`               | Run the test suite, but see notes above |\r\n| `npm run format`             | Run the Prettier formatter              |\r\n| `npm run lint!`              | Run the formatter and the linter        |\r\n| `npm run docs`               | Build the doc pages                     |\r\n| `npm run site`               | Build the Luxon website                 |\r\n| `npm run check-doc-coverage` | Check whether there's full doc coverage |\r\n",
    "static": true,
    "access": "public"
  }
]